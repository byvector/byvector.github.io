<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[vector's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.supce.com/"/>
  <updated>2016-10-09T12:25:32.015Z</updated>
  <id>http://blog.supce.com/</id>
  
  <author>
    <name><![CDATA[vector]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之水平居中&垂直居中]]></title>
    <link href="http://blog.supce.com/2016/10/09/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD&%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://blog.supce.com/2016/10/09/CSS Secret 读书笔记之水平居中&垂直居中/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2016-10-09T12:25:32.015Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="水平居中">水平居中</h1><h2 id="行内元素">行内元素</h2><p>对于<code>&lt;span&gt;</code> <code>img</code> <code>&lt;input&gt;</code>等行内元素，只需要给父元素设置<code>text-align: center</code></p>
<h2 id="定宽块级元素">定宽块级元素</h2><p>对于<code>div</code> <code>p</code> 等块级元素，如果是定宽，只需要给该元素设置左右<code>margin</code>为<code>auto</code></p>
<h2 id="不定宽块级元素">不定宽块级元素</h2><ul>
<li>方法一：改变块级元素<code>display</code>为<code>inline</code>或者<code>inline-block</code>，然后设置父元素<code>text-align</code>为<code>center</code></li>
</ul>
<a id="more"></a>
<p>比如：</p>
<pre><code>&lt;div&gt;
    &lt;ul&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> <span class="keyword">one</span>&lt;/<span class="keyword">li</span>&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> <span class="keyword">one</span>&lt;/<span class="keyword">li</span>&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> <span class="keyword">two</span>&lt;/<span class="keyword">li</span>&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> <span class="keyword">one</span>&lt;/<span class="keyword">li</span>&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> <span class="keyword">two</span>&lt;/<span class="keyword">li</span>&gt;
        &lt;<span class="keyword">li</span>&gt;<span class="keyword">test</span> three&lt;/<span class="keyword">li</span>&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="tag">ul</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
}</span>
<span class="tag">li</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-01.jpg" alt=""></p>
<p><em>这种方法虽然实现了居中，但是会导致块级元素功能的缺失，上面例子中已经无法给li设置宽和高（虽然可以利用margin和padding产生视觉上的宽和高）当然也可以直接设置li为inline-block</em></p>
<ul>
<li>方法二：通过给父元素设置float，然后父元素设置position:relative和left:50%，子元素设置position:relative和left:-50%来实现水平居中。</li>
</ul>
<p>其基本原理如下：</p>
<p>1、没有浮动的div：大家都知道div是一个块元素，其默认的宽度就是100%：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-02.jpg" alt=""><br>2、如果div设置了浮动之后，他的内容有多宽度就会撑开有多大的容器（除了显式设置元素宽度值）：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-03.jpg" alt=""><br>3、设置ul浮动到左侧：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-04.jpg" alt=""><br>4、然后设置ul的position为relative，让其在原来的位置右移50%(left:50%)<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-05.jpg" alt=""><br>5、最后我们在li上设置<code>position:relative</code>，但其移动的方向和ul移动的方向刚好是反方向，而其移动的值保持一致:<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-06.jpg" alt=""></p>
<p>保持HTML不变CSS代码如下：</p>
<pre><code><span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="tag">ul</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>;  <span class="comment">/*清除浮动*/</span>
}</span>
<span class="tag">li</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">2px</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"> -<span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-07.jpg" alt=""></p>
<ul>
<li>方法三：在元素外加入table标签（包括 table、tbody、tr、td），该元素写在 td 内，然后设置左右margin的值为auto</li>
</ul>
<blockquote>
<p>在CSS Secret 读书笔记之结构与布局(一)中知道，如果是默认的自动表格布局算法，单元格的宽度是根据内容的宽度来进行分配的，这恰好是使用该方法的前提。</p>
</blockquote>
<p>HTML:</p>
<pre><code><span class="tag">&lt;<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">table</span>&gt;</span>
        <span class="tag">&lt;<span class="title">tbody</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">ul</span>&gt;</span>
                        <span class="tag">&lt;<span class="title">li</span>&gt;</span>test one<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                        <span class="tag">&lt;<span class="title">li</span>&gt;</span>test two<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                        <span class="tag">&lt;<span class="title">li</span>&gt;</span>test three<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
                    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
                <span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">tbody</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">table</span>&gt;</span>    
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>CSS:</p>
<pre><code><span class="tag">div</span><span class="rules">{
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
        <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed <span class="hexcolor">#333</span></span></span>;
    }</span>
    <span class="tag">table</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    }</span>
    <span class="tag">ul</span><span class="rules">{
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
        <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    }</span>
    <span class="tag">li</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">2px</span></span></span>;
        <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
        <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
    }</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-08.jpg" alt=""></p>
<hr>
<h1 id="垂直居中">垂直居中</h1><p>1、对于父元素高度不确定的文本，图片和块级元素：：<br>设置父元素的上下内边距相同。<br>HTML: </p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent one"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"centered"</span>&gt;
        &lt;h3&gt;this <span class="keyword">is</span> a test&lt;/h3&gt;
        &lt;p&gt;this <span class="keyword">div</span> <span class="keyword">is</span> centered&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#c0c0c0</span></span></span>;
}</span>
<span class="class">.centered</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="hexcolor">#a0a0a0</span> solid <span class="number">1px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#f5f5f5</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-09.jpg" alt=""></p>
<p>2、对于父元素高度确定的单行文本：<br>设置父元素的<code>height</code>与<code>line-height</code>两个属性的值相同。</p>
<p><em>当<code>line-height</code>的值大于<code>font-size</code>时，会将大于的部分平均分配到文字的上下两端</em></p>
<p>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"single_line"</span>&gt;
    this <span class="keyword">is</span> a test. 
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.single_line</span><span class="rules">{
    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">15px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">40px</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-10.jpg" alt=""></p>
<p>3、对于多行文本：<br>设置父元素display为table，要被居中的元素display为table-cell和vertical-algin为middle<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"out"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"in"</span>&gt;
        这是一个多行文本，这是一个多行文本，这是一个多行文本
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.out</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">250px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#c0c0c0</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> table</span></span>;
}</span>
<span class="class">.in</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> table-cell</span></span>;
    <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> middle</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-11.jpg" alt=""></p>
<p>4、inline-block方法：<br>设置元素<code>display:inline-block;</code> <code>vertical-align:middle</code>，为父元素设置after伪元素，将伪元素的display和vertical属性分别设置为inline-block和middle，最后设置伪元素高度与父元素高度相同(<code>height:100%</code>)</p>
<p><em>由于行内框的高度是由最高的行内框决定的，设置伪元素高度与父元素高度一致，然后利用vertical-algin即可</em></p>
<p>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container one"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"centered-one centered"</span>&gt;
        &lt;h1&gt;this <span class="keyword">is</span> a test&lt;/h1&gt;
        &lt;p&gt;this <span class="keyword">div</span> <span class="keyword">is</span> centered&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.container</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">250px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#c0c0c0</span></span></span>;
}</span>
<span class="class">.centered</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="hexcolor">#a0a0a0</span> solid <span class="number">1px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#f5f5f5</span></span></span>;
}</span>
<span class="class">.centered-one</span>,<span class="rule"><span class="attribute">.one</span>:<span class="value">after{
    display: inline-block</span></span>;
    <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> middle</span></span>;
}
<span class="rule"><span class="attribute">.one</span>:<span class="value">after{
    content: <span class="string">''</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-12.jpg" alt=""></p>
<p>5、对于宽高确定的元素：</p>
<p>方法一：利用绝对定位<br>设置父元素的position为relative，设置要垂直居中的元素position为absolute，top和bottom为0，上下外边距为auto。</p>
<blockquote>
<p>元素在过度受限情况下，将margin设置为auto，浏览器会重算margin的值，过度受限指的是同时设置top/bottom与height或者left/right与width</p>
</blockquote>
<p>计算公式为：</p>
<blockquote>
<p>‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度，在其他值不是auto的时候，margin-top和margin-bottom是可以根据上式算出的</p>
</blockquote>
<p>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container two"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"centered-two centered"</span>&gt;
        &lt;h1&gt;this <span class="keyword">is</span> a test&lt;/h1&gt;
        &lt;p&gt;this <span class="keyword">div</span> <span class="keyword">is</span> centered&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.container</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">250px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#c0c0c0</span></span></span>;
}</span>
<span class="class">.centered</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="hexcolor">#a0a0a0</span> solid <span class="number">1px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#f5f5f5</span></span></span>;
}</span>
<span class="class">.two</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
}</span>
<span class="class">.centered-two</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">0</span></span></span>; <span class="rule"><span class="attribute">bottom</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value">auto <span class="number">0</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-13.jpg" alt=""></p>
<p>方法二：利用负边距<br>设置父元素的position为relative，设置要垂直居中的元素position为absolute，top为50%，margin-top为高度的一般。</p>
<p><em>通过设置top为50%，将元素的左上角放在父元素的垂直中心，在利用margin-top为高度的一半，将元素的垂直中心与父元素的垂直中心重合</em></p>
<p>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container three"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"centered-three centered"</span>&gt;
        &lt;h1&gt;this <span class="keyword">is</span> a test&lt;/h1&gt;
        &lt;p&gt;this <span class="keyword">div</span> <span class="keyword">is</span> centered&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.container</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">250px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#c0c0c0</span></span></span>;
}</span>
<span class="class">.centered</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="hexcolor">#a0a0a0</span> solid <span class="number">1px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#f5f5f5</span></span></span>;
}</span>
<span class="class">.three</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
}</span>
<span class="class">.centered-three</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> -<span class="number">75px</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-14.jpg" alt=""></p>
<blockquote>
<p>如果想要水平也居中，可以同时设置left为50%，margin-left为负的宽度的一半。</p>
</blockquote>
<p>如果支持CSS3的话，为了增强自适应性，可以使用<code>translateY()</code>变形函数，这个函数支持百分比。<br>修改CSS代码如下：</p>
<pre><code><span class="class">.centered-three</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="comment">/*width: 300px;
    height: 150px;
    margin-top: -75px;*/</span>
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">10em</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateY</span>(-<span class="number">50%</span>)</span></span>;
}</span>
</code></pre><blockquote>
<p>想要水平垂直居中，可以同时设置<code>left:50%</code>,<code>transform:transform(-50%,-50%)</code></p>
</blockquote>
<p>6、Flex布局<br>这个比较简单<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"container four"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"centered-four centered"</span>&gt;
        &lt;h1&gt;this <span class="keyword">is</span> a test&lt;/h1&gt;
        &lt;p&gt;this <span class="keyword">div</span> <span class="keyword">is</span> centered&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.four</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">align-items</span>:<span class="value"> center</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-15.jpg" alt=""></p>
<p>如果想要水平垂直居中，只需修改CSS代码如下：</p>
<pre><code><span class="class">.four</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="comment">/*align-items: center;*/</span>
}</span>
<span class="class">.centered-four</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-18-16.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="水平居中">水平居中</h1><h2 id="行内元素">行内元素</h2><p>对于<code>&lt;span&gt;</code> <code>img</code> <code>&lt;input&gt;</code>等行内元素，只需要给父元素设置<code>text-align: center</code></p>
<h2 id="定宽块级元素">定宽块级元素</h2><p>对于<code>div</code> <code>p</code> 等块级元素，如果是定宽，只需要给该元素设置左右<code>margin</code>为<code>auto</code></p>
<h2 id="不定宽块级元素">不定宽块级元素</h2><ul>
<li>方法一：改变块级元素<code>display</code>为<code>inline</code>或者<code>inline-block</code>，然后设置父元素<code>text-align</code>为<code>center</code></li>
</ul>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之结构与布局(二)]]></title>
    <link href="http://blog.supce.com/2016/10/01/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B8%83%E5%B1%80(%E4%BA%8C)/"/>
    <id>http://blog.supce.com/2016/10/01/CSS Secret 读书笔记之结构与布局(二)/</id>
    <published>2016-09-30T16:00:00.000Z</published>
    <updated>2016-10-01T13:31:30.640Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="根据兄弟元素的数量设置样式">根据兄弟元素的数量设置样式</h1><p>有时候会碰见这样一种场景：当一个列表不断延长时，通过隐藏空间或压缩控件等方式来节省屏幕空间，用来提升用户体验。<br>这时候就需要我们根据兄弟元素的总数来为它们设置相应的样式。<br>设想一个列表，假设仅当列表的总数为4时才对这些列表项设置样式，这时可以使用<code>li:nth-child(4)</code>来选中列表的第四个列表项。但是我们的需求却是：<br><em>在列表的总数为4时选中每个列表项</em><br>如果直接利用兄弟选择符<code>li:nth-child(4),li:hth-child(4)~li</code>得到的是第四个列表以及它之后的所有列表项。那么我们转换一下思路分以下几种情况：<br>当只有一个列表项时，直接利用<code>:only-child</code>即：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:only-child</span>{
    <span class="comment">/*只有一个列表时的样式*/</span>
}
</code></pre><a id="more"></a>
<p>对于只有一个列表项的列表，其第一项同时也是该列表的最后一项。也就是说<code>:only-child</code>等效于<code>:first-child:last-child</code>，而<code>:last-child</code>是<code>nth-last-child(1)</code>的简写，所以：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(<span class="number">1</span>){
    <span class="comment">/*等效于:only-child*/</span>
}
</code></pre><p><em>tips :nth-last-child(n) 选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。</em></p>
<p>由上面可以得出对于一个正好包含4项的列表，如果想命中所有列表项，可以这样写：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(<span class="number">4</span>),
<span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(<span class="number">4</span>)~<span class="tag">li</span>{
    <span class="comment">/*列表包含4项且命中所有项*/</span>
}
</code></pre><p>根据<a href="http://www.w3school.com.cn/cssref/selector_nth-last-child.asp" target="_blank" rel="external">参考手册</a>，<code>:nth-last-child()</code>选择器的参数不仅仅可以是简单的数字，也可以是类似于an+b的表达式，其中，n 是计数器（从 0 开始），b 是偏移值。<br>比如，我们指定了下标是 3 的倍数的所有p元素的背景色，从最后一个子元素开始计数：</p>
<pre><code><span class="tag">p</span><span class="pseudo">:nth-last-child</span>(<span class="number">3</span>n+<span class="number">0</span>){
    <span class="attribute">background</span>:<span class="hexcolor">#ff0000</span>;
}
</code></pre><p>而对于n+b(相当于a=1)这个公式，无论n如何取值，这个表达式都无法产生一个小于b的值，可以选中从第b个开始的所有子元素。<br>因此：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(n+<span class="number">4</span>),
<span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(n+<span class="number">4</span>)~<span class="tag">li</span>{
    <span class="comment">/*列表至少包含4项且命中所有项*/</span>
}
</code></pre><p>同理，-n+b这种形式的表达式可以选中开头的b个元素。因此仅当列表中有4个或更少的列表时，可以这样写:</p>
<pre><code><span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(-n+<span class="number">4</span>),
<span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(-n+<span class="number">4</span>)~<span class="tag">li</span>{
   <span class="comment">/*列表最多包含4项且命中所有项*/</span>
}
</code></pre><p>如果想命中包含2-6个列表项的列表时，只需把上面两种技巧组合一下：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(n+<span class="number">2</span>)<span class="pseudo">:nth-last-child</span>(-n+<span class="number">6</span>),
<span class="tag">li</span><span class="pseudo">:first-child</span><span class="pseudo">:nth-last-child</span>(n+<span class="number">2</span>)<span class="pseudo">:nth-last-child</span>(-n+<span class="number">6</span>)~<span class="tag">li</span>{
    <span class="comment">/*当列表包含2-6项时，命中列表中所有列表项*/</span>
}
</code></pre><p>利用上面的技巧可以写一个类似于变色便签的小例子：<br>HTML：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"palette"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"color-options"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"add"</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Add<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"delete"</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Delete<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"input-group"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">rows</span>=<span class="value">"12"</span> <span class="attribute">class</span>=<span class="value">"form-control"</span>&gt;</span>write someting...<span class="tag">&lt;/<span class="title">textarea</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>CSS:</p>
<pre><code><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
    <span class="tag">ul</span><span class="rules">{
        <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    }</span>
    <span class="class">.palette</span><span class="rules">{
        <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
        <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">900px</span></span></span>;
        <span class="rule"><span class="attribute">font</span>:<span class="value"> bold <span class="number">90%</span>/<span class="number">1</span> sans-serif</span></span>;
    }</span>
    <span class="class">.palette</span> <span class="tag">li</span><span class="rules">{
        <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span></span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#D6E055</span></span></span>;
    }</span>
    <span class="class">.color-options</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>)</span></span>;
        <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">15px</span></span></span>;
        <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
    }</span>
    <span class="class">.color-options</span> <span class="tag">a</span><span class="rules">{
        <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
        <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
    }</span>
    <span class="class">.color-options</span> <span class="rule"><span class="attribute">a</span>:<span class="value">before{
        display: inline-block</span></span>;
        <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1rem</span></span></span>;
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1.2rem</span></span></span>;
        <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> .<span class="number">3rem</span></span></span>;
        <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1.2</span></span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;
        <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    }
    <span class="class">.color-options</span> <span class="rule"><span class="attribute">.add</span>:<span class="value">before {
        content:<span class="string">'✚'</span></span></span>;
        <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#590</span></span></span>;
    }
    <span class="class">.color-options</span> <span class="rule"><span class="attribute">.delete</span>:<span class="value">before {
        content:<span class="string">'✖'</span></span></span>;
        <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#b00</span></span></span>;
    }

    <span class="class">.color-options</span> <span class="rule"><span class="attribute">a</span>:<span class="value">after {
        content: <span class="string">' color'</span></span></span>;
        <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> normal</span></span>;
    }
    <span class="class">.add</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value">left</span></span>; }</span>
    <span class="class">.delete</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>; }</span>

    <span class="class">.palette</span> <span class="rule"><span class="attribute">li</span>:<span class="value">only-child .delete{
        display: none</span></span>;
    }
    <span class="class">.palette</span> <span class="rule"><span class="attribute">li</span>:<span class="value">first-child:<span class="function">nth-last-child</span>(n+<span class="number">4</span>) .color-options a:after,
    .palette li:first-child:<span class="function">nth-last-child</span>(n+<span class="number">4</span>) ~ li .color-options a:after{
        content: none</span></span>;
    }
    <span class="class">.palette</span> <span class="rule"><span class="attribute">li</span>:<span class="value">first-child:<span class="function">nth-last-child</span>(n+<span class="number">4</span>) .color-options a,
    .palette li:first-child:<span class="function">nth-last-child</span>(n+<span class="number">4</span>) ~ li .color-options a{
        font-size: <span class="number">0</span></span></span>;
        <span class="rule"><span class="attribute">color</span>:<span class="value"> transparent</span></span>;
    }
    <span class="class">.input-group</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">20px</span></span></span>;
    }</span>
    <span class="class">.form-control</span><span class="rules">{
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">120%</span>/<span class="number">1</span> sans-serif</span></span>;
        <span class="rule"><span class="attribute">box-sizing</span>:<span class="value">border-box</span></span>; <span class="comment">/*防止溢出*/</span>
        <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">15px</span></span></span>;
        <span class="rule"><span class="attribute">outline</span>:<span class="value"> none</span></span>;
        <span class="rule"><span class="attribute">resize</span>:<span class="value"> none</span></span>;
    }</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre><p>JS:</p>
<pre><code>&lt;script <span class="keyword">type</span>=<span class="string">"text/javascript"</span>&gt;
    <span class="keyword">var</span> colors = [
        '<span class="comment">#FEE169', '#CDD452', '#2E95A3', '#F9722E',</span>
        '<span class="comment">#E6E2AF', '#A7A37E', '#EFECCA', '#046380', </span>
        '<span class="comment">#50B8B4', '#C6FFFA', '#E2FFA8', '#D6E055','#C9313D'</span>
    ],
    palette = document.querySelector('.palette'),
    <span class="keyword">template</span> = palette.firstElementChild;
    function addColor(<span class="keyword">template</span>){
        <span class="keyword">var</span> li = <span class="keyword">template</span>.cloneNode(<span class="literal">true</span>);
        <span class="keyword">var</span> color = colors.shift();
        colors.push(color);
        li.style.background = color;
        // palette.insertBefore(li,<span class="keyword">template</span>.nextSibling);
        palette.appendChild(li);
    }
    palette.onclick = function(evt){
        <span class="keyword">var</span> button = evt.target;
        <span class="keyword">if</span>(button.className == 'add'){
            addColor(button.parentNode.parentNode)
        }<span class="keyword">else</span> <span class="keyword">if</span>(button.className == 'delete'){
            <span class="keyword">if</span>(confirm('您确定删除?')){
                <span class="keyword">var</span> li = button.parentNode.parentNode;
                li.parentNode.removeChild(li);
            }   
        }
    }
&lt;/script&gt;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-17-1.gif" alt=""></p>
<hr>
<h1 id="紧贴底部的页脚">紧贴底部的页脚</h1><p>有一个具有块级样式的页脚，当页面内容足够长时它一切正常，而当页面比较短时，就会出现问题。此时的问题在于页脚不能像我们期望中那样“紧贴”在视口的最底部，而是紧跟在内容的下方。</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-17-2.jpg" alt=""></p>
<blockquote>
<p>上图是将内容div删掉后的天津教育考试院官网</p>
</blockquote>
<p>针对于这种情况可以用下面两种方式解决：</p>
<h2 id="基于固定高度的解决方案">基于固定高度的解决方案</h2><p>这种方案的主要思路是：假设页脚的文本不折行，然后估算出页脚实际所占的高度。然后再计算出页头的高度。最后借助视口相关的长度单位以及<code>calc()</code>函数，把页脚固定到底部。其核心代码为：</p>
<pre><code><span class="tag">main</span><span class="rules">{
    <span class="rule"><span class="attribute">min-height</span>:<span class="value"><span class="function">calc</span>(<span class="number">100vh</span> - 页头高度 - 页脚高度)</span></span>;
    <span class="comment">/*避免内边距或边框扰乱高度的计算*/</span>
    <span class="rule"><span class="attribute">box-sizing</span>:<span class="value">border-box</span></span>;
}</span>
</code></pre><p>举个例子，HTML：</p>
<pre><code><span class="tag">&lt;<span class="title">header</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;/<span class="title">header</span>&gt;</span>
<span class="tag">&lt;<span class="title">main</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>
        空空道人看了一回，晓得这石头有些来历，遂向石头说道：“石兄，你这一段故事，据你自己说来，有些趣味，故镌写在此，意欲闻世传奇。据我看来：第一件，无朝代年纪可考；第二件，并无大贤大忠、理朝廷、治风俗的善政，其中只不过几个异样女子，或情或痴，或小才微善。我纵然抄去，也算不得一种奇书。”石头果然答道：“我师何必太痴！我想历来野史的朝代，无非假借汉、唐的名色；莫如我这石头所记不借此套，只按自己的事体情理，反倒新鲜别致。况且那野史中，或讪谤君相，或贬人妻女，奸淫凶恶，不可胜数；更有一种风月笔墨，其淫秽污臭最易坏人子弟。至于才子佳人等书，则又开口‘文君’，满篇‘子建’，千部一腔，千人一面，且终不能不涉淫滥。在作者不过要写出自己的两首情诗艳赋来，故假捏出男女二人名姓；又必旁添一小人拨乱其间，如戏中的小丑一般。更可厌者，‘之乎者也’，非理即文，大不近情，自相矛盾。竟不如我这半世亲见亲闻的几个女子，虽不敢说强似前代书中所有之人，但观其事迹原委，亦可消愁破闷；至于几首歪诗，也可以喷饭供酒。其间离合悲欢，兴衰际遇，俱是按迹循踪，不敢稍加穿凿，至失其真。
    <span class="tag">&lt;/<span class="title">p</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">main</span>&gt;</span>
<span class="tag">&lt;<span class="title">footer</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>© 2016 No rights reserved.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Made with ♥ by supce.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
</code></pre><p>CSS:</p>
<pre><code><span class="tag">main</span> <span class="rules">{
    <span class="rule"><span class="attribute">min-height</span>:<span class="value"> <span class="function">calc</span>(<span class="number">100vh</span> - <span class="number">5em</span> - <span class="number">7em</span>)
}
body {
    margin: <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">100%</span>/<span class="number">1.5</span> Palatino Linotype, Palatino, serif</span></span>;
}</span>
<span class="tag">h1</span> <span class="rules">{ <span class="rule"><span class="attribute">margin</span>:<span class="value"> .<span class="number">5em</span> <span class="number">0</span> <span class="number">0</span></span></span>; }</span>
<span class="tag">header</span> <span class="rules">{ <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">3em</span></span></span>; }</span>
<span class="tag">main</span>, <span class="tag">footer</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> .<span class="number">5em</span> <span class="function">calc</span>(<span class="number">50%</span> - <span class="number">400px</span>)</span></span>;
}</span>
<span class="tag">footer</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#222</span>, <span class="hexcolor">#444</span>)</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">6em</span></span></span>;
}</span>
</code></pre><p>效果如下：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-17-3.jpg" alt=""></p>
<h2 id="基于flex弹性布局的解决方案">基于flex弹性布局的解决方案</h2><p>之前有一篇关于弹性布局的<a href="http://blog.supce.com/2016/09/12/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/">日志</a>。<br>要想让页脚紧贴底部：</p>
<ul>
<li>首先对<code>&lt;body&gt;</code>设置<code>display:flex;flex-flow:column;</code>，保证<code>body</code>内的子元素为垂直排列。</li>
<li>其次，设置<code>&lt;body&gt;</code>的<code>min-height</code>属性为100vh，这样它就至少会占据整个视口的高度。</li>
<li>最后，我们希望页头和页脚有其内部因素来决定，而内容区块的高度应该可以自动伸展并占满所有的可用空间。这就需要给<code>&lt;main&gt;</code>这个容器的flex属性指定一个大于0的值，我们可以暂时设置为1即可。</li>
</ul>
<p>这种方案的核心代码如下:</p>
<pre><code><span class="tag">body</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column</span></span>;
    <span class="rule"><span class="attribute">min-height</span>:<span class="value"> <span class="number">100vh</span></span></span>;
}</span>
<span class="tag">main</span><span class="rules">{
    <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span></span></span>;
}</span>
</code></pre><blockquote>
<p>国庆节偷个小懒，不举例子了</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="根据兄弟元素的数量设置样式">根据兄弟元素的数量设置样式</h1><p>有时候会碰见这样一种场景：当一个列表不断延长时，通过隐藏空间或压缩控件等方式来节省屏幕空间，用来提升用户体验。<br>这时候就需要我们根据兄弟元素的总数来为它们设置相应的样式。<br>设想一个列表，假设仅当列表的总数为4时才对这些列表项设置样式，这时可以使用<code>li:nth-child(4)</code>来选中列表的第四个列表项。但是我们的需求却是：<br><em>在列表的总数为4时选中每个列表项</em><br>如果直接利用兄弟选择符<code>li:nth-child(4),li:hth-child(4)~li</code>得到的是第四个列表以及它之后的所有列表项。那么我们转换一下思路分以下几种情况：<br>当只有一个列表项时，直接利用<code>:only-child</code>即：</p>
<pre><code><span class="tag">li</span><span class="pseudo">:only-child</span>{
    <span class="comment">/*只有一个列表时的样式*/</span>
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之结构与布局(一)]]></title>
    <link href="http://blog.supce.com/2016/09/28/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B8%83%E5%B1%80(%E4%B8%80)/"/>
    <id>http://blog.supce.com/2016/09/28/CSS Secret 读书笔记之结构与布局(一)/</id>
    <published>2016-09-27T16:00:00.000Z</published>
    <updated>2016-09-28T03:13:23.512Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="自适应内部元素">自适应内部元素</h1><p>如果不给一个元素指定一个具体的高度(<code>height</code>),这个元素就会根据内容适应高度。但是对于<code>width</code>怎么样才能有类似的行为呢？<br>首先给出一段HTML测试代码：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>猫，属于猫科动物，分家猫、野猫，是全世界家庭中较为广泛的宠物。家猫的祖先据推测是起源于古埃及的沙漠猫，波斯的波斯猫，已经被人类驯化了3500年（但未像狗一样完全地被驯化）。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">figure</span>&gt;</span>
    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"cat.jpg"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">figcaption</span>&gt;</span>猫咪的训练要从幼时抓起，先要摸清猫咪的脾气，然后根据需要选择不同的方式来进行训练。以下几种方式可供选用：强迫、诱导、奖励、惩罚、喊叫。<span class="tag">&lt;/<span class="title">figcaption</span>&gt;</span>
<span class="tag">&lt;/<span class="title">figure</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>猫，分多种，是鼠的天敌。各地都有畜养。有黄、黑、白、灰等各种颜色；身形像狸，外貌像老虎，毛柔而齿利（有几乎无毛的品种）。以尾长腰短，目光如金银，上腭棱多的最好。身体小巧，样子招人喜爱。好奇心重。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><a id="more"></a>
<p>设置一些基本的样式：</p>
<pre><code><span class="tag">figure</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
<span class="tag">figure</span> &gt; <span class="tag">img</span><span class="rules">{ <span class="rule"><span class="attribute">max-width</span>:<span class="value"> inherit</span></span>; }</span>
</code></pre><p>初始的效果是这样的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-1.jpg" alt=""><br>这个时候希望figure元素能够跟它所包含的图片宽度一样，而且是水平居中的。即：如何让figure的宽度让内部的图片决定。<br>首先想到的是浮动，给figure增加<code>float: left;</code><br>这时候宽度虽然符合要求，但是改变了原有的布局。<br>如果对figure元素设置<code>display: inline-block;</code>，让它根据内容来决定自身的尺寸。但是元素的宽度并不是根据图片的宽度来决定的。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-2.jpg" alt=""><br>最后只能设置figure元素为定宽，然后对其内部的img设置<code>max-width: 100%;</code>，但是这就意味着放弃了响应式布局。<br>当然之前也用过JS来动态的设置figure宽度，但是我们可以利用CSS3的一个新关键字，轻松解决这个问题。<br>CSS3中为<code>height</code>和<code>width</code>属性定义了一<code>min-content</code>的关键字。这个关键字将元素的宽度设置为元素内部最大的不可断行元素的宽度(即最宽的单词，图片，或具有固定宽度的盒元素)。<br>为了平稳回退，可以再给元素设置一个固定的<code>max-width</code>值。最终代码如下：</p>
<pre><code><span class="tag">figure</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
<span class="tag">figure</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">300px</span></span></span>;
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> min-content</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
<span class="tag">figure</span> &gt; <span class="tag">img</span><span class="rules">{ <span class="rule"><span class="attribute">max-width</span>:<span class="value"> inherit</span></span>; }</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-3.jpg" alt=""></p>
<p>问题轻松解决~</p>
<hr>
<h1 id="精准控制表格列宽">精准控制表格列宽</h1><p>对于table有一个属性，叫作<code>table-layout</code>，它的默认值为<code>auto</code>，其行为模式被称作自定表格布局算法。也就是平时所看到的表格布局行为。<br>其具体的行为可以用下面这断代码来演示：<br>为了便于演示，先把CSS样式放前面，然后再把HTML分段。</p>
<pre><code><span class="tag">section</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed red</span></span>;
}</span>
<span class="tag">table</span><span class="rules">{
    <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">border-collapse</span>:<span class="value"> collapse</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
}</span>
<span class="tag">table</span>,<span class="tag">tr</span>,<span class="tag">td</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
}</span>
<span class="tag">td</span><span class="class">.preformatted</span><span class="rules">{
    <span class="rule"><span class="attribute">white-space</span>:<span class="value"> pre</span></span>;
    <span class="rule"><span class="attribute">text-overflow</span>:<span class="value"> ellipsis</span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
}</span>
</code></pre><p>HTML：</p>
<pre><code><span class="tag">&lt;<span class="title">section</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">table</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>如果我们不<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>指定单元格的宽度，则这些单元格就会根据它们内容的长短来分配宽度，也就是说，内容较长的单元格所能分配到的宽度也较多<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
        <span class="tag">&lt;<span class="title">table</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>如果我们不<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>指定单元格的宽度，则这些单元格就会根据它们内容的长短来分配宽度，也就是说，内容较长的单元格所能分配到的宽度也较多<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>表格的每一行都会参与到列宽的计算中，而不仅是第一行<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>注意，这个表格的列宽分配结果跟上面那个表格不同<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
        <span class="tag">&lt;<span class="title">table</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span> <span class="attribute">style</span>=<span class="value">"width:1000px"</span>&gt;</span>即使我们为单元格指定了宽度，也未必会得到对应的结果。比如这个单元格宽度为1000px<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span> <span class="attribute">style</span>=<span class="value">"width:2000px"</span>&gt;</span>这个单元格宽度被指定为2000px。由于外层容器不足以提供3000px，则两个单元格等比例缩小为33.3%和66.6%<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-4.jpg" alt=""></p>
<pre><code>        <span class="tag">&lt;<span class="title">table</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>如果我们禁止文本折行，那么表格宽度也可能远远超出其容器的宽度<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span> <span class="attribute">class</span>=<span class="value">"preformatted"</span>&gt;</span>而且 text-flow:ellipsis 对此也无能为力而且 text-flow:ellipsis 对此也无能为力而且 text-flow:ellipsis 对此也无能为力<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
        <span class="tag">&lt;<span class="title">table</span>&gt;</span>
            <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span>大图片或者代码块也可能会导致同样的问题<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
                <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://lea.verou.me/book/panoramic.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">section</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-5.jpg" alt=""></p>
<p>如果我们把<code>table-layout</code>的值设置为<code>fixed</code>，这时候就是利用固定表格布局算法了。在这个算法下，表格的内容不会影响单元格的宽度，它把更多的控制权交给开发者，我们设置的宽度也会起作用，同时，类似于溢出等元素行为也会接受控制，因此的表格的内容将只能影响表格的行高。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-6.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-7.jpg" alt=""><br>通过对比可以发现，设置fixed后，图片所在的单元行并没有根据图片的宽度来扩大自己的宽度。<br>如果给该单元格设置<code>overflow: hidden;</code>也是有效的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-8.jpg" alt=""></p>
<hr>
<h1 id="满幅的背景，定宽的内容">满幅的背景，定宽的内容</h1><p>有一种网页设计方案，特别是在电子产品的介绍页面比较流行。比如下图某手机的发布页面：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-16-9.jpg" alt=""><br>这种设计可以称作为“背景宽度满幅，内容宽度固定”。其典型的特征如下：</p>
<ul>
<li>页面中包含多个大区块，每个区块都占据了整个视口的宽度，区块的背景也各不相同。</li>
<li>内容是定宽的，即使在不同分辨率下的宽度不一样，那也只是因为媒体查询改变了这个固定宽度的宽度值。在某些情况下，不同区块的内容也可能具有不同的宽度。</li>
</ul>
<p>要实现这种设计风格，最常见的方法就是为每个区块准备两层元素：外层用来实现满幅的背景，内层用来实现定宽的内容，然后再通过<code>margin: auto;</code>实现内容的水平居中。<br>比如下面这个例子：<br>HTML:</p>
<pre><code><span class="tag">&lt;<span class="title">footer</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"wrapper"</span>&gt;</span>
        <span class="comment">&lt;!--内容部分--&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">footer</span>&gt;</span>
</code></pre><p>CSS：</p>
<pre><code><span class="tag">footer</span><span class="rules">{
    <span class="rule"><span class="attribute">blackground</span>:<span class="value"> <span class="function">url</span>()</span></span>;
}</span>
<span class="class">.wrapper</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"><span class="number">900px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1em</span> auto</span></span>;
}</span>
</code></pre><p>如果对<code>marign: auto;</code>有足够的了解，就会发现没必要再添加一层额外的元素。<br><code>margin: auto</code>所产生的左右外边距实际上都等于视口宽度的一半减去内容宽度的一半，根据上面的例子，左右外边距就是：50% - 450px。这时候就可以利用我们之前用到过的<code>calc</code>了。<br>可以把上面的代码修改下：</p>
<pre><code><span class="tag">footer</span><span class="rules">{
    <span class="rule"><span class="attribute">blackground</span>:<span class="value"> <span class="function">url</span>()</span></span>;
}</span>
<span class="class">.wrapper</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"><span class="number">900px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1em</span> <span class="function">calc</span>(<span class="number">50%</span> - <span class="number">450px</span>)</span></span>;
}</span>
</code></pre><p>我们最初的需求是能够去掉包裹内容的div元素。这时候可以稍微改变下思路，去掉div，给父元素设置<code>padding</code>值：</p>
<pre><code><span class="tag">footer</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>; <span class="comment">/*平稳回退*/</span>
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span> <span class="function">calc</span>(<span class="number">50%</span> - <span class="number">450px</span>)</span></span>;
    <span class="rule"><span class="attribute">blackground</span>:<span class="value"> <span class="function">url</span>()</span></span>;
}</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="自适应内部元素">自适应内部元素</h1><p>如果不给一个元素指定一个具体的高度(<code>height</code>),这个元素就会根据内容适应高度。但是对于<code>width</code>怎么样才能有类似的行为呢？<br>首先给出一段HTML测试代码：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>猫，属于猫科动物，分家猫、野猫，是全世界家庭中较为广泛的宠物。家猫的祖先据推测是起源于古埃及的沙漠猫，波斯的波斯猫，已经被人类驯化了3500年（但未像狗一样完全地被驯化）。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">figure</span>&gt;</span>
    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"cat.jpg"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">figcaption</span>&gt;</span>猫咪的训练要从幼时抓起，先要摸清猫咪的脾气，然后根据需要选择不同的方式来进行训练。以下几种方式可供选用：强迫、诱导、奖励、惩罚、喊叫。<span class="tag">&lt;/<span class="title">figcaption</span>&gt;</span>
<span class="tag">&lt;/<span class="title">figure</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>猫，分多种，是鼠的天敌。各地都有畜养。有黄、黑、白、灰等各种颜色；身形像狸，外貌像老虎，毛柔而齿利（有几乎无毛的品种）。以尾长腰短，目光如金银，上腭棱多的最好。身体小巧，样子招人喜爱。好奇心重。<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之交互式的图片对比控件]]></title>
    <link href="http://blog.supce.com/2016/09/26/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87%E5%AF%B9%E6%AF%94%E6%8E%A7%E4%BB%B6/"/>
    <id>http://blog.supce.com/2016/09/26/CSS Secret 读书笔记之交互式的图片对比控件/</id>
    <published>2016-09-25T16:00:00.000Z</published>
    <updated>2016-09-26T12:50:45.385Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="交互式的图片对比控件">交互式的图片对比控件</h1><p>利用CSS可以模拟一种图片对比滑动控件，这个控件会把两张图片叠加起来，允许用户拖动分割条来控制这两张图片的显露区域。这种控件可以理解为两层结构：<br>下层是一张固定的图片，上层的图片则可以在水平方向上调整大小，从而能够显示下层的图片。<br>一般这种需求是可以利用JavaScript解决的。但是也可以利用下面这两种CSS方式。</p>
<h2 id="resize方案"><code>resize</code>方案</h2><p>可以利用CSS3中的<code>resize</code>属性。这个属性就算没听说过，但是也肯定接触过它的行为，因为对于<code>&lt;textarea&gt;</code>元素来说，整个属性被默认设置为<code>both</code>，这就使得<code>&lt;textarea&gt;</code>元素在水平和垂直方向上是可以调整大小的。<br>对于任何一个<code>overflow</code>属性不是<code>visible</code>的元素来说，<code>resize</code>属性都是适用的。大部分元素<code>resize</code>属性的默认值是none，即禁止调整大小。该属性也接受<code>horizontal</code>和<code>vertical</code>来限制元素调整大小的方向。<br><a id="more"></a><br>搞清楚<code>resize</code>属性，问题就很好解决了。<br>首先想到的是两个img元素，但是直接对一个img元素应用<code>resize</code>会导致图片变形失真。这时候可以在它外面包裹一个div，然后对div设置<code>resize</code>进行大小调整。</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"image-slider"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span>
        <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"bad.jpg"</span> /&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"good.jpg"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>然后给元素设置一些基本的样式，并设置好对应div元素的<code>resize</code>属性值：</p>
<pre><code><span class="class">.image-slider</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
}</span>
<span class="class">.image-slider</span>&gt;<span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">bottom</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40%</span></span></span>;  <span class="comment">/*初始宽度*/</span>
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
    <span class="rule"><span class="attribute">resize</span>:<span class="value"> horizontal</span></span>;
}</span>
<span class="class">.image-slider</span> <span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;  <span class="comment">/*img是一种类似text的元素，在结束的时候，
                        会在末尾加上一个空白符，所以就会多出3px 设置为block可解决*/</span>
}</span>
</code></pre><p>这时候的效果是这样的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-15-1.gif" alt=""><br>虽然在上层图片的右下角有一个调节的手柄，但是并不容易辨认。这时候可以利用一个伪元素，将其覆盖在初始的调节手柄之上。最后对伪元素进行美化：</p>
<pre><code><span class="tag">image-slider</span>&gt;<span class="rule"><span class="attribute">div</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">bottom</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">12px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">12px</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(-<span class="number">45deg</span>,white <span class="number">50%</span>,transparent <span class="number">0</span>)</span></span>;
    <span class="rule"><span class="attribute">-webkit-filter</span>:<span class="value"> <span class="function">drop-shadow</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> black)</span></span>;
    <span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">drop-shadow</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> black)</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> content-box</span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> ew-resize</span></span>;
}
</code></pre><p><em><code>cursor: ew-resize</code>提供额外的自释性，可以提示用户这个区域可以进行水平方向的拖动</em></p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-15-2.gif" alt=""></p>
<h2 id="范围输入控件方案">范围输入控件方案</h2><p>利用<code>resize</code>属性很简单就实现了我们的需求，但是这个方案有下面几个不足：</p>
<ul>
<li>利用<code>resize</code>方案对于键盘来说是不可访问的</li>
<li>只能通过拖动来调整上层图片。用户不能点击到某个点来调整宽度。</li>
<li>用户只能在上层图片的右上角进行大小的调整，有可能被用户忽略。</li>
</ul>
<p>为了解决上面三个问题，可以利用一点JS，将一个原生的滑动控件覆盖在图片上，用这个控件来控制上层图片的伸缩。<br>下面可以优化下HTML代码结构，通过JS来添加相应的元素和控件。</p>
<pre><code>&lt;<span class="tag">div</span> class=<span class="string">"image-slider-2"</span>&gt;
    &lt;<span class="tag">img</span> src=<span class="string">"bad.jpg"</span> /&gt;
    &lt;<span class="tag">img</span> src=<span class="string">"good.jpg"</span> /&gt;
&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.image-slider-2</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
}</span>
<span class="class">.image-slider-2</span> &gt; <span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">0</span></span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
}</span>
<span class="class">.image-slider-2</span> <span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
}</span>
<span class="class">.image-slider-2</span> <span class="tag">input</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">0</span></span></span>; <span class="rule"><span class="attribute">bottom</span>:<span class="value"><span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="comment">/*filter: contrast(.5);
    mix-blend-mode: luminosity;*/</span>
}</span>
</code></pre><p>JS:</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> slider = <span class="built_in">document</span>.querySelector(<span class="string">'.image-slider-2'</span>);
    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);
    slider.appendChild(div);
    <span class="keyword">var</span> img = slider.querySelector(<span class="string">'img'</span>);
    slider.insertBefore(img,div);
    div.appendChild(img);
    <span class="comment">//创建滑动控件</span>
    <span class="keyword">var</span> range = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);
    range.type = <span class="string">'range'</span>;
    range.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        div.style.width = <span class="keyword">this</span>.value + <span class="string">'%'</span>;
    }
    slider.appendChild(range);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>最终效果如下：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-15-3.gif" alt=""></p>
<blockquote>
<p>最后真的希望雾霾问题能够解决，能够给后代留一个蓝天。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="交互式的图片对比控件">交互式的图片对比控件</h1><p>利用CSS可以模拟一种图片对比滑动控件，这个控件会把两张图片叠加起来，允许用户拖动分割条来控制这两张图片的显露区域。这种控件可以理解为两层结构：<br>下层是一张固定的图片，上层的图片则可以在水平方向上调整大小，从而能够显示下层的图片。<br>一般这种需求是可以利用JavaScript解决的。但是也可以利用下面这两种CSS方式。</p>
<h2 id="resize方案"><code>resize</code>方案</h2><p>可以利用CSS3中的<code>resize</code>属性。这个属性就算没听说过，但是也肯定接触过它的行为，因为对于<code>&lt;textarea&gt;</code>元素来说，整个属性被默认设置为<code>both</code>，这就使得<code>&lt;textarea&gt;</code>元素在水平和垂直方向上是可以调整大小的。<br>对于任何一个<code>overflow</code>属性不是<code>visible</code>的元素来说，<code>resize</code>属性都是适用的。大部分元素<code>resize</code>属性的默认值是none，即禁止调整大小。该属性也接受<code>horizontal</code>和<code>vertical</code>来限制元素调整大小的方向。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之模糊弱化背景&滚动提示]]></title>
    <link href="http://blog.supce.com/2016/09/25/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E7%B3%8A%E5%BC%B1%E5%8C%96%E8%83%8C%E6%99%AF&%E6%BB%9A%E5%8A%A8%E6%8F%90%E7%A4%BA/"/>
    <id>http://blog.supce.com/2016/09/25/CSS Secret 读书笔记之模糊弱化背景&滚动提示/</id>
    <published>2016-09-24T16:00:00.000Z</published>
    <updated>2016-09-25T12:14:50.929Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="通过模糊弱化背景">通过模糊弱化背景</h1><p>昨天实现了阴影弱化背景，这里换个方式实现模糊弱化背景。<br>下面这种方式主要利用了<code>box-shadow</code>的扩展参数，把元素的投影向各个方向延伸放大。并且利用了viewport单位<code>vmax</code>。</p>
<p><em>1vmax相当于1vw和1vh两者中的较大值。100vw等于整个viewport的宽度，100vh等于整个viewport的高度</em></p>
<p>HTML:</p>
<pre><code>&lt;main&gt;
    &lt;button&gt;show dialog&lt;/button&gt;
    &lt;p&gt;
         <span class="number">2016</span> presidential campaign truly <span class="keyword">is</span> a product <span class="keyword">of</span> <span class="keyword">its</span> <span class="property">time</span>. When one presidential candidate loves <span class="keyword">to</span> communicate <span class="keyword">with</span> his voters <span class="keyword">through</span> <span class="number">140</span>-<span class="property">character</span> bursts <span class="function_start"><span class="keyword">on</span></span> Twitter, <span class="keyword">and</span> a hasty tweet can cause an international scandal, <span class="keyword">the</span> other side has <span class="keyword">to</span> be quick <span class="keyword">to</span> respond <span class="keyword">in</span> similar fashion. Hence a new internet gem courtesy <span class="keyword">of</span> Hillary Clinton’s campaign website: “Donald Trump, Pepe <span class="keyword">the</span> frog, <span class="keyword">and</span> white supremacists: an explainer.”
    &lt;/p&gt;
&lt;/main&gt;
&lt;dialog&gt;this <span class="keyword">is</span> a test this <span class="keyword">is</span> a test click <span class="keyword">me</span> click <span class="keyword">me</span>&lt;/dialog&gt;
</code></pre><a id="more"></a>
<p>CSS:</p>
<pre><code><span class="tag">main</span><span class="rules">{
    <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">150%</span>/<span class="number">1.6</span> sans-serif</span></span>;
    <span class="rule"><span class="attribute">transition</span>:<span class="value"> .<span class="number">5s</span> filter</span></span>;
}</span>
<span class="tag">main</span><span class="class">.emphasized</span><span class="rules">{
    <span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">blur</span>(<span class="number">5px</span>)</span></span>;
    <span class="rule"><span class="attribute">-webkit-filter</span>:<span class="value"> <span class="function">blur</span>(<span class="number">5px</span>)</span></span>;

    <span class="comment">/*filter: blur(5px) contrast(.8) brightness(.8);
    -webkit-filter: blur(5px) contrast(.8) brightness(.8);*/</span>
}</span>
<span class="tag">dialog</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"><span class="number">25%</span></span></span>;
    <span class="rule"><span class="attribute">left</span>:<span class="value"><span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">7.5em</span></span></span>;
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">1</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">15em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">4em</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0</span> .<span class="number">2em</span> .<span class="number">5em</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>),
                <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100vmax</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>)</span></span>;
}</span>
<span class="rule"><span class="attribute">dialog</span>:<span class="value"><span class="function">not</span>([open]){
    display: none</span></span>;
}
</code></pre><p>JS:</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">return</span> context.querySelector(selector);
    }
    <span class="keyword">var</span> main = $(<span class="string">'main'</span>);
    <span class="keyword">var</span> dialog = $(<span class="string">'dialog'</span>);
    $(<span class="string">'button'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        dialog.setAttribute(<span class="string">'open'</span>,<span class="string">'true'</span>);
        main.classList.add(<span class="string">'emphasized'</span>);
    }
    dialog.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">if</span>(dialog.close){
            dialog.close();
        }<span class="keyword">else</span>{
            dialog.removeAttribute(<span class="string">'open'</span>);
        }
        main.classList.remove(<span class="string">'emphasized'</span>);
    }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-1.gif" alt=""></p>
<hr>
<h1 id="滚动提示">滚动提示</h1><p>这里模拟一种滚动提示，这种滚动提示类似于Android 4.0+设置列表中的滚动提示。当列表滚动到最底部(最顶部)时会有阴影效果。</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-2.jpg" alt=""></p>
<p>首先，创建一个无序列表，设置好最基本的样式。然后就轮到径像渐变大展身手了。在列表的顶部添加一个渐变阴影。<br>HTML:</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>高坂穗乃果<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>园田海末<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>南琴梨<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>小泉花阳<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>西木野真姬<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>星空凛<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>绚濑绘里<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>东条希<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>矢泽妮可<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>CSS:</p>
<pre><code><span class="tag">ul</span><span class="rules">{
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">10em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">4em</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> .<span class="number">3em</span> .<span class="number">5em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid silver</span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;

    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">radial-gradient</span>(at top,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>),transparent <span class="number">60%</span>) no-repeat</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">25px</span></span></span>;
}</span>
</code></pre><p>这时候的效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-3.gif" alt=""><br>当列表滚动时，上面的阴影会一直停留在相同的位置。如果设置<code>background-attachment</code>为local时会出现一个相反的效果：当我们滚动到最顶端时，能看到阴影。向下滚动时阴影就消失了。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-4.gif" alt=""><br>这时候可以换一种思路，再添加一层与背景色相同的矩形遮盖层，用于遮盖阴影。将阴影背景的<code>background-attachment</code>设置为默认值，将矩形遮盖层设置为local。这样，它就会在我们滚动到最顶部时遮盖住阴影，向下滚动时露出阴影。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(white,<span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,<span class="number">0</span>)),
            <span class="function">radial-gradient</span>(at top,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>),transparent <span class="number">60%</span>)</span></span>;
<span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">25px</span></span></span>;
<span class="rule"><span class="attribute">background-attachment</span>:<span class="value"> local,scroll</span></span>;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-5.gif" alt=""></p>
<p>最后再用相同的思路给底部添加上双层阴影，最终代码如下：</p>
<pre><code>background: linear-gradient(white,hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">0</span>)) <span class="number">0</span> <span class="number">0</span>,
            radial-gradient(at top,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.3</span>),transparent <span class="number">60</span>%) <span class="number">0</span> <span class="number">0</span>,
            linear-gradient(hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">0</span>),white) bottom,
            radial-gradient(at bottom,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.3</span>),transparent <span class="number">60</span>%) bottom;
background-size: <span class="number">100</span>% <span class="number">50</span>px, <span class="number">100</span>% <span class="number">25</span>px,<span class="number">100</span>% <span class="number">50</span>px, <span class="number">100</span>% <span class="number">25</span>px;
background-repeat: no-repeat;
background-attachment: local,scroll,local,scroll;
</code></pre><p>效果图：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-14-6.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="通过模糊弱化背景">通过模糊弱化背景</h1><p>昨天实现了阴影弱化背景，这里换个方式实现模糊弱化背景。<br>下面这种方式主要利用了<code>box-shadow</code>的扩展参数，把元素的投影向各个方向延伸放大。并且利用了viewport单位<code>vmax</code>。</p>
<p><em>1vmax相当于1vw和1vh两者中的较大值。100vw等于整个viewport的宽度，100vh等于整个viewport的高度</em></p>
<p>HTML:</p>
<pre><code>&lt;main&gt;
    &lt;button&gt;show dialog&lt;/button&gt;
    &lt;p&gt;
         <span class="number">2016</span> presidential campaign truly <span class="keyword">is</span> a product <span class="keyword">of</span> <span class="keyword">its</span> <span class="property">time</span>. When one presidential candidate loves <span class="keyword">to</span> communicate <span class="keyword">with</span> his voters <span class="keyword">through</span> <span class="number">140</span>-<span class="property">character</span> bursts <span class="function_start"><span class="keyword">on</span></span> Twitter, <span class="keyword">and</span> a hasty tweet can cause an international scandal, <span class="keyword">the</span> other side has <span class="keyword">to</span> be quick <span class="keyword">to</span> respond <span class="keyword">in</span> similar fashion. Hence a new internet gem courtesy <span class="keyword">of</span> Hillary Clinton’s campaign website: “Donald Trump, Pepe <span class="keyword">the</span> frog, <span class="keyword">and</span> white supremacists: an explainer.”
    &lt;/p&gt;
&lt;/main&gt;
&lt;dialog&gt;this <span class="keyword">is</span> a test this <span class="keyword">is</span> a test click <span class="keyword">me</span> click <span class="keyword">me</span>&lt;/dialog&gt;
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之自定义复选框&阴影弱化背景]]></title>
    <link href="http://blog.supce.com/2016/09/24/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%8D%E9%80%89%E6%A1%86&%E9%98%B4%E5%BD%B1%E5%BC%B1%E5%8C%96%E8%83%8C%E6%99%AF/"/>
    <id>http://blog.supce.com/2016/09/24/CSS Secret 读书笔记之自定义复选框&阴影弱化背景/</id>
    <published>2016-09-23T16:00:00.000Z</published>
    <updated>2016-09-24T12:00:00.511Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="自定义复选框">自定义复选框</h1><p>单选框和复选框的默认样式确实不敢恭维，但是这两种控件在绝大多数浏览器中仍然无法自由的设置样式。这时候可以用下面这种“曲线救国”的思路来实现自定义复选框。</p>
<h2 id="伪元素解决方案">伪元素解决方案</h2><p>具体思路如下：<br>由于<code>label</code>元素可以和复选框关联，起到触发开关的作用。我们可以为它添加伪元素，并基于复选框的状态来为其设置样式。然后再把真正的复选框隐藏起来。</p>
<blockquote>
<p>CSS的魅力就在于此，正是<code>label</code>可以和复选框(单选框)关联，才有了自定义复选框的可能性。</p>
</blockquote>
<p>有了上面的思路，代码就很简单了。首先是最最最简单的HTML：</p>
<pre><code>&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"custom-a"</span> /&gt;
&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"custom-a"</span>&gt;自定义复选框&lt;/<span class="keyword">label</span>&gt;
</code></pre><a id="more"></a>
<p>然后给<code>label</code>的伪元素添加一些基本的样式：</p>
<pre><code><span class="tag">body</span><span class="rules">{<span class="rule"><span class="attribute">font</span>:<span class="value"><span class="number">150%</span>/<span class="number">1.5</span> sans-serif</span></span>;}</span>
<span class="tag">input</span><span class="attr_selector">[type="checkbox"]</span> + <span class="rule"><span class="attribute">label</span>:<span class="value">:before{
    content: <span class="string">'\a0'</span></span></span>; <span class="comment">/*不换行空格*/</span>
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> .<span class="number">8em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> .<span class="number">8em</span></span></span>;
    <span class="rule"><span class="attribute">vertical-align</span>:<span class="value"> .<span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#c00</span></span></span>;
    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> .<span class="number">2em</span></span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> .<span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> .<span class="number">65</span></span></span>;
    <span class="rule"><span class="attribute">text-indent</span>:<span class="value"> .<span class="number">15em</span></span></span>;
}
</code></pre><p>这时候效果是这个样子的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-1.jpg" alt=""><br>下面再给伪元素添加复选框被勾选时的样式：</p>
<pre><code><span class="tag">input</span><span class="attr_selector">[type="checkbox"]</span><span class="pseudo">:checked</span> + <span class="rule"><span class="attribute">label</span>:<span class="value">:before{
    content: <span class="string">'\2713'</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> yellowgreen</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-2.jpg" alt=""></p>
<p>现在就差一步了，就是把原来的复选框以一种不损失可访问性的方式隐层起来。这就意味着我们不能简单粗暴地设置<code>display:none</code>，因为这样会把它从键盘tab键切换焦点的队列中删除。那么怎么隐藏呢，这时候轮到裁剪登场了，可以使用裁剪，将它裁剪掉！</p>
<pre><code><span class="tag">input</span><span class="attr_selector">[type="checkbox"]</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">clip</span>:<span class="value"> <span class="function">rect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;
}</span>
</code></pre><p>然后当伪元素聚焦时再添加<code>box-shadow</code>的特效：</p>
<pre><code>input[type=<span class="string">"checkbox"</span>]:focus + label::before{
    box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">.1</span>em <span class="number">2</span>px <span class="preprocessor">#<span class="number">58</span>a;</span>
}
</code></pre><p>OK，完美解决:<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-3.gif" alt=""><br>当然也可以补充上禁用时的样式：</p>
<pre><code><span class="tag">input</span><span class="attr_selector">[type="checkbox"]</span><span class="pseudo">:disabled</span> + <span class="rule"><span class="attribute">label</span>:<span class="value">:before{
    background: <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">'\2713'</span></span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> not-allowed</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-4.gif" alt=""></p>
<blockquote>
<p>在上面的例子中，尽量避免把复选框设置为圆形，因为大多数用户会把圆形的选择框理解为单选框。对于单选框则反之。</p>
</blockquote>
<h2 id="开关式按钮">开关式按钮</h2><p>利用<code>label</code>的可关联性，也可以用来模拟开关式按钮。开关式按钮与复选框的行为十分相似，可以用来切换某个选项的开关状态：启用时，它是被按下的状态，停用时，它就是浮起的状态。<br>代码很简单，主要是利用了内嵌阴影的效果。<br>HTML:</p>
<pre><code>&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"switch"</span>&gt;
&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"switch"</span> id=<span class="string">"switch-label"</span>&gt;开关式按钮&lt;/<span class="keyword">label</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="id">#switch</span><span class="attr_selector">[type="checkbox"]</span> + <span class="id">#switch-label</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> .<span class="number">3em</span> .<span class="number">5em</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>;
    <span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#ddd</span>,<span class="hexcolor">#bbb</span>)</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>)</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> .<span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">1px</span> white inset</span></span>;
    <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> white</span></span>;
}</span>
<span class="id">#switch</span><span class="attr_selector">[type="checkbox"]</span><span class="pseudo">:checked</span> + <span class="id">#switch-label</span>,
<span class="id">#switch</span><span class="attr_selector">[type="checkbox"]</span><span class="pseudo">:active</span> + <span class="id">#switch-label</span><span class="rules">{
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> .<span class="number">1em</span> .<span class="number">1em</span> .<span class="number">2em</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">6</span>) inset</span></span>;
    <span class="rule"><span class="attribute">border-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>)</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#bbb</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-5.gif" alt=""></p>
<hr>
<h1 id="通过阴影来弱化背景">通过阴影来弱化背景</h1><p>评论Twitter时，会通过阴影来弱化背景：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-6.jpg" alt=""><br>主要思路是通过点击事件，给背景设置半透明的背景色，然后将要显示的元素显示出来。这里就要用到js来辅助了。<br>HTML：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"overlay"</span>&gt;
    &lt;p&gt;this <span class="keyword">is</span> a test this <span class="keyword">is</span> test click <span class="keyword">me</span> click <span class="keyword">me</span>&lt;/p&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"lightbox"</span>&gt;this <span class="keyword">is</span> a light box&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS：</p>
<pre><code><span class="class">.overlay</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">10em</span></span></span>;
    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;
    <span class="comment">/*background-color: rgba(0,0,0,.7);*/</span>
}</span>
<span class="class">.lightbox</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">5em</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">1</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;
}</span>
</code></pre><p>js：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">return</span> context.querySelector(selector);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">checkDisStyle</span>(<span class="params">obj</span>)</span>{
        <span class="keyword">if</span>(obj.currentStyle){
            <span class="keyword">return</span> obj.currentStyle.display;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> <span class="built_in">window</span>.getComputedStyle(obj).display;
        }
    }
    $(<span class="string">'.overlay'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">if</span> (checkDisStyle($(<span class="string">'.lightbox'</span>)) == <span class="string">'none'</span>) {
            $(<span class="string">'.overlay'</span>).style.backgroundColor = <span class="string">"rgba(0,0,0,.7)"</span>;
            $(<span class="string">'.lightbox'</span>).style.display = <span class="string">"block"</span>;
        }<span class="keyword">else</span>{
            $(<span class="string">'.overlay'</span>).style.backgroundColor = <span class="string">""</span>;
            $(<span class="string">'.lightbox'</span>).style.display = <span class="string">"none"</span>;
        }
        <span class="comment">// console.log(checkDisStyle($('.lightbox')));</span>
    }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> 
</code></pre><p>搞完手工~</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-13-7.gif" alt=""></p>
<blockquote>
<p>在获取当前样式时，记得兼容IE，使用getComputedStyle方法</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="自定义复选框">自定义复选框</h1><p>单选框和复选框的默认样式确实不敢恭维，但是这两种控件在绝大多数浏览器中仍然无法自由的设置样式。这时候可以用下面这种“曲线救国”的思路来实现自定义复选框。</p>
<h2 id="伪元素解决方案">伪元素解决方案</h2><p>具体思路如下：<br>由于<code>label</code>元素可以和复选框关联，起到触发开关的作用。我们可以为它添加伪元素，并基于复选框的状态来为其设置样式。然后再把真正的复选框隐藏起来。</p>
<blockquote>
<p>CSS的魅力就在于此，正是<code>label</code>可以和复选框(单选框)关联，才有了自定义复选框的可能性。</p>
</blockquote>
<p>有了上面的思路，代码就很简单了。首先是最最最简单的HTML：</p>
<pre><code>&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"checkbox"</span> id=<span class="string">"custom-a"</span> /&gt;
&lt;<span class="keyword">label</span> <span class="keyword">for</span>=<span class="string">"custom-a"</span>&gt;自定义复选框&lt;/<span class="keyword">label</span>&gt;
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之合适光标&扩大可点击区域]]></title>
    <link href="http://blog.supce.com/2016/09/23/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%90%88%E9%80%82%E5%85%89%E6%A0%87&%E6%89%A9%E5%A4%A7%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F/"/>
    <id>http://blog.supce.com/2016/09/23/CSS Secret 读书笔记之合适光标&扩大可点击区域/</id>
    <published>2016-09-22T16:00:00.000Z</published>
    <updated>2016-09-23T12:39:21.503Z</updated>
    <content type="html"><![CDATA[<p><em>今天莫名的累，借此机会水一篇好了</em></p>
<hr>
<h1 id="合适的鼠标光标">合适的鼠标光标</h1><p>为了给用户带来良好的体验，鼠标在网页中有着不可忽视的作用。不同的鼠标光标暗示着不同的信息。下图是CSS3中新的一批内建光标：</p>
<a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-12-1.jpg" alt=""><br>下面就简单实现几个：</p>
<pre><code><span class="comment">&lt;!--禁用状态--&gt;</span>
<span class="tag">&lt;<span class="title">button</span>&gt;</span>可用<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">disabled</span>&gt;</span>禁用<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="comment">&lt;!--隐藏光标 适用于公共触摸屏--&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"dis-cursor"</span>&gt;</span>隐藏光标<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
</code></pre><p>CSS：</p>
<pre><code><span class="pseudo">:disabled</span><span class="rules">{        <span class="comment">/*disable选择器*/</span>
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> not-allowed</span></span>;
}</span>
<span class="class">.dis-cursor</span><span class="rules">{
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> none</span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-12-2.gif" alt=""></p>
<hr>
<h1 id="扩大可点击区域">扩大可点击区域</h1><p>美国心理学家 Paul Fitts 层提出Fitts法则：人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。<br>即：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-12-3.jpg" alt=""><br>其中，T表示所需时间，D是从起点到目标中心的距离，W是目标区域的宽度，a和b是常数。<br>对于网页中那些较小的、难以瞄准的控件来说，如果不能把视觉尺寸放大时，可以把可点击区域放大以增加用户体验和提升交互性。</p>
<h2 id="利用透明边框">利用透明边框</h2><p>首先想到的就是透明边框，因为鼠标也会对边框出发鼠标事件。<br>但是要注意，利用<code>background-clip</code>把背景色限制在原本的区域。<br>如果想要给元素添加边框，可以利用内嵌投影来模拟边框。<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"extend-a"</span>&gt;+&lt;/<span class="keyword">div</span>&gt;       
</code></pre><p>CSS：</p>
<pre><code><span class="class">.extend-a</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">5px</span> auto</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">2em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">2em</span></span></span>;
    <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">250%</span>/<span class="number">2em</span> sans-serif</span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">10px</span> solid transparent</span></span>; <span class="comment">/*透明边框扩大可点击区域*/</span>
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>) inset</span></span>;  <span class="comment">/*内嵌投影模拟边框*/</span>
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-12-4.gif" alt=""></p>
<h2 id="利用伪元素">利用伪元素</h2><p>利用边框心里面总感觉怪怪的，有点别扭。这时候可以试试伪元素了，毕竟边框有时候会影响整体的布局，而伪元素不会。<br>可以在按钮的上层覆盖一层透明的伪元素，并且让伪元素在四个方向都比宿主元素大10px<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"extend-b"</span>&gt;+&lt;/<span class="keyword">div</span>&gt;        
</code></pre><p>CSS：</p>
<pre><code><span class="class">.extend-b</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">5px</span> auto</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">2em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">2em</span></span></span>;
    <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">250%</span>/<span class="number">2em</span> sans-serif</span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;
}</span>
<span class="rule"><span class="attribute">.extend-b</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value">-<span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">right</span>:<span class="value">-<span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">bottom</span>:<span class="value">-<span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value">-<span class="number">10px</span></span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-12-5.gif" alt=""></p>
<blockquote>
<p>就偷偷的划一次水</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>今天莫名的累，借此机会水一篇好了</em></p>
<hr>
<h1 id="合适的鼠标光标">合适的鼠标光标</h1><p>为了给用户带来良好的体验，鼠标在网页中有着不可忽视的作用。不同的鼠标光标暗示着不同的信息。下图是CSS3中新的一批内建光标：</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之折角效果&连字符断行]]></title>
    <link href="http://blog.supce.com/2016/09/22/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%8A%98%E8%A7%92%E6%95%88%E6%9E%9C&%E8%BF%9E%E5%AD%97%E7%AC%A6%E6%96%AD%E8%A1%8C/"/>
    <id>http://blog.supce.com/2016/09/22/CSS Secret 读书笔记之折角效果&连字符断行/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2016-09-22T13:08:49.524Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="折角效果">折角效果</h1><p>有时候会把一个元素的右上角进行折叠，使元素显得更加有立体感。<br>要实现这种效果通常可以在右上角增加两个三角形：一个三角形来体现折页的形状，另一个三角形遮住元素的一角，用来模拟翻折所产生的缺口。但是这两种方式有以下两个缺陷：</p>
<ul>
<li>当折角元素之下的背景不是纯色而是一幅图案、一层纹理、一张照片或者渐变等，上面这种方式就不能完美实现了。</li>
<li>当折角不是45°时也不能够完美实现。</li>
</ul>
<p>这时候可以用下面这种方式解决<br><a id="more"></a></p>
<h2 id="45°的折角">45°的折角</h2><p>估计已经猜到，这时候要轮到到“万能”的渐变(<code>linear-gradient</code>)登场了。<br>基本思路是这样的：</p>
<ul>
<li>首先利用渐变在右上角创建一个透明的三角</li>
<li>其次再利用渐变生成一个深色透明的三角产生折页效果</li>
</ul>
<p>代码是这个样子的：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"triangle-a"</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
<span class="keyword">div</span>{
    width: <span class="number">10</span>em;
    height: <span class="number">6</span>em;
    background: <span class="comment">#fb3;</span>
    font: <span class="number">100</span>%/<span class="number">6</span>em sans-serif;
    <span class="type">text</span>-align: center;
    color: white;
}
.triangle-a{
    background: <span class="comment">#58a  /*回退样式*/</span>
    background: linear-gradient(<span class="keyword">to</span> left bottom,transparent <span class="number">50</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.4</span>) <span class="number">0</span>) no-<span class="keyword">repeat</span> <span class="number">100</span>% <span class="number">0</span> / <span class="number">2</span>em <span class="number">2</span>em,
                linear-gradient(-<span class="number">135</span>deg,transparent <span class="number">1.5</span>em,<span class="comment">#fb3 0);</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-1.jpg" alt=""></p>
<blockquote>
<p>注意：透明的切角是沿着渐变轴进行度量的，而background-size中的长度是正常的宽度和高度。所以在45°角的情况下，深色透明正方形的边长应为渐变轴的长度根号2倍。</p>
</blockquote>
<h2 id="其他度数的折角">其他度数的折角</h2><p>如果需要产生一个30°的切角，这时候把渐变设置为-150deg，然后利用正余弦算出深色透明矩形的长和宽。</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-2.jpg" alt=""></p>
<pre><code>.triangle-b{
        background: linear-gradient(to left bottom,transparent <span class="number">50</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.4</span>) <span class="number">0</span>) no-repeat <span class="number">100</span>% <span class="number">0</span> /<span class="number">3</span>em <span class="number">1.73</span>em,
                    linear-gradient(-<span class="number">150</span>deg,transparent <span class="number">1.5</span>em,<span class="preprocessor">#fb3 <span class="number">0</span>);</span>
    }
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-3.jpg" alt=""></p>
<p>结果发现效果跟现实里是不一样的。</p>
<p>仔细观察会发现深色三角在形状和大小上与切下来的角是一样的。只是这个深色三角需要进行旋转才能模拟现实的效果。<br>为了方便对深色透明三角进行操作且不影响切口效果，这时候得利用伪元素来实现深色三角了！</p>
<pre><code><span class="class">.triangle-c</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(-<span class="number">150deg</span>,transparent <span class="number">1.5em</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>)</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> .<span class="number">5em</span></span></span>;
}</span>
<span class="rule"><span class="attribute">.triangle-c</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(to left bottom,transparent <span class="number">50%</span>,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>) <span class="number">0</span>,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>)) no-repeat <span class="number">100%</span> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">1.73em</span></span></span>;
}
</code></pre><p>这是只不过是把上面的效果用伪元素实现了一遍。<br>然后把伪元素的宽和高进行互换：<code>width: 1.73em;height: 3em;</code></p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-4.jpg" alt=""></p>
<p>再观察下，把元素以右下角为中心进行旋转-30度，就可以使得深色透明三角与切口平行：</p>
<pre><code><span class="rule"><span class="attribute">.triangle-c</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(to left bottom,transparent <span class="number">50%</span>,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>) <span class="number">0</span>,<span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>)) no-repeat <span class="number">100%</span> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1.73em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(-<span class="number">30deg</span>)</span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> bottom right</span></span>;
    <span class="rule"><span class="attribute">border-bottom-left-radius</span>:<span class="value"> inherit</span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> -.<span class="number">2em</span> .<span class="number">2em</span> .<span class="number">3em</span> -.<span class="number">1em</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>)</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-5.jpg" alt=""></p>
<p>最后再把深色透明三角向上垂直移动就行，垂直移动量应为x-y如下图：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-6.jpg" alt=""></p>
<p>即修改代码如下：</p>
<pre><code><span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateY</span>(-<span class="number">1.3em</span>) <span class="function">rotate</span>(-<span class="number">30deg</span>)</span></span>;
</code></pre><p>最终效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-7.jpg" alt=""></p>
<p>每换一个角度就需要重新计算，这时候可以用下预处理器：</p>
<pre><code>@mixin folded-corner(<span class="variable">$background</span>, <span class="variable">$size</span>, <span class="variable">$angle</span>: <span class="number">30</span>deg) {
    position: relative;
    background: <span class="variable">$background</span>; /* 回退 */
    background: linear-gradient(<span class="variable">$angle</span> - <span class="number">180</span>deg, transparent <span class="variable">$size</span>, <span class="variable">$background</span> <span class="number">0</span>);
                border-radius: .<span class="number">5</span>em;
                <span class="variable">$x</span>: <span class="variable">$size</span> / sin(<span class="variable">$angle</span>);
                <span class="variable">$y</span>: <span class="variable">$size</span> / cos(<span class="variable">$angle</span>);
    &amp;::before {
        content: <span class="string">''</span>;
        position: absolute;
        top: <span class="number">0</span>; right: <span class="number">0</span>;
        background: linear-gradient(to left bottom,transparent <span class="number">50</span>%, rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>) <span class="number">0</span>,
        rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>)) <span class="number">100</span>% <span class="number">0</span> no-repeat;
        width: <span class="variable">$y</span>; height: <span class="variable">$x</span>;
        transform: translateY(<span class="variable">$y</span> - <span class="variable">$x</span>)
        rotate(<span class="number">2</span>*<span class="variable">$angle</span> - <span class="number">90</span>deg);
        transform-origin: bottom right;
        border-bottom-left-radius: inherit;
        box-shadow: -.<span class="number">2</span>em .<span class="number">2</span>em .<span class="number">3</span>em -.<span class="number">1</span>em rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);
    }
}
</code></pre><p>此时只需一行代码即可：</p>
<pre><code>.triangle{ @include folded-corner(<span class="preprocessor">#<span class="number">58</span>a,<span class="number">2</span>em,<span class="number">40</span>deg); }</span>
</code></pre><hr>
<h1 id="连字符断行">连字符断行</h1><p>这部分在英文文本中可能会遇到，处于强迫症，也把它写一下吧<br>文本如果在元素中能够两端对齐是很美观的。但是利用<code>text-align:justify;</code>会自动调整单词的间距，出现类似于“孤岛”的单词<br>比如：</p>
<pre><code><span class="keyword">div</span>{
    width: <span class="number">15</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">20</span>px;
    font: <span class="number">125</span>%/<span class="number">1.5</span> sans-serif;
    background: <span class="comment">#fb3;</span>
}
.test-a{
    <span class="type">text</span>-align: justify;
}
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-a"</span>&gt;
This <span class="keyword">is</span> a test.Like many things <span class="keyword">in</span> computer science, <span class="property">word</span> wrapping sounds simple <span class="keyword">and</span> straightforward
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-8.jpg" alt=""></p>
<p>虽然上图中文本两端对齐了，但是更加不美观了。<br>如果在两端对齐中使用连词符断行，使单词能够在音节分界处断开并折行，效果就会好一些。<br>这时候可以利用<code>CSS3中</code>的新属性<code>hyphens</code>，它接收三个值：<code>none,manual,auto</code>。<br><code>manual</code>是它的初始值，表示我们可以在任何时候手工插入连词符(<code>&amp;shy</code>)以实现折行。<br><code>none</code>表示禁用这种行为。<br><code>auto</code>表示自动为我们添加连词符<br>比如上面的例子添加后：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-11-9.jpg" alt=""></p>
<blockquote>
<p>可惜这个属性在chrome 53.0.2785.116 m中不兼容</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="折角效果">折角效果</h1><p>有时候会把一个元素的右上角进行折叠，使元素显得更加有立体感。<br>要实现这种效果通常可以在右上角增加两个三角形：一个三角形来体现折页的形状，另一个三角形遮住元素的一角，用来模拟翻折所产生的缺口。但是这两种方式有以下两个缺陷：</p>
<ul>
<li>当折角元素之下的背景不是纯色而是一幅图案、一层纹理、一张照片或者渐变等，上面这种方式就不能完美实现了。</li>
<li>当折角不是45°时也不能够完美实现。</li>
</ul>
<p>这时候可以用下面这种方式解决<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之染色效果&毛玻璃效果]]></title>
    <link href="http://blog.supce.com/2016/09/21/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9F%93%E8%89%B2%E6%95%88%E6%9E%9C&%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.supce.com/2016/09/21/CSS Secret 读书笔记之染色效果&毛玻璃效果/</id>
    <published>2016-09-20T16:00:00.000Z</published>
    <updated>2016-09-21T13:27:23.467Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="染色效果">染色效果</h1><p>有时候会遇到这样一种场景:需要给图片增加染色效果，当发生hover或者交互时再把染色效果去除。<br>最容易想到的是以下两种方式：</p>
<ul>
<li>把图片做成两个版本，然后用CSS使得两个版本交替呈现。这种方式会导致更大的文件体积和额外的HTTP请求，同时也不便于维护(想改变染色主色调时需要重新制作图片)。</li>
<li>还有一种方式，可以在图片上方覆盖一层半透明的纯色或者把图片设置为半透明并覆盖在一层纯色背景之上。这种方式会降低图片的对比度。</li>
</ul>
<p>为了避免上面两种方式带来的问题，可以用下面这两种纯CSS的方式解决<br><a id="more"></a></p>
<h2 id="基于滤镜的方案">基于滤镜的方案</h2><p>要想给图片染色，这里用到了三个滤镜，分别式<code>sepia()</code>、<code>saturate()</code>和<code>hue-rotate()</code></p>
<ul>
<li>sepia会增加一种将饱和度的橙黄色染色特效，这种特效会将图片复古成黑白老照片。</li>
<li>saturate会改变像素的饱和度。</li>
<li>hue-rotate会把每个像素的色相以指定的度数进行偏移。</li>
</ul>
<p>当然，给图片染色还可以用<code>grayscale</code>、<code>contrast</code>等。</p>
<p>比如下面的例子给图片增加一种暖色染色效果，出发hover时恢复原图：<br>HTML:</p>
<pre><code>&lt;<span class="tag">div</span> class=<span class="string">"test-a"</span>&gt;
    &lt;<span class="tag">img</span> src=<span class="string">"test.jpg"</span>&gt;
&lt;/div&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="tag">body</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
}</span>
<span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">200px</span></span></span>;
}</span>
<span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;
}</span>
<span class="class">.test-a</span> &gt; <span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">-webkit-filter</span>:<span class="value"> <span class="function">sepia</span>(<span class="number">1</span>) <span class="function">saturate</span>(<span class="number">3</span>) <span class="function">hue-rotate</span>(<span class="number">300deg</span>)</span></span>;
    <span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">sepia</span>(<span class="number">1</span>) <span class="function">saturate</span>(<span class="number">3</span>) <span class="function">hue-rotate</span>(<span class="number">300deg</span>)</span></span>;
    <span class="comment">/*transition: 5s -webkit-filter;*/</span>
}</span>
<span class="class">.test-a</span>&gt;<span class="rule"><span class="attribute">img</span>:<span class="value">hover,.test-a&gt;img:focus{
    -webkit-filter: none</span></span>;
    <span class="rule"><span class="attribute">filter</span>:<span class="value"> none</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-1.gif" alt=""></p>
<h2 id="基于混合模式的方案">基于混合模式的方案</h2><p>滤镜方案虽然可以染色，但是有一定的限制，它比较适合染褪色之类的效果。如果想消除这种褪色的染色效果，可以使用<code>saturate</code>增加饱和度，但是又会得到一种不自然的、过渡风格化的效果。这时候可以利用混合模式。</p>
<p>混合模式是指，当两个元素叠加时，该模式控制了上层元素的颜色与下层颜色进行混合。用它来实现染色效果时，需要用到的混合模式是<code>luminosity</code>、这种<code>luminosity</code>的混合模式会保留上层元素的HSL亮度信息，并从它的下层吸取色相和饱和度信息。这时候只需要将下层设置为想要的主色调，并把图片放在上层即可。</p>
<p>可以用两种方式实现混合模式：<br>第一种是把图片包裹在一个容器里，并把容器的背景色设置为需要的背景色。<br>第二种是不用img标签，而是使用div，把div第一层背景设置为要染色的图片，第二层设置为想要的主色调。<br>HTML:</p>
<pre><code>&lt;<span class="tag">div</span> class=<span class="string">"test-b"</span>&gt;
    &lt;<span class="tag">img</span> src=<span class="string">"test.jpg"</span>&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code><span class="class">.test-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
}</span>
<span class="class">.test-b</span>&gt;<span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">mix-blend-mode</span>:<span class="value"> luminosity</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-2.jpg" alt=""></p>
<p>因为<code>mix-blend-mode</code>是把整个元素向下进行混合，而不管它的下层是什么。因此第一种方式无法使用动画效果对图片进行还原。如果使用第二种方式，使用<code>background-blend-mode</code>属性，可以让每层背景跟它的下层背景混合，并且不关心元素之外的颜色。如果设置主色调为透明，就会还原到原来的图片。这样就可以使用动画对图片进行还原了。</p>
<pre><code>&lt;div class=<span class="string">"test-c"</span>&gt;&lt;/div&gt;
.test-c{
    <span class="built_in">background</span>-<span class="built_in">image</span>: url(test.jpg);
    <span class="built_in">background</span>-<span class="built_in">size</span>: cover;
    <span class="built_in">background</span>-<span class="built_in">color</span>: #<span class="number">655</span>;
    <span class="built_in">background</span>-<span class="built_in">blend</span>-mode: luminosity;
    transition: <span class="number">3</span>s <span class="built_in">background</span>-<span class="built_in">color</span>;
}
.test-c:hover{
    <span class="built_in">background</span>-<span class="built_in">color</span>: transparent;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-3.gif" alt=""></p>
<hr>
<h1 id="毛玻璃效果">毛玻璃效果</h1><p>半透明作为某个元素的背景，把它放在一张照片或者花哨的背景之上，是一种很美的设计效果，但是可能会导致文字比较难以阅读。比如下面这种情况：<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"blur-a"</span>&gt;
    &lt;blockquote&gt;
        “The only way <span class="keyword">to</span> <span class="keyword">get</span> rid <span class="keyword">of</span> a temptation <span class="keyword">is</span> <span class="keyword">to</span> yield <span class="keyword">to</span> <span class="keyword">it</span>. Resist <span class="keyword">it</span>, <span class="keyword">and</span> your soul grows sick <span class="keyword">with</span> longing <span class="keyword">for</span> <span class="keyword">the</span> things <span class="keyword">it</span> has forbidden <span class="keyword">to</span> itself, <span class="keyword">with</span> desire <span class="keyword">for</span> what <span class="keyword">its</span> monstrous laws have made monstrous <span class="keyword">and</span> unlawful.”
        &lt;cite&gt;— Oscar Wilde, The Picture <span class="keyword">of</span> Dorian Gray&lt;/cite&gt;
    &lt;/blockquote&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS：</p>
<pre><code><span class="class">.blur-a</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">20em</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(tiger.jpg)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> cover</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
<span class="class">.blur-a</span>&gt;<span class="tag">blockquote</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">80%</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">70%</span></span></span>;
    <span class="rule"><span class="attribute">font</span>:<span class="value"> italic bold <span class="number">140%</span>/<span class="number">140%</span> sans-serif</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>)</span></span>;
    <span class="comment">/*-webkit-filter:blur(2px);*/</span>
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> .<span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>) inset,
        <span class="number">0</span> .<span class="number">5em</span> <span class="number">1em</span> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>)</span></span>;
    <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>)</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-4.jpg" alt=""></p>
<p>这个时候可以使用模糊滤镜(<code>filter:blur(2px)</code>)产生一种毛玻璃的效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-5.jpg" alt=""><br>结果发现文字也被模糊了，如果想要不模糊文字，同时又有毛玻璃效果就可以使用下面这种方式。<br>首先要求背景图片的<code>background-attachment</code>为fixed，然后设置一个伪元素，将其定位到元素的下层，再对伪元素进行模糊。<br>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"blur-b"</span>&gt;
    &lt;blockquote&gt;
        “The only way <span class="keyword">to</span> <span class="keyword">get</span> rid <span class="keyword">of</span> a temptation <span class="keyword">is</span> <span class="keyword">to</span> yield <span class="keyword">to</span> <span class="keyword">it</span>. Resist <span class="keyword">it</span>, <span class="keyword">and</span> your soul grows sick <span class="keyword">with</span> longing <span class="keyword">for</span> <span class="keyword">the</span> things <span class="keyword">it</span> has forbidden <span class="keyword">to</span> itself, <span class="keyword">with</span> desire <span class="keyword">for</span> what <span class="keyword">its</span> monstrous laws have made monstrous <span class="keyword">and</span> unlawful.”
        &lt;cite&gt;— Oscar Wilde, The Picture <span class="keyword">of</span> Dorian Gray&lt;/cite&gt;
    &lt;/blockquote&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS：</p>
<pre><code><span class="class">.blur-b</span><span class="rules">{
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> -<span class="number">2</span></span></span>;
}</span>
<span class="class">.blur-b</span>&gt;<span class="tag">blockquote</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">80%</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">70%</span></span></span>;
    <span class="rule"><span class="attribute">font</span>:<span class="value"> italic bold <span class="number">140%</span>/<span class="number">140%</span> sans-serif</span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> .<span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>) inset,
        <span class="number">0</span> .<span class="number">5em</span> <span class="number">1em</span> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.6</span>)</span></span>;
    <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">3</span>)</span></span>;
}</span>
<span class="class">.blur-b</span>&gt;<span class="rule"><span class="attribute">blockquote</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(tiger.jpg) <span class="number">0</span> / cover fixed</span></span>;
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> -<span class="number">1</span></span></span>;
    <span class="rule"><span class="attribute">-webkit-filter</span>:<span class="value"> <span class="function">blur</span>(<span class="number">10px</span>)</span></span>;
    <span class="rule"><span class="attribute">filter</span>:<span class="value"> <span class="function">blur</span>(<span class="number">10px</span>)</span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> -<span class="number">30px</span></span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-10-6.jpg" alt=""></p>
<blockquote>
<p>这里有个坑，就是在背景图不是fixed的情况下使用毛玻璃，以后会填上的。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="染色效果">染色效果</h1><p>有时候会遇到这样一种场景:需要给图片增加染色效果，当发生hover或者交互时再把染色效果去除。<br>最容易想到的是以下两种方式：</p>
<ul>
<li>把图片做成两个版本，然后用CSS使得两个版本交替呈现。这种方式会导致更大的文件体积和额外的HTTP请求，同时也不便于维护(想改变染色主色调时需要重新制作图片)。</li>
<li>还有一种方式，可以在图片上方覆盖一层半透明的纯色或者把图片设置为半透明并覆盖在一层纯色背景之上。这种方式会降低图片的对比度。</li>
</ul>
<p>为了避免上面两种方式带来的问题，可以用下面这两种纯CSS的方式解决<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之单侧投影&不规则投影]]></title>
    <link href="http://blog.supce.com/2016/09/20/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%95%E4%BE%A7%E6%8A%95%E5%BD%B1&%E4%B8%8D%E8%A7%84%E5%88%99%E6%8A%95%E5%BD%B1/"/>
    <id>http://blog.supce.com/2016/09/20/CSS Secret 读书笔记之单侧投影&不规则投影/</id>
    <published>2016-09-19T16:00:00.000Z</published>
    <updated>2016-09-20T12:55:58.107Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="单侧投影">单侧投影</h1><p>有时候会遇到给元素设置单侧投影的情形。要想实现单侧投影，首先得了解<code>box-shadow</code>的工作原理。<br>平时使用<code>box-shadow</code>的方法是指定三个长度值和一个颜色值：</p>
<pre><code>box-shadow: <span class="number">2</span>px <span class="number">3</span>px <span class="number">4</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>)</span></span>;
</code></pre><p>此时，shadow是通过下面四个步骤绘制的：</p>
<ul>
<li>以该元素相同的尺寸和位置，画一个rgba(0,0,0,.5)的矩形</li>
<li>把它向右移2px，向下移3px</li>
<li>使用高斯模糊算法(或者类似算法)将它进行4px的模糊处理。模糊算法本质上是在阴影边缘发生阴影色和纯色透明色之间的颜色过渡，其长度近似于模糊半径的两倍(这里是8px)</li>
<li>最后，将模糊后的矩形与原始元素的交集部分切除掉，因此模糊的部分看起来是在该元素的后面，其实是和原始元素位于同一层。</li>
</ul>
<a id="more"></a>
<p>具体步骤如下图：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-1.jpg" alt=""></p>
<p>对于<code>box-shadow: 2px 3px 4px rgba(0,0,0,.5);</code>将在顶部看到1px的投影，左侧看到2px的投影，右侧看到6px的投影，底部看到7px的投影。<br>此时如果改变偏移量就可以把顶部和左侧隐藏起来，但是这样会导致露出的投影太过浓重，而且也不是单侧投影。 这时候就可以利用<code>box-shadow</code>的第四个参数来实现了。</p>
<h2 id="底边投影">底边投影</h2><p><code>box-shadow</code>的第四个参数被称作扩张半径。这个参数会根据指定值的正负去扩大或者缩小投影的尺寸。举例来说，一个-5px的扩张半径会把投影的宽度和高度减少10px(两边各5px)。<br>因此，设置一个负的扩张半径，其值刚好等于模糊半径，那么投影的尺寸就会与投影所属元素的尺寸完全一致。然后再通过偏移量进行单方向移动，就会产生单侧投影。比如下面的底边投影：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"shadow-b"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
<span class="keyword">div</span>{
    margin: <span class="number">20</span>px;
    width: <span class="number">10</span>em;
    height: <span class="number">6</span>em;
    background: <span class="comment">#fb3;</span>
    display: inline-block;
}
.shadow-b{
    box-shadow: <span class="number">0</span> <span class="number">6</span>px <span class="number">4</span>px -<span class="number">4</span>px black;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-2.jpg" alt=""></p>
<h2 id="邻边投影">邻边投影</h2><p>对于邻边投影：</p>
<ul>
<li>不能把投影缩小的太小，只需要把阴影藏进一侧，另一侧自然露出。可以设置扩张半径为模糊半径相反值的一半</li>
<li>指定两个偏移量，它们的值需要大于或者等于模糊半径的一半，这有这有才能把投影“藏进”元素内部。(其实是切割掉)</li>
</ul>
<p>代码如下：</p>
<pre><code><span class="class">.shadow-d</span><span class="rules">{
    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> -<span class="number">3px</span> black</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-3.jpg" alt=""></p>
<h2 id="双侧投影">双侧投影</h2><p>双侧投影很简单，利用单侧投影的原理，模拟两条投影即可：</p>
<pre><code>.shadow-e{
    box-shadow: <span class="number">5</span>px <span class="number">0</span> <span class="number">5</span>px -<span class="number">5</span>px black,
                -<span class="number">5</span>px <span class="number">0</span> <span class="number">5</span>px -<span class="number">5</span>px black;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-4.jpg" alt=""></p>
<hr>
<h1 id="不规则投影">不规则投影</h1><p>给一个矩形元素或者其他能用<code>border-radius</code>生成的形状(圆或者椭圆)加投影时，不会出现问题。<br>但是当给一个有伪元素装饰的元素或者虚线边框添加投影，或者给具有切角效果的元素添加投影时，会出现透明的效果。如下图：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-5.jpg" alt=""></p>
<p>这个问题可以用<code>filter</code>属性来解决，设置阴影滤镜<code>drop-shadow</code>，它接收的参数基本与<code>box-shadow</code>一样，但不包括扩展半径和inset关键字。也不支持逗号分隔的多层投影语法。<br>因此修改下上面的代码：</p>
<p>HTML:</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"drop-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"drop-b"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"drop-c"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS:</p>
<pre><code><span class="class">.drop-a</span>,<span class="class">.drop-b</span>,<span class="class">.drop-c</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="comment">/*box-shadow: 2px 2px 10px rgba(0,0,0,0.5);*/</span>
    <span class="rule"><span class="attribute">-webkit-filter</span>:<span class="value"> <span class="function">drop-shadow</span>(.<span class="number">3em</span> .<span class="number">3em</span> .<span class="number">3em</span> <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>))</span></span>;
}</span>
<span class="rule"><span class="attribute">.drop-a</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">right</span>:<span class="value"> -<span class="number">1em</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1em</span> solid transparent</span></span>;
    <span class="rule"><span class="attribute">border-left-color</span>:<span class="value"> <span class="hexcolor">#fb3</span></span></span>;
    <span class="rule"><span class="attribute">border-right-width</span>:<span class="value"> <span class="number">0</span></span></span>;
}
<span class="class">.drop-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> transparent</span></span>;
    <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> .<span class="number">5em</span> dashed <span class="hexcolor">#fb3</span></span></span>;
}</span>
<span class="class">.drop-c</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"> .<span class="number">5em</span> solid <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">border-image</span>:<span class="value"> <span class="number">1</span> <span class="function">url</span>(<span class="string">'data:image/svg+xml,\
                 &lt;svg xmlns="http://www.w3.org/2000/svg"\
                 width="3" height="3" fill="%23fb3"&gt;\
                 &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2"/&gt;\
        &lt;/svg&gt;'</span>)</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
    <span class="rule"><span class="attribute">box-sizing</span>:<span class="value"> border-box</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-09-6.jpg" alt=""></p>
<blockquote>
<p>今天发烧，就不多写了，可能通篇文章逻辑有些问题…</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="单侧投影">单侧投影</h1><p>有时候会遇到给元素设置单侧投影的情形。要想实现单侧投影，首先得了解<code>box-shadow</code>的工作原理。<br>平时使用<code>box-shadow</code>的方法是指定三个长度值和一个颜色值：</p>
<pre><code>box-shadow: <span class="number">2</span>px <span class="number">3</span>px <span class="number">4</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>)</span></span>;
</code></pre><p>此时，shadow是通过下面四个步骤绘制的：</p>
<ul>
<li>以该元素相同的尺寸和位置，画一个rgba(0,0,0,.5)的矩形</li>
<li>把它向右移2px，向下移3px</li>
<li>使用高斯模糊算法(或者类似算法)将它进行4px的模糊处理。模糊算法本质上是在阴影边缘发生阴影色和纯色透明色之间的颜色过渡，其长度近似于模糊半径的两倍(这里是8px)</li>
<li>最后，将模糊后的矩形与原始元素的交集部分切除掉，因此模糊的部分看起来是在该元素的后面，其实是和原始元素位于同一层。</li>
</ul>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之梯形标签页&饼图]]></title>
    <link href="http://blog.supce.com/2016/09/19/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A2%AF%E5%BD%A2%E6%A0%87%E7%AD%BE%E9%A1%B5&%E9%A5%BC%E5%9B%BE/"/>
    <id>http://blog.supce.com/2016/09/19/CSS Secret 读书笔记之梯形标签页&饼图/</id>
    <published>2016-09-18T16:00:00.000Z</published>
    <updated>2016-09-19T13:29:56.990Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="梯形标签页">梯形标签页</h1><p>梯形标签在导航栏部分经常遇到，书中只提到3D旋转的方案，但是万能的裁切和渐变怎么能丢？于是有了下面三种方式。</p>
<h2 id="裁切方案">裁切方案</h2><p>在形状这部分，裁切是一种很强大的方式，以左上角为原点，梯形的绘制对于它来说很简单。</p>
<pre><code>&lt;div class=<span class="string">"echelon-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
div{
    margin:<span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">4</span>em;
    font:<span class="number">125</span>%/<span class="number">4</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.echelon-a{
    <span class="built_in">background</span>: #<span class="number">58</span>a;
    -webkit-clip-path: polygon(<span class="number">20</span>% <span class="number">0</span>,<span class="number">80</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">100</span>%);
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-1.jpg" alt=""></p>
<h2 id="渐变方案">渐变方案</h2><p>到现在为止，利用渐变已经实现了条纹背景、复杂背景、图像边框以及下面的梯形。不得不说渐变真是一把利器。只要注意多层渐变的覆盖，设置好每层渐变的大小和位置即可。</p>
<pre><code><span class="class">.echelon-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="number">120deg</span>,transparent <span class="number">40px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>) top left,
                <span class="function">linear-gradient</span>(-<span class="number">120deg</span>,transparent <span class="number">40px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>) top right</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-2.jpg" alt=""></p>
<h2 id="3D旋转方案">3D旋转方案</h2><p>在现实的三维世界中旋转一个矩形，然后其在平面上的投影就是一个梯形。利用这个思路，可以尝试使用3D旋转来模拟一个梯形。<br>如果对元素直接使用<code>transform: perspective(.5em) rotateX(5deg);</code>,元素内部也会进行旋转，这并不是我们想要的结果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-3.jpg" alt=""><br>这时候可以利用伪元素来生成一个矩形，设置其堆叠次序，然后旋转为一个矩形。<br>仔细观察上面的图还会发现，内部的文字不居中了而且也变矮了，这是由于元素是以自身的中心线为轴进行空间旋转的。因此投影到2D屏幕上尺寸会发生变化，导致高度缩减，宽度增加。<br>为了控制它的尺寸，这时候可以指定<code>transform-origin</code>为bottom，当它在3D空间旋转时，可以把它的底边固定住。保证宽度不增加，然后再通过变形属性，即<code>scaleY()</code>来保证高度不会变低。<br>下面是完整的代码：</p>
<pre><code><span class="class">.echelon-c</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
}</span>
<span class="rule"><span class="attribute">.echelon-c</span>:<span class="value">before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> -<span class="number">1</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fb3</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">scaleY</span>(<span class="number">1.7</span>) <span class="function">perspective</span>(.<span class="number">5em</span>) <span class="function">rotateX</span>(<span class="number">5deg</span>)</span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> bottom</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-4.jpg" alt=""></p>
<h2 id="梯形导航">梯形导航</h2><p>上面说了3种方式主要是用于实现导航，这里就简单模拟了一个梯形的导航。详细过程就不说了，直接上代码。</p>
<blockquote>
<p>一定要注意在使用3D旋转时的元素的堆叠顺序。</p>
</blockquote>
<pre><code>&lt;nav&gt;
    &lt;a href="#"&gt;Home&lt;/a&gt;
    &lt;a href="#" class="selected"&gt;Contact&lt;/a&gt;
    &lt;a href="#"&gt;About&lt;/a&gt;
&lt;/nav&gt;
&lt;main&gt;Content&lt;/main&gt;
nav{
    position: relative<span class="comment">;</span>
    padding-left: 1em<span class="comment">;</span>
}
nav &gt; a {
    position: relative<span class="comment">;</span>
    display: inline-block<span class="comment">;</span>
    padding: .3em 1em 0<span class="comment">;</span>
    color: inherit<span class="comment">;</span>
    text-decoration: none<span class="comment">;</span>
    margin: 0 -.3em<span class="comment">;</span>
}
nav&gt;<span class="number">a::bef</span>ore,main{
    border: .1em solid rgba(0,0,0,.4)<span class="comment">;</span>
}
nav <span class="number">a::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    z-index: -1<span class="comment">;</span>
    border-bottom: none<span class="comment">;</span>
    border-radius: .5em .5em 0 0<span class="comment">;</span>
    background: #ccc linear-gradient(hsla(0,0%,100%,.6),hsla(0,0%,100%,0))<span class="comment">;</span>
    box-shadow: 0 .15em white inset<span class="comment">;</span>
    transform: scale(<span class="number">1.1,1.3</span>) perspective(.5em) rotateX(5deg)<span class="comment">;</span>
    transform-origin: bottom<span class="comment">;</span>
}
main {
    width: 30em<span class="comment">;</span>
    display: block<span class="comment">;</span>
    margin-bottom: 1em<span class="comment">;</span>
    background: #eee<span class="comment">;</span>
    padding: 1em<span class="comment">;</span>
    border-radius: .15em<span class="comment">;</span>
}
nav a:hover{
    z-index: 2<span class="comment">;</span>
}
nav a:hover<span class="number">::bef</span>ore{
    background-color: #eee<span class="comment">;</span>
    margin-bottom: -1px<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-5.gif" alt=""></p>
<h1 id="饼图">饼图</h1><p>一般在统计图表、进度指示器、定时器等场景中会用到饼图。我们希望能够很简单的创建出对应百分比的饼图，比如创建一个20%的饼图，只需一行代码，不引入外部插件。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"pie"</span>&gt;<span class="number">20</span>%&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>可以用下面这种方式解决。</p>
<h2 id="基于transform的解决方案">基于transform的解决方案</h2><p>首先要利用之前的border-radius创建一个圆，然后利用渐变遮盖半个圆。即：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"pie-test"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
.pie-test{
    width: <span class="number">100</span>px;
    height: <span class="number">100</span>px;
    border-radius: <span class="number">50</span>%;
    background: yellowgreen;
    background-image: linear-gradient(<span class="keyword">to</span> right,transparent <span class="number">50</span>%,<span class="comment">#655 0);</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-6.jpg" alt=""></p>
<p>然后设置伪元素，对右半圆进行遮盖</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
}
</code></pre><blockquote>
<p>设置border只是为了演示方便</p>
</blockquote>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-7.jpg" alt=""></p>
<p>对于伪元素，有3件微小的工作需要它完成</p>
<ul>
<li>第一件，希望它能遮盖有半侧的黑色部分，设置<code>background-color:inherit</code>即可。</li>
<li>第二件，希望它绕着圆形的圆心旋转，设置<code>transform-origin: left</code>或者0 50%</li>
<li>第三件，不希望它是矩形的，可以设置.pie-test为<code>overflow:hidden</code>或者给伪元素设置合理的<code>border-radius</code></li>
</ul>
<blockquote>
<p>伪元素：很惭愧，就做了三件微小的工作，谢谢大家！希望下次能控制天气~</p>
</blockquote>
<p>如果想要显示比例20%，只要旋转.2turn即可</p>
<p>具体代码如下：</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> inherit</span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(.<span class="number">2turn</span>)</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-8.jpg" alt=""></p>
<p>如果我们想要60%的比例，设置.6turn会出现下面的结果：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-9.jpg" alt=""></p>
<p>这时候可以把50%-100%看做另外一个问题，设置一个黑色的伪元素，让它在0-.5turn范围内旋转，此时，要得到一个60%比率的饼图，代码如下：</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(.<span class="number">1turn</span>)</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-10.jpg" alt=""></p>
<p>利用上面的代码可以用动画来做一个从0-100%的进度指示器了</p>
<p>这里给出完整代码：</p>
<pre><code>&lt;div class="pie-a"&gt;&lt;/div&gt;
@keyframes spin{
    to {transform: rotate(.5turn)<span class="comment">;}</span>
}
@keyframes bg{
    50% {background: #655<span class="comment">;}</span>
}
.pie-a{
    width: 100px<span class="comment">;</span>
    height: 100px<span class="comment">;</span>
    border-radius: 50%<span class="comment">;</span>
    background: yellowgreen<span class="comment">;</span>
    background-image: linear-gradient(to right,transparent 50%,#655 0)<span class="comment">;</span>
}
.pie-<span class="number">a::bef</span>ore{
    content: ''<span class="comment">;</span>
    display: block<span class="comment">;</span>
    margin-left: 50%<span class="comment">;</span>
    height: 100%<span class="comment">;</span>
    background-color: inherit<span class="comment">;</span>
    transform-origin: 0 50%<span class="comment">;</span>
    border-radius: 0 100% 100% 0 / 50%<span class="comment">;</span>
    animation: spin 3s linear infinite,
               bg 6s step-end infinite<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-11.gif" alt=""></p>
<p>下面再来实现最初的需求，核心是利用动画。<br>一个负的延时值是合法的，它意味着动画会立即开始播放，但会自动前进到延时值的绝对处，这样在视觉上就好像动画跳过指定时间直接播放了。<br>然后再让它暂停到我们需要的位置即可。<br>我们可以设置一个长达100S的动画，便于计算。<br>代码如下：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>0%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>40%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>80%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
@keyframes spin{
    to {transform: rotate(.5turn);}
}
@keyframes bg{
    50% {background: #655;}
}
.pie{
    position: relative;
    display: inline-block;
    width: 100px;
    line-height: 100px;
    border-radius: 50%;
    background: yellowgreen;
    background-image: linear-gradient(to right,transparent 50%,#655 0);
    color: transparent;
}
.pie::before{
    content: '';
    position: absolute;
    top: 0;left: 50%;
    width: 50%;height: 100%;
    border-radius: 0 100% 100% 0 / 50%;
    background-color: inherit; 
    transform-origin: left;
    animation: spin 50s linear infinite,
               bg 100s step-end infinite;
    animation-play-state: paused;
    animation-delay: inherit;
}
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">var</span> elements = context.querySelectorAll(selector);
        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);
    }
    $$(<span class="string">'.pie'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">pie</span>)</span>{
        <span class="keyword">var</span> p = pie.textContent;
        pie.style.animationDelay = <span class="string">'-'</span> + <span class="built_in">parseFloat</span>(p) + <span class="string">'s'</span>;
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-12.jpg" alt=""></p>
<h2 id="SVG解决方案">SVG解决方案</h2><p>还有一种是利用SVG来实现，主要原理的是stroke-dasharray属性，使它的虚线间隙超过圆的周长，利用描边来表示百分比。下面不在细说，直接给出实现代码：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie-svg"</span>&gt;</span>20%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie-svg"</span>&gt;</span>80%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">var</span> elements = context.querySelectorAll(selector);
        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);
    }
    $$(<span class="string">'.pie-svg'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">pie</span>)</span>{
        <span class="keyword">var</span> p = <span class="built_in">parseFloat</span>(pie.textContent);
        <span class="keyword">var</span> NS = <span class="string">"http://www.w3.org/2000/svg"</span>;
        <span class="keyword">var</span> svg = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"svg"</span>);
        <span class="keyword">var</span> circle = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"circle"</span>);
        <span class="keyword">var</span> title = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"title"</span>);

        circle.setAttribute(<span class="string">"r"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"cx"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"cy"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"stroke-dasharray"</span>, p + <span class="string">" 100"</span>);

        svg.setAttribute(<span class="string">"viewBox"</span>, <span class="string">"0 0 32 32"</span>);
        title.textContent = pie.textContent;
        pie.textContent = <span class="string">''</span>;
        svg.appendChild(title);
        svg.appendChild(circle);
        pie.appendChild(svg); 
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-13.jpg" alt=""><br>上面直接利用JavaScript完成自动化。也可以自己编写SVG标签。</p>
<pre><code><span class="tag">svg</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(-<span class="number">90deg</span>)</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> yellowgreen</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;
}</span>
<span class="tag">circle</span><span class="rules">{
    <span class="rule"><span class="attribute">fill</span>:<span class="value"> yellowgreen</span></span>;
    <span class="rule"><span class="attribute">stroke</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
    <span class="rule"><span class="attribute">stroke-width</span>:<span class="value"> <span class="number">32</span></span></span>;
}</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="梯形标签页">梯形标签页</h1><p>梯形标签在导航栏部分经常遇到，书中只提到3D旋转的方案，但是万能的裁切和渐变怎么能丢？于是有了下面三种方式。</p>
<h2 id="裁切方案">裁切方案</h2><p>在形状这部分，裁切是一种很强大的方式，以左上角为原点，梯形的绘制对于它来说很简单。</p>
<pre><code>&lt;div class=<span class="string">"echelon-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
div{
    margin:<span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">4</span>em;
    font:<span class="number">125</span>%/<span class="number">4</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.echelon-a{
    <span class="built_in">background</span>: #<span class="number">58</span>a;
    -webkit-clip-path: polygon(<span class="number">20</span>% <span class="number">0</span>,<span class="number">80</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">100</span>%);
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之菱形图片&切角效果]]></title>
    <link href="http://blog.supce.com/2016/09/18/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%8F%B1%E5%BD%A2%E5%9B%BE%E7%89%87&%E5%88%87%E8%A7%92%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.supce.com/2016/09/18/CSS Secret 读书笔记之菱形图片&切角效果/</id>
    <published>2016-09-17T16:00:00.000Z</published>
    <updated>2016-09-18T13:05:37.670Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="菱形图片">菱形图片</h1><p>有时候可能会遇到菱形图片的需求，可以用下面两种方式实现。</p>
<h2 id="基于变形的方案">基于变形的方案</h2><p>这种方式与之前平行四边形的解决方案类似，需要把图片用一个div包裹，然后div和img进行相反的变形。</p>
<pre><code>&lt;div class=<span class="string">"diamond-a"</span>&gt;
    &lt;img src=<span class="string">"cat.jpg"</span>&gt;
&lt;/div&gt;
.diamond-a{
    margin: <span class="number">100</span>px;
    <span class="variable">width</span>: <span class="number">250</span>px;
    <span class="variable">height</span>:<span class="number">250</span>px;
    transform: <span class="built_in">rotate</span>(<span class="number">45</span>deg);
    overflow: hidden;
}
.diamond-a &gt; img{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">100</span>%;
    transform: <span class="built_in">rotate</span>(-<span class="number">45</span>deg);
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-1.jpg" alt=""><br>得到的结果是个八角形。原因就是<code>max-width: 100%;</code>会解析为外部容器的边长，如果图片的宽度与容器的菱形对角线长度相同，就会成为一个菱形。也就是设置宽度为外部容器边长的√2倍，即约为1.42倍。</p>
<pre><code><span class="class">.diamond-a</span> &gt; <span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(-<span class="number">45deg</span>) <span class="function">scale</span>(<span class="number">1.42</span>)</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-2.jpg" alt=""></p>
<h2 id="裁切路径方案">裁切路径方案</h2><p>上面的方法首先破坏了原有的HTML结构，而且要求图片必须是正方形。<br>这里就可以用裁切的方法来实现。而且可以给图片添加动画，当鼠标悬停时，图片扩展为完整的面积。</p>
<pre><code>&lt;img <span class="keyword">class</span>=<span class="string">"diamond-b"</span> src=<span class="string">"cat.jpg"</span> /&gt;
.diamond-b{
    width: <span class="number">250</span>px;
    -webkit-clip-path: polygon(<span class="number">50</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">50</span>%,<span class="number">50</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">50</span>%);
    clip-path: polygon(<span class="number">50</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">50</span>%, <span class="number">50</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">50</span>%);
    transition: <span class="number">1</span>s;
}
.diamond-b:hover{
    -webkit-clip-path: polygon(<span class="number">0</span> <span class="number">0</span>, <span class="number">100</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">100</span>%);
    clip-path: polygon(<span class="number">0</span> <span class="number">0</span>, <span class="number">100</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">100</span>%);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-4.gif" alt=""></p>
<hr>
<h1 id="切角效果">切角效果</h1><p>之前的切角效果大多是使用背景图片来达到目的，比如使用三角形盖住元素的顶角来模拟切角效果(当网页背景是纯色时)，或者使用一张或者多张已经切过角的图片来作为整个元素的背景。这些方法增加了额外的HTTP请求，而且也不够灵活，不易维护。<br>这时候可以根据场景用下面几种方式来实现。</p>
<h2 id="渐变方案">渐变方案</h2><p>在之前渐变已经帮助我们实现了好多特效比如条纹背景，复杂背景以及图像边框等。这次来帮助我们实现切角效果，后面也还有它大展神通的地方！<br>渐变方案很简单，把一个透明色放在切角处即可，以右下角为例：</p>
<pre><code>&lt;div class=<span class="string">"rad-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
.rad-a{
    margin: <span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">6</span>em;
    font: <span class="number">125</span>%/<span class="number">6</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.rad-a{
    <span class="built_in">background</span>: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,#<span class="number">58</span>a <span class="number">15</span>px);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-5.jpg" alt=""></p>
<p>假设需要裁剪底部两个角。最初的想法可能会是这样：</p>
<pre><code>.rad-b{
    background: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px),</span>
                linear-gradient(<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#fb3 <span class="number">15</span>px);   </span>
}
</code></pre><p>但会发现结果是这样的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-6.jpg" alt=""><br>这是因为两层渐变互相覆盖的结果。<br>那可以对每层渐变进行位置和大小的修改来实现：</p>
<pre><code><span class="class">.rad-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(-<span class="number">45deg</span>,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) right,
                <span class="function">linear-gradient</span>(<span class="number">45deg</span>,transparent <span class="number">15px</span>,<span class="hexcolor">#fb3</span> <span class="number">15px</span>) left</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-7.jpg" alt=""></p>
<p>那么也可以做出切出四角的效果了:</p>
<pre><code>.rad-c{
    background: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) bottom right,</span>
                linear-gradient(<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) bottom left,</span>
                linear-gradient(<span class="number">135</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) top left,</span>
                linear-gradient(-<span class="number">135</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">48</span>a <span class="number">15</span>px) top right;</span>
    background-size: <span class="number">50</span>% <span class="number">50</span>%;
    background-repeat: no-repeat;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-8.jpg" alt=""></p>
<blockquote>
<p>可以用SCSS预处理下，需要的时候直接调用</p>
</blockquote>
<h2 id="弧形切角">弧形切角</h2><p>既然有了<code>linear-gradient</code>，那使用<code>radial-gradient</code>就可以创建出弧形切角</p>
<pre><code><span class="class">.rad-d</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">radial-gradient</span>(circle at top left,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) top left,
                <span class="function">radial-gradient</span>(circle at top right,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) top right,
                <span class="function">radial-gradient</span>(circle at bottom left,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) bottom left,
                <span class="function">radial-gradient</span>(circle at  bottom right,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) bottom right</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-9.jpg" alt=""></p>
<h2 id="内联SVG与border-image方案">内联SVG与border-image方案</h2><p>这个方式，是利用<code>border-image</code>的缩放，设置SVG为一个八角形，那么得出的效果就是我们需要的切角效果。</p>
<pre><code><span class="class">.rad-e</span><span class="rules">{
    <span class="rule"><span class="attribute">color</span>:<span class="value"> black</span></span>;
    <span class="comment">/*border:20px solid transparent;*/</span>
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">20px</span> solid <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">border-image</span>:<span class="value"> <span class="number">1</span> <span class="function">url</span>(<span class="string">'data:image/svg+xml,\
                  &lt;svg xmlns="http://www.w3.org/2000/svg" width="3" height="3" fill="%2358a"&gt;\
                  &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2" /&gt;\
                  &lt;/svg&gt;'</span>)</span></span>;
    <span class="comment">/*background: #58a;*/</span>
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">radial-gradient</span>(circle at center,<span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">5</span>),<span class="hexcolor">#58a</span>)</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-10.jpg" alt=""></p>
<blockquote>
<p>注意，由于背景色会延伸到边框，所以一定要记着设置background-clip的值。为了平稳退化，防止浏览器不支持border-image，可以设置border的颜色与背景色相同</p>
</blockquote>
<h2 id="裁切路径方案-1">裁切路径方案</h2><p>跟上面提到的菱形一样，也可以用裁切路径的方案</p>
<pre><code>.rad-f{
    <span class="comment">/*background: #58a;*/</span>
    background: url(cat.jpg);
    background-size: <span class="number">100</span>% <span class="number">100</span>%;
    clip-path: polygon(<span class="number">20</span>px <span class="number">0</span>, calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">0</span>, <span class="number">100</span>% <span class="number">20</span>px, <span class="number">100</span>% calc(<span class="number">100</span>% - <span class="number">20</span>px),calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">100</span>%,
                               <span class="number">20</span>px <span class="number">100</span>%, <span class="number">0</span> calc(<span class="number">100</span>% - <span class="number">20</span>px), <span class="number">0</span> <span class="number">20</span>px);
    -webkit-clip-path: polygon(<span class="number">20</span>px <span class="number">0</span>, calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">0</span>, <span class="number">100</span>% <span class="number">20</span>px, <span class="number">100</span>% calc(<span class="number">100</span>% - <span class="number">20</span>px),calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">100</span>%,
                               <span class="number">20</span>px <span class="number">100</span>%, <span class="number">0</span> calc(<span class="number">100</span>% - <span class="number">20</span>px), <span class="number">0</span> <span class="number">20</span>px);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-11.jpg" alt=""></p>
<ul>
<li>使用这个方式的好处显而易见，就是可以使用任意类型的背景，就如上面的例子背景如果是图片也可以进行剪裁。而且想菱形那里设置hover动画效果等。</li>
</ul>
<ul>
<li>但是，它有一个缺点，当内边距不够宽时，它会裁切掉文本。因为它只能对元素做出统一的裁切，并不能区分元素的部分。而在渐变方案中，允许字体溢出并超出切角区域(因为它只是背景图案)，而<code>border-image</code>会起到普通边框的作用，使文字折行。</li>
</ul>
<p><em>今天天津好冷</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="菱形图片">菱形图片</h1><p>有时候可能会遇到菱形图片的需求，可以用下面两种方式实现。</p>
<h2 id="基于变形的方案">基于变形的方案</h2><p>这种方式与之前平行四边形的解决方案类似，需要把图片用一个div包裹，然后div和img进行相反的变形。</p>
<pre><code>&lt;div class=<span class="string">"diamond-a"</span>&gt;
    &lt;img src=<span class="string">"cat.jpg"</span>&gt;
&lt;/div&gt;
.diamond-a{
    margin: <span class="number">100</span>px;
    <span class="variable">width</span>: <span class="number">250</span>px;
    <span class="variable">height</span>:<span class="number">250</span>px;
    transform: <span class="built_in">rotate</span>(<span class="number">45</span>deg);
    overflow: hidden;
}
.diamond-a &gt; img{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">100</span>%;
    transform: <span class="built_in">rotate</span>(-<span class="number">45</span>deg);
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之自适应椭圆&平行四边形]]></title>
    <link href="http://blog.supce.com/2016/09/17/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E9%80%82%E5%BA%94%E6%A4%AD%E5%9C%86&%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/"/>
    <id>http://blog.supce.com/2016/09/17/CSS Secret 读书笔记之自适应椭圆&平行四边形/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2016-09-17T03:35:13.305Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="自适应椭圆">自适应椭圆</h1><p>对于一个正方形的元素，如果设置其属性<code>border-radius</code>的值大于等于边长的一半，那么该元素会变成一个圆形。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"round-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
body{
    display: flex;
    flex-flow: row wrap; 
    justify-content: <span class="constant">space</span>-<span class="keyword">around</span>;
}
.<span class="command">round</span>-a{
    background: <span class="comment">#fb3;</span>
    width: <span class="number">10</span>em;
    height: <span class="number">10</span>em;
    border-radius: <span class="number">50</span>%;
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-1.jpg" alt=""></p>
<p>那么对于矩形设置合适的水平与垂直<code>border-radius</code>就可以创建出一个椭圆了。<br>恰好<code>border-radius</code>可以单独指定水平和垂直半径，只要用一个斜杠(/)分隔这两个值即可。比如对于<code>200px * 150px</code>的元素，把它圆角的两个半径值分别设为宽高的一般(<code>border-radius: 100px / 75px</code>)，就可以得到一个椭圆了。<br>为了创建能够自适应的椭圆，只要把参数改为百分比。</p>
<pre><code><span class="class">.round-b</span>{
    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">20px</span>;
    <span class="attribute">background</span>: <span class="hexcolor">#fb3</span>;
    <span class="attribute">width</span>: <span class="number">10em</span>;
    <span class="attribute">height</span>: <span class="number">6em</span>;
}
<span class="class">.round-b</span>{
    <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">50%</span>;
    <span class="comment">/*border-radius: 50%;*/</span>   <span class="comment">//简写</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-2.jpg" alt=""></p>
<h2 id="半椭圆">半椭圆</h2><p>由于<code>border-radius</code>的灵活性为我们创建半椭圆提供了可能性。<br>首先，它支持给每个角指定不同的半径。即展开式属性：</p>
<ul>
<li>border-top-left-radius</li>
<li>border-top-right-radius</li>
<li>border-bottom-right-radius</li>
<li>border-bottom-left-radius</li>
</ul>
<p>当然，也可以一次提供用空格分开的多个值来简写。</p>
<ul>
<li>如果指定四个值，则按照左上，右上，右下，左下 这种逆时针指定。</li>
<li>如果指定三个值，则第一个表左上，第二个表示右上与左下，第三个表示右下。</li>
<li>如果指定两个值，则第一个表示左上与右下，第二个表示右上与左下。</li>
<li>如果指定一个值，则表示四个角均为该值。</li>
</ul>
<p>但是<code>border-radius</code>比我之前想到的更加灵活，除了可以指定每个角为不同的半径，还可以为四个角提供完全不同的水平和垂直半径。<br>方法是在斜杠前指定1-4个值表示水平半径，在斜杠后指定1-4个值表示垂直半径。这两组值的简写规则与之前不同，是单独展开为四个值的。比如<code>border-radius: 10px / 5px 20px;</code>效果相当于<code>border-radius: 10px 10px 10px 10px / 5px 20px 5px 20px;</code></p>
<p>有了上面这些，就可以轻松创建一个沿横轴的半椭圆了：</p>
<pre><code>.round-c{
    border-radius: <span class="number">50</span>% / <span class="number">100</span>% <span class="number">100</span>% <span class="number">0</span> <span class="number">0</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-3.jpg" alt=""></p>
<p>也创建一个沿纵轴的半椭圆：</p>
<pre><code>.round-d{
    border-radius: <span class="number">0</span> <span class="number">100</span>% <span class="number">100</span>% <span class="number">0</span> / <span class="number">50</span>%;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-4.jpg" alt=""></p>
<h2 id="四分之一椭圆">四分之一椭圆</h2><p>按照上面的思路，要创建一个四分之一椭圆，其中一个角的水平和垂直半径都需要是100%，其他的三个角不能设为圆角。于是：</p>
<pre><code><span class="class">.round-e</span><span class="rules">{
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-5.jpg" alt=""></p>
<hr>
<h1 id="平行四边形">平行四边形</h1><p>在导航栏有时候会用到平行四边形。之前也写过几种实现的方法，当时用到了背景图片，这里用纯CSS实现下。<br>最简单的方法就是对于一个普通的矩形进行斜向拉伸：</p>
<pre><code>&lt;div class="para-a"&gt;this is a test&lt;/div&gt;
.para-a{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    background: #58a<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
}
.para-a{
    transform: skewX(-45deg)<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-6.jpg" alt=""><br>但是这样带来一个问题，就是文字也随着被斜向拉伸了，可以用下面两种方式，只让容器形状倾斜，同时保持内容不被拉伸。</p>
<h2 id="嵌套元素方案">嵌套元素方案</h2><p>最容易想到的方法就是嵌套一个元素了。对容器内部的元素再进行一次反向拉伸，抵消外部容器的拉伸效果。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"para-b"</span>&gt;
    &lt;<span class="keyword">div</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
.para-b{
    margin: <span class="number">20</span>px <span class="number">20</span>px;
    width: <span class="number">10</span>em;
    height: <span class="number">4</span>em;
    background: <span class="comment">#58a;</span>
    color: white;
    <span class="type">text</span>-align: center;
    font: <span class="number">125</span>%/<span class="number">4</span>em sans-serif;
}
.para-b{
    transform: skewX(-<span class="number">45</span>deg);
}
.para-b &gt; <span class="keyword">div</span>{
    transform: skewX(<span class="number">45</span>deg);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-7.jpg" alt=""></p>
<h2 id="伪元素方案">伪元素方案</h2><p>根据之前的经验，既然可以嵌套元素，那么应该也可以使用伪元素来避免污染原有的HTML结构。</p>
<pre><code>&lt;div class="para-c"&gt;this is a test&lt;/div&gt;
.para-c{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
    position: relative<span class="comment">;</span>
}
.para-<span class="number">c::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    background: #58a<span class="comment">;</span>
    z-index: -1<span class="comment">;</span>
    transform: skewX(-45deg)<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-8.jpg" alt=""></p>
<blockquote>
<p>注意，这种方式虽然在视觉上是平行四边形，但是他实际所占据的仍然是个矩形。</p>
</blockquote>
<h1 id="内边框圆角">内边框圆角</h1><p>利用这种思路，可以给之前的内边框圆角增加一种实现方式</p>
<pre><code>&lt;div class="bor-ra"&gt;this is a test&lt;/div&gt;
.bor-ra{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
    position: relative<span class="comment">;</span>
}
.bor-ra{
    background: tan<span class="comment">;</span>
    border-radius: .8em<span class="comment">;</span>
    outline: .6em solid #655<span class="comment">;</span>
}
.bor-r<span class="number">a::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    background: #655<span class="comment">;</span>
    z-index: -1<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-9.jpg" alt=""></p>
<p>OK 搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="自适应椭圆">自适应椭圆</h1><p>对于一个正方形的元素，如果设置其属性<code>border-radius</code>的值大于等于边长的一半，那么该元素会变成一个圆形。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"round-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
body{
    display: flex;
    flex-flow: row wrap; 
    justify-content: <span class="constant">space</span>-<span class="keyword">around</span>;
}
.<span class="command">round</span>-a{
    background: <span class="comment">#fb3;</span>
    width: <span class="number">10</span>em;
    height: <span class="number">10</span>em;
    border-radius: <span class="number">50</span>%;
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之条纹背景&复杂背景]]></title>
    <link href="http://blog.supce.com/2016/09/16/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9D%A1%E7%BA%B9%E8%83%8C%E6%99%AF&%E5%A4%8D%E6%9D%82%E8%83%8C%E6%99%AF/"/>
    <id>http://blog.supce.com/2016/09/16/CSS Secret 读书笔记之条纹背景&复杂背景/</id>
    <published>2016-09-15T16:00:00.000Z</published>
    <updated>2016-09-16T11:43:11.307Z</updated>
    <content type="html"><![CDATA[<h1 id="条纹背景">条纹背景</h1><p>通常条纹背景是由一个图片来代替，或者使用SVG。能不能利用CSS直接创建条纹图案呢，答案是肯定的。<br>假设背景是垂直线性渐变。比如：<code>background:linear-gradient(#fb3,#58a);</code><br>效果是这个样子的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-1.jpg" alt=""><br>如果让渐变区域变的更窄，产生一个无限小的渐变区域，比如：<code>background:linear-gradient(#fb3 50%,#58a 50%);</code> 就可以得到想要的结果了。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-2.jpg" alt=""><br><a id="more"></a></p>
<h2 id="横向条纹">横向条纹</h2><p>利用上面的方法可以轻松利用CSS绘出横向条纹，同时还可以设置多种颜色的条纹，以及每个条纹的尺寸。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-b"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-c"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="tag">body</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
}</span>
<span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">10em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">6em</span></span></span>;
}</span>
<span class="class">.test-a</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">50%</span>, <span class="hexcolor">#58a</span> <span class="number">50%</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">24px</span></span></span>;
}</span>
<span class="class">.test-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">30%</span>, <span class="hexcolor">#58a</span> <span class="number">30%</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">24px</span></span></span>;
}</span>
<span class="class">.test-c</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">33.3%</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">66.6%</span>,yellowgreen <span class="number">0</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">36px</span></span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-3.jpg" alt=""></p>
<h2 id="垂直条纹">垂直条纹</h2><p>幸好<code>linear-gradient</code>足够的灵活，利用它可以轻松创建出垂直条纹。<br>代码：</p>
<pre><code>&lt;<span class="operator">div</span> class=<span class="string">"test-d"</span>&gt;&lt;/<span class="operator">div</span>&gt;
.test-d{
    background: linear-gradient(<span class="built_in">to</span> <span class="constant">right</span>,<span class="comment">#fb3 50%,#58a 50%);</span>
    <span class="comment">/*background: linear-gradient(90deg,#fb3 50%,#58a 50%);*/</span>
    background-size: <span class="number">32</span>px <span class="number">100</span>%;   <span class="comment">/*颠倒下宽度和高度值*/</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-11.jpg" alt=""></p>
<h2 id="斜向条纹">斜向条纹</h2><p>在绘制斜向条纹之前，如果对<code>linear-gradient</code>的斜向线性渐变不太理解，可以参考下张鑫旭大神的这篇<a href="http://www.zhangxinxu.com/wordpress/?p=3639" target="_blank" rel="external">博文</a><br>在完成水平和垂直条纹后，好像斜向条纹也很就简单，稍微修改下渐变方向和<code>background-size</code>的值就可以了。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="hexcolor">#fb3</span> <span class="number">50%</span>,<span class="hexcolor">#58a</span> <span class="number">50%</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p>但是得到的结果并不是想要的。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-4.jpg" alt=""><br>如果观察下斜向条纹，会发现斜向条纹是由四条条纹的“贴片”组成的。如下图：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-5.jpg" alt=""><br>这样的话解决思路就有了。</p>
<pre><code>background:linear-gradient(<span class="number">45</span>deg,<span class="preprocessor">#fb3 <span class="number">25</span>%,#<span class="number">58</span>a <span class="number">0</span>,#<span class="number">58</span>a <span class="number">50</span>%,#fb3 <span class="number">0</span>,#fb3 <span class="number">75</span>%,#<span class="number">58</span>a <span class="number">0</span>);</span>
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-6.jpg" alt=""><br>但是会发现条纹的宽度并不是16像素，因为<code>background-size</code>指定的长度是最左下角的直角三角形的直角边长度。而条纹的宽度是直角三角形的高，对于45度的三角形，要想高为16px，直角边设置为16√2，即<code>background-size</code>设置为2*16√2的约值。<br>好了，45度的斜向条纹完成了，好像其他度数的条纹比葫芦画瓢轻松得来，设置度数为60度</p>
<pre><code>background:linear-gradient(<span class="number">60</span>deg,<span class="preprocessor">#fb3 <span class="number">25</span>%,#<span class="number">58</span>a <span class="number">0</span>,#<span class="number">58</span>a <span class="number">50</span>%,#fb3 <span class="number">0</span>,#fb3 <span class="number">75</span>%,#<span class="number">58</span>a <span class="number">0</span>);</span>
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p>结果是这个样子：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-7.jpg" alt=""><br>看来得换个思路了。<br>这时候可以祭出<code>repeating-linear-gradient()</code>了，它的工作方式与<code>linear-gradient</code>类似，只有一点不同，色标是无限循环重复的，直至填满整个背景。比如：</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">45deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#58a</span> <span class="number">30px</span>)</span></span>;
</code></pre><p>就等于</p>
<pre><code>background:repeating-linear-gradient(<span class="number">45</span>deg,
                    <span class="preprocessor">#fb3,#<span class="number">58</span>a <span class="number">30</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">30</span>px,#<span class="number">58</span>a <span class="number">60</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">60</span>px,#<span class="number">58</span>a <span class="number">90</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">90</span>px,#<span class="number">58</span>a <span class="number">120</span>px,...);</span>
</code></pre><p>45°斜向条纹就可以轻松创建了</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">45deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#fb3a</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>;
</code></pre><p>同时<code>background-size</code>也不用设置，因为长度就是直接在渐变轴上进行度量的。<br>现在试试60°的斜向条纹</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">60deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#fb3</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>;
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-8.jpg" alt=""></p>
<h2 id="灵活的同色系条纹">灵活的同色系条纹</h2><p>存在这样一种场景，我们想要的条纹图案并不是由差异极大的几种颜色组成的，而是由同色系但亮度不同的条纹组成。比如：</p>
<pre><code><span class="attribute">background</span>: <span class="function"><span class="title">repeating-linear-gradient</span><span class="params">(<span class="number">30deg</span>,<span class="hexcolor">#79b</span>,<span class="hexcolor">#79b</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>
</code></pre><p>是这种效果<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-9.jpg" alt=""><br>但是，如果想要修改颜色，就需要对上面的代码进行4处修改。身为懒癌患者，这是不能忍受的。于是诞生了下面这种方式：<br>先把最深的颜色指定为背景色，同时把半透明的白色条纹叠加在背景色之上来得到浅色条纹。</p>
<pre><code>background: <span class="preprocessor">#<span class="number">58</span>a;</span>
background-image: repeating-linear-gradient(<span class="number">30</span>deg,hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.1</span>),hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.1</span>) <span class="number">16</span>px,
transparent <span class="number">16</span>px, transparent <span class="number">32</span>px);
</code></pre><p>这样就舒服多了：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-10.jpg" alt=""></p>
<h1 id="复杂的背景图案">复杂的背景图案</h1><p>这里所说的复杂背景图案是指下面的网格、波点和棋盘背景。其实这些都是<code>gradient</code>的一些扩展应用。</p>
<h2 id="网格">网格</h2><p>有了上面的水平和垂直条纹，网格背景其实就是两者的结合。举个最简单的例子。</p>
<pre><code>background: white;
background-image: linear-gradient(<span class="number">90</span>deg,rgba(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>) <span class="number">50</span>%,transparent <span class="number">50</span>%),
    linear-gradient(rgba(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>) <span class="number">50</span>%,transparent <span class="number">50</span>%);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-12.jpg" alt=""><br>常用的可能会需要下面这种细线条单色网格背景。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#58a</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">linear-gradient</span>(white <span class="number">1px</span>,transparent <span class="number">1px</span>),
                      <span class="function">linear-gradient</span>(<span class="number">90deg</span>,white <span class="number">1px</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-13.jpg" alt=""></p>
<p>偶尔还可能会用到两幅不同线宽的网格图案。显得更为真实一些，比如：</p>
<pre><code>background: <span class="preprocessor">#<span class="number">58</span>a;</span>
background-image: linear-gradient(white <span class="number">2</span>px,transparent <span class="number">0</span>),
                linear-gradient(<span class="number">90</span>deg,white <span class="number">2</span>px,transparent <span class="number">0</span>),
                linear-gradient(hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.3</span>) <span class="number">1</span>px,transparent <span class="number">0</span>),
                linear-gradient(<span class="number">90</span>deg,hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.3</span>) <span class="number">1</span>px,transparent <span class="number">0</span>);
background-size: <span class="number">48</span>px <span class="number">48</span>px,<span class="number">48</span>px <span class="number">48</span>px,<span class="number">16</span>px <span class="number">16</span>px,<span class="number">16</span>px <span class="number">16</span>px;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-14.jpg" alt=""></p>
<h2 id="波点">波点</h2><p>相对于网格背景，我个人更偏向于波点背景，波点背景其实是利用的径向渐变。最简单的就是圆点的阵列。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-15.jpg" alt=""><br>但是，这样看起来不是很自然。这时候可以考虑把两个径向渐变图像错位相排。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>),
                <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
<span class="rule"><span class="attribute">background-position</span>:<span class="value"> <span class="number">0px</span> <span class="number">0px</span>,<span class="number">16px</span> <span class="number">16px</span></span></span>; 
</code></pre><p>这样的话就比较自然了<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-16.jpg" alt=""><br>但是这段代码的可维护性确实很差，幸好Sass大法好。</p>
<pre><code><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> polka</span>(<span class="variable">$size</span>,<span class="variable">$dot</span>,<span class="variable">$base</span>,<span class="variable">$accent</span>){</span>
    <span class="attribute">background</span><span class="value">: <span class="variable">$base</span>;</span>
    <span class="attribute">background-image</span><span class="value">: <span class="function">radial-gradient</span>(<span class="variable">$accent</span> <span class="variable">$dot</span>,transparent <span class="number">0</span>),
                      <span class="function">radial-gradient</span>(<span class="variable">$accent</span> <span class="variable">$dot</span>,transparent <span class="number">0</span>);</span>
    <span class="attribute">background-size</span><span class="value">: <span class="variable">$size</span> <span class="variable">$size</span>;</span>
    <span class="attribute">background-position</span><span class="value">: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span>/<span class="number">2</span> <span class="variable">$size</span>/<span class="number">2</span>
}
@include <span class="function">polka</span>(<span class="number">32px</span>,<span class="number">30%</span>,<span class="hexcolor">#655</span>,tan);</span>
</code></pre><blockquote>
<p>每次$dot都打成$dota</p>
</blockquote>
<h2 id="棋盘">棋盘</h2><p>棋盘的话，见得并不多，调试的时候可以看见透明色就是用灰色棋盘来表示的。<br>棋盘的实现稍微复杂些，首先，利用渐变绘制出如图案：</p>
<pre><code>background: <span class="preprocessor">#eee;</span>
background-image: linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,
            transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-17.jpg" alt=""><br>这时候会发现，再绘制一份相同的背景，然后错下位就可以实现棋盘效果了。</p>
<pre><code>background: <span class="preprocessor">#eee;</span>
background-image: linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>),
                  linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
background-position: <span class="number">0</span> <span class="number">0</span> ,<span class="number">16</span>px <span class="number">16</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-18.jpg" alt=""></p>
<p>当然在懒人癌的作用下，利用Sass处理下：</p>
<pre><code><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> checkerboard</span>(<span class="variable">$size</span>,<span class="variable">$base</span>,<span class="variable">$accent</span>){</span>
    <span class="attribute">background</span><span class="value">: <span class="variable">$base</span>;</span>
    <span class="attribute">background-image</span><span class="value">: <span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="variable">$accent</span> <span class="number">25%</span>,transparent <span class="number">0</span>, transparent <span class="number">75%</span>,<span class="variable">$accent</span> <span class="number">0</span>),
    <span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="variable">$accent</span> <span class="number">25%</span>,transparent <span class="number">0</span>, transparent <span class="number">75%</span>,<span class="variable">$accent</span> <span class="number">0</span>);</span>
    <span class="attribute">background-size</span><span class="value">: <span class="number">2</span>*<span class="variable">$size</span> <span class="number">2</span>*<span class="variable">$size</span>;</span>
    <span class="attribute">background-position</span><span class="value">: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span> <span class="variable">$size</span>;</span>
}
<span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> checkerboard</span>(<span class="number">16px</span>,<span class="hexcolor">#eee</span>,<span class="function">rgba</span>(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>));</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="条纹背景">条纹背景</h1><p>通常条纹背景是由一个图片来代替，或者使用SVG。能不能利用CSS直接创建条纹图案呢，答案是肯定的。<br>假设背景是垂直线性渐变。比如：<code>background:linear-gradient(#fb3,#58a);</code><br>效果是这个样子的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-1.jpg" alt=""><br>如果让渐变区域变的更窄，产生一个无限小的渐变区域，比如：<code>background:linear-gradient(#fb3 50%,#58a 50%);</code> 就可以得到想要的结果了。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-2.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之伪随机背景&图像边框]]></title>
    <link href="http://blog.supce.com/2016/09/16/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%AA%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF&%E5%9B%BE%E5%83%8F%E8%BE%B9%E6%A1%86/"/>
    <id>http://blog.supce.com/2016/09/16/CSS Secret 读书笔记之伪随机背景&图像边框/</id>
    <published>2016-09-15T16:00:00.000Z</published>
    <updated>2016-09-16T13:34:24.303Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="伪随机背景">伪随机背景</h1><p>伪随机背景其实还是对条纹背景的扩展。假设一种场景，我们想得到不同颜色和不同宽度的垂直条纹。并且在背景平铺时不会产生接缝。利用<code>linear-gradient</code>好像可以轻松实现</p>
<pre><code>&lt;div class="rb-a"&gt;&lt;/div&gt;
body{
    display: flex<span class="comment">;</span>
    flex-flow: row wrap<span class="comment">;</span>
    justify-content: space-around<span class="comment">;</span>
}
div{
    margin: 20px 20px<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    min-width: 20em<span class="comment">;</span>
    min-height: 6em<span class="comment">;</span>
}
.rb-a{
    background: linear-gradient(90deg,#fb3 15%,#655 0,#655 40%,#ab4 0,#ab4 65%,hsl(20,40%,90%) 0)<span class="comment">;</span>
    background-size: 80px 100%<span class="comment">;</span>
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-1.jpg" alt=""><br>从效果图中可以看出这个背景图的重复规律非常明显，每水平80px就会重复一次。<br>这时候可以考虑另一种思路：<br>把这组条纹从一个平面图拆散为多个图层，一种颜色作为底色，另外三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺，同时利用<code>background-size</code>控制条纹的间距。</p>
<pre><code>background: hsl(<span class="number">20</span>,<span class="number">40</span>%,<span class="number">90</span>%);
background-image: linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#fb3 <span class="number">10</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#ab4 <span class="number">20</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#<span class="number">655</span> <span class="number">20</span>px,transparent <span class="number">0</span>);</span>
background-size: <span class="number">80</span>px <span class="number">100</span>%,<span class="number">60</span>px <span class="number">100</span>%,<span class="number">40</span>px <span class="number">100</span>%;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-2.jpg" alt=""><br>随机的效果好了很多，但是仔细观察会发现每隔240px像素就会重复一次，且240正好是40 60 80 的最小公倍数。<br>如果我们将背景的宽度设置为质数，那么它们的最小公倍数就会很大，当大于屏幕宽度时就可以在视觉上满足随机背景了。于是将背景的宽度修改一下</p>
<pre><code>background: hsl(<span class="number">20</span>,<span class="number">40</span>%,<span class="number">90</span>%);
background-image: linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#fb3 <span class="number">11</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#ab4 <span class="number">23</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#<span class="number">655</span> <span class="number">41</span>px,transparent <span class="number">0</span>);</span>
background-size: <span class="number">41</span>px <span class="number">100</span>%,<span class="number">61</span>px <span class="number">100</span>%,<span class="number">83</span>px <span class="number">100</span>%;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-3.jpg" alt=""><br>这时候的最小公倍数为41<em>61</em>83=207583，已经可以满足我们的需求了。</p>
<hr>
<h1 id="图像边框">图像边框</h1><p>图片经常作为容器的背景，但是有时候想把一副图片作为边框。也就是说一张图片被剪裁到边框所在的方形环状区域。同时，也希望图片能够随着元素的大小进行缩放并完整的覆盖边框的区域。<br>但是<code>border-image</code>是一种九宫格伸缩法，将图片裁剪为九块，放到边框所对应的变和角，显然是不符合我们的要求的。<br>可以尝试设置元素的背景色为白色，然后给元素外部嵌套一个父元素，并设置背景为图片。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"border-test"</span>&gt;
    &lt;<span class="keyword">div</span>&gt;this <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a test
    this <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
.border-test{
    background: url(stone-art.jpg);
    background-size: cover;
    padding: <span class="number">.5</span>em;
}
.border-test &gt; <span class="keyword">div</span>{
    background: white;
    padding: <span class="number">1</span>em;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-4.jpg" alt=""><br>在强迫症的作用下，并不想嵌套一个父元素，就得换一个思路了。<br>首先设置元素的背景为图片，然后在背景图之上叠加一层纯色的实色背景。设置背景边框为透明，并且为两层背景指定不同的<code>background-clip</code>的值。由于只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的CSS渐变来模拟出纯白色背景的效果。</p>
<pre><code>&lt;div class=<span class="string">"border-a"</span>&gt;<span class="keyword">this</span> is a testthis is a testthis is a testthis is a testthis is a testthis is a testthis is a test&lt;/div&gt;
.border-a,.border-b{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">20</span>em;
    <span class="built_in">max</span>-<span class="variable">height</span>: <span class="number">10</span>em;
    padding: <span class="number">1</span>em;
    border: <span class="number">1</span>em solid transparent;
}
.border-a{
    <span class="built_in">background</span>: linear-gradient(white,white),
                url(stone-art.jpg);
    <span class="built_in">background</span>-<span class="built_in">size</span>: cover; 
    <span class="built_in">background</span>-clip: padding-<span class="built_in">box</span>,border-<span class="built_in">box</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-5.jpg" alt=""><br><code>background-origin</code> 属性规定 <code>background-position</code> 属性相对于什么位置来定位。其默认值为<code>padding-box</code>，因此边框的图片出现了奇怪的拼接效果。于是添加一条属性：<br><code>background-origin: border-box;</code><br>就可以到达下面这个结果了：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-7.jpg" alt=""></p>
<p>既然可以使用渐变那就可以模拟更多的边框效果了~ 比如下面这种：</p>
<pre><code>background: linear-gradient(white,white) padding-box,
                repeating-linear-gradient(-<span class="number">45</span>deg,red <span class="number">0</span>,red <span class="number">12.5</span>%,transparent <span class="number">0</span>,transparent <span class="number">25</span>%,<span class="preprocessor">#<span class="number">58</span>a <span class="number">0</span>,</span>
                    <span class="preprocessor">#<span class="number">58</span>a <span class="number">37.5</span>%,transparent <span class="number">0</span>,transparent <span class="number">50</span>%) <span class="number">0</span> <span class="number">0</span> / <span class="number">4</span>em <span class="number">4</span>em;</span>
</code></pre><p>一种漂亮的信封效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-8.jpg" alt=""></p>
<p>当然，也可以给边框添加动画。</p>
<pre><code><span class="at_rule">@<span class="keyword">keyframes</span> ants </span>{<span class="tag">to</span> <span class="rules">{<span class="rule"><span class="attribute">background-position</span>:<span class="value"> <span class="number">100%</span>}}
.border-c{
    border: <span class="number">1px</span> solid transparent</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(white,white) padding-box,
                <span class="function">repeating-linear-gradient</span>(-<span class="number">45deg</span>,black <span class="number">0</span>,black <span class="number">25%</span>,white <span class="number">0</span>,white <span class="number">50%</span>) <span class="number">0</span> <span class="number">0</span> / .<span class="number">6em</span> .<span class="number">6em</span></span></span>;
    <span class="rule"><span class="attribute">animation</span>:<span class="value"> ants <span class="number">12s</span> ease-out infinite</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-9.jpg" alt=""><br>可惜图片看不出动画效果了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="伪随机背景">伪随机背景</h1><p>伪随机背景其实还是对条纹背景的扩展。假设一种场景，我们想得到不同颜色和不同宽度的垂直条纹。并且在背景平铺时不会产生接缝。利用<code>linear-gradient</code>好像可以轻松实现</p>
<pre><code>&lt;div class="rb-a"&gt;&lt;/div&gt;
body{
    display: flex<span class="comment">;</span>
    flex-flow: row wrap<span class="comment">;</span>
    justify-content: space-around<span class="comment">;</span>
}
div{
    margin: 20px 20px<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    min-width: 20em<span class="comment">;</span>
    min-height: 6em<span class="comment">;</span>
}
.rb-a{
    background: linear-gradient(90deg,#fb3 15%,#655 0,#655 40%,#ab4 0,#ab4 65%,hsl(20,40%,90%) 0)<span class="comment">;</span>
    background-size: 80px 100%<span class="comment">;</span>
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret读书笔记之灵活定位&边框内圆角]]></title>
    <link href="http://blog.supce.com/2016/09/14/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D&%E8%BE%B9%E6%A1%86%E5%86%85%E5%9C%86%E8%A7%92/"/>
    <id>http://blog.supce.com/2016/09/14/CSS Secret 读书笔记之灵活定位&边框内圆角/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2016-09-14T12:27:01.556Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="灵活的背景定位">灵活的背景定位</h1><p>假设一种场景，需要对容器某个角对背景图片做偏移定位，比如说右下角。在定位的同时，也希望图片和容易边角之间能够够留出一定的空隙，以避免下图这种效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-1.jpg" alt=""><br>当容器的尺寸固定时，很好解决。但是容器的尺寸不固定时，可以利用下面三种方法来解决。<br><a id="more"></a></p>
<h2 id="background-position的扩展语法方案"><code>background-position</code>的扩展语法方案</h2><p>在CSS3中，<code>background-position</code>已经得到扩展，它允许我们指定背景图片距离任意角的偏移量。</p>
<blockquote>
<p>当然，还需要一个合适的回退方案。避免浏览器的不支持。</p>
</blockquote>
<p>代码：</p>
<pre><code>&lt;div class=<span class="string">"position"</span>&gt;
    Code Pirate
&lt;/div&gt;
.position{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">10</span>px;
    <span class="built_in">color</span>: white;
    font: <span class="number">100</span>%/<span class="number">1</span> sans-serif;
    <span class="built_in">background</span>:url(http:<span class="comment">//csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;   /*回退方案*/</span>
}
.position{
    <span class="built_in">background</span>-position: right <span class="number">10</span>% bottom <span class="number">20</span>%;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-2.jpg" alt=""></p>
<h2 id="background-origin方案"><code>background-origin</code>方案</h2><p>在上个方案中有一个缺陷，当修改容器的内边距时，需要在3处做出修改。希望有一种方式，能够让背景图片自动根据设定的内边距定位，而不用声明额外的偏移量。<br>在默认情况下<code>background-position</code>是以padding box为基准的。可以利用属性<code>background-origin</code>来改变这种行为。当把它的值设置为<code>content-box</code>时，<code>background-position</code>会以内容区边缘作为基准。此时，背景图片的距离的边角偏移量就可以和内边距保持一致了。<br>代码：</p>
<pre><code>&lt;div class=<span class="string">"origin"</span>&gt;
    Code Pirate
&lt;/div&gt;
.origin{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">10</span>px;
    <span class="built_in">color</span>: white;
    font: <span class="number">100</span>%/<span class="number">1</span> sans-serif;
    <span class="built_in">background</span>:url(http:<span class="comment">//csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;</span>
}
.origin{
    <span class="built_in">background</span>-origin: content-<span class="built_in">box</span>;
 }
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-3.jpg" alt=""></p>
<h2 id="calc()方案"><code>calc()</code>方案</h2><p>如果想把背景图片定位到距离底边10px 距离右边20px。可以使用<code>calc()</code><br>即：<code>background-position: calc(100% - 20px) calc(100% - 10px);</code>也可以达到同样的效果。</p>
<blockquote>
<p>注意：在calc()函数内部的- + 运算符两侧需要加一个空格符，否则会产生解析错误。</p>
</blockquote>
<hr>
<h1 id="边框内圆角">边框内圆角</h1><p>考虑一种场景，需要一个容器，只在内侧有圆角，而<code>border</code>或者<code>outline</code>仍然是直角，可以用下面两种方式实现。</p>
<h2 id="嵌套容器">嵌套容器</h2><p>这个方式很简单，直接在原容器外侧嵌套一个容器，设置内部容器有圆角即可<br>代码：</p>
<pre><code>&lt;div class=<span class="string">"radius"</span>&gt;
    &lt;div&gt;
        <span class="keyword">this</span> is a test
    &lt;/div&gt;
&lt;/div&gt;
.radius{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">.8</span>em;
    <span class="built_in">background</span>: #<span class="number">655</span>;
}
.radius &gt; div{
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">3.4</span>em;
    <span class="built_in">background</span>: <span class="built_in">tan</span>;
    border-radius: <span class="number">.8</span>em;
    padding: <span class="number">1</span>em;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-5.jpg" alt=""></p>
<h2 id="box-shadow填充"><code>box-shadow</code>填充</h2><p>有时候，可能稍微有些强迫症，不想破坏原有的HTML结构。可以使用<code>box-shadow</code>进行颜色填充。<br>之前已经知道，<code>outline</code>并不会沿着元素的圆角走。可以在元素外侧设置<code>outline</code><br>代码如下：</p>
<pre><code>&lt;div class=<span class="string">"shadow_outline"</span>&gt;
    <span class="keyword">this</span> is a test
&lt;/div&gt;
.shadow_outline{
        <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
        <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
        margin: <span class="number">20</span>px auto;
        padding: <span class="number">.8</span>em;
        <span class="built_in">background</span>: <span class="built_in">tan</span>;
        border-radius: <span class="number">.8</span>em;
        outline: <span class="number">.6</span>em solid #<span class="number">655</span>;
    }
</code></pre><p>此时的效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-07.jpg" alt=""><br>会发现在四个角会有空白，这个空白可以利用<code>box-shadow</code>进行颜色填充。由几何数学可知，当圆角的半径为r时，<code>box-shadow</code>的投影扩张值不能小于(√2-1)r。上面的<code>border-radius</code>为0.8，计算得约为0.33，<br>因此只要设置<code>box-shadow: 0 0 0 .34em #655;</code>即可。<br>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-6.jpg" alt=""></p>
<blockquote>
<p>最后说句题外话，Chrome v53.0.2785.113m版本的界面挺好看，没错，我就是扁平脑残粉。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="灵活的背景定位">灵活的背景定位</h1><p>假设一种场景，需要对容器某个角对背景图片做偏移定位，比如说右下角。在定位的同时，也希望图片和容易边角之间能够够留出一定的空隙，以避免下图这种效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-1.jpg" alt=""><br>当容器的尺寸固定时，很好解决。但是容器的尺寸不固定时，可以利用下面三种方法来解决。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之半透明与多重边框]]></title>
    <link href="http://blog.supce.com/2016/09/13/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%8A%E9%80%8F%E6%98%8E%E4%B8%8E%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86/"/>
    <id>http://blog.supce.com/2016/09/13/CSS Secret 读书笔记之半透明与多重边框/</id>
    <published>2016-09-12T16:00:00.000Z</published>
    <updated>2016-09-13T13:04:59.411Z</updated>
    <content type="html"><![CDATA[<h1 id="半透明边框">半透明边框</h1><p>由于背景色会侵入到边框所在的范围，如果想要半透明的边框，可以使用<code>background-clip</code>属性。这个属性规定背景的绘制区域，其初始值为<code>border-box</code>，如果将属性值设置为<code>padding-box</code>，背景就会被裁剪到内边距框。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;
        this <span class="keyword">is</span> a test
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><a id="more"></a>
<p>CSS代码：</p>
<pre><code><span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
<span class="class">.test</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">50px</span> auto</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">10px</span> solid <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">5</span>)</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran1.jpg" alt=""></p>
<h1 id="多重边框">多重边框</h1><p>想要使用多重边框，但是又不想添加无用的额外元素破坏HTML结构。可以使用<code>box-shadow</code>或者<code>outline</code>来模拟多重边框。</p>
<h2 id="box-shadow方案"><code>box-shadow</code>方案</h2><p>想要模拟多重边框，可以利用<code>box-shadow</code>的第四个参数，用来设置阴影的尺寸。一个正值的阴影加上两个为零的偏移量以及为零的模糊值，得到的效果就像一道实线的边框。</p>
<blockquote>
<p>恰巧，box-shadow支持都好分隔语法，可以创建任意数量的阴影。</p>
</blockquote>
<p>于是可以模拟出多重边框。例如：<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box-shadow-test"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code>.box-shadow-test{
    margin: <span class="number">50</span>px <span class="keyword">auto</span>;
    padding: <span class="number">0</span>;
    width: <span class="number">50</span>px;
    height: <span class="number">50</span>px;
}
.box-shadow-test{
    background: <span class="preprocessor">#<span class="number">6</span>b0;</span>
    box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px <span class="preprocessor">#<span class="number">655</span>,</span>
    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px deeppink,
    <span class="number">0</span>px <span class="number">2</span>px <span class="number">5</span>px <span class="number">15</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.6</span>)</span></span>;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran2.jpg" alt=""></p>
<h2 id="outline方案"><code>outline</code>方案</h2><p><code>box-shadow</code>虽然可以模拟边框，但是有一个缺陷，就是只能模拟实线边框，不能模拟出虚线边框。而且，可以设置<code>outline-offset</code>属性来控制它和元素边缘之间的间距，如果设置成负值可以模拟出缝边效果。比如：<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"outline-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.outline-a</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">50px</span> auto</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> yellowgreen</span></span>;
        <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">10px</span> solid <span class="hexcolor">#655</span></span></span>;
        <span class="rule"><span class="attribute">outline</span>:<span class="value"> <span class="number">1px</span> dashed deeppink</span></span>;
        <span class="rule"><span class="attribute">outline-offset</span>:<span class="value"> -<span class="number">5px</span></span></span>;
        <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">5px</span></span></span>;
    }</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran3.jpg" alt=""></p>
<blockquote>
<p>可以看出来，使用outline方案，适用于两层边框的场景。如果需要更多的边框，只能使用box-shadow方案了。</p>
</blockquote>
<p><code>outline</code>还有一个缺陷，<code>outline</code>模拟的边框并不能贴合<code>border-radius</code>产生圆角。比如：</p>
<p>代码：</p>
<pre><code>&lt;div class="outline-b"&gt;&lt;/div&gt;
.outline-b{
    margin: 50px auto<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    width: 50px<span class="comment">;</span>
    height: 50px<span class="comment">;</span>
    background: yellowgreen<span class="comment">;</span>
    border: 10px solid #655<span class="comment">;</span>
    outline: 5px solid deeppink<span class="comment">;</span>
    border-radius: 5px<span class="comment">;</span>
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran4.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="半透明边框">半透明边框</h1><p>由于背景色会侵入到边框所在的范围，如果想要半透明的边框，可以使用<code>background-clip</code>属性。这个属性规定背景的绘制区域，其初始值为<code>border-box</code>，如果将属性值设置为<code>padding-box</code>，背景就会被裁剪到内边距框。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;
        this <span class="keyword">is</span> a test
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之弹性布局]]></title>
    <link href="http://blog.supce.com/2016/09/12/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.supce.com/2016/09/12/CSS Secret 读书笔记之弹性布局/</id>
    <published>2016-09-11T16:00:00.000Z</published>
    <updated>2016-09-12T13:12:20.547Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在CSS Secret中提到了弹性布局，这里就简单写了四个实例来回顾下弹性布局</p>
</blockquote>
<h1 id="居中">居中</h1><p>可以利用<code>flex</code>，让子容器在父容器中居中。设置父容器<code>display</code>属性为<code>flex</code>，并设置子容器<code>margin</code>属性为<code>auto</code>即可。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child"</span>&gt;
            child
        &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.parent</span>,<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
}</span>
<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
</code></pre><a id="more"></a>
<p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex0.jpg" alt=""></p>
<h1 id="自适应列表">自适应列表</h1><p>有一组列表，有固定的宽度，但是想让它们能够根据浏览器窗口的大小进行自适应调整，可以使用弹性布局。<br>HTML代码：</p>
<pre><code>&lt;ul <span class="keyword">class</span>=<span class="string">"flex-container"</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;2&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;3&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;4&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;5&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;6&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.flex-container</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
}</span>
<span class="class">.flex-item</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> tomato</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">10px</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex1.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex2.jpg" alt=""></p>
<h1 id="自适应导航">自适应导航</h1><p>为了适应移动端的屏幕尺寸，可以根据屏幕由小到大依次设置为多行居中、单行居中以及单行左(右)对齐。<br>HTML代码：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"navigation"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Details<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>About<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.navigation</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1em</span> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;

    <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> flex-end</span></span>;

}</span>
<span class="class">.navigation</span> <span class="tag">a</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>; 
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="class">.navigation</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover{
    background: tomato</span></span>;
}
<span class="at_rule">@<span class="keyword">media</span> all and (max-width: <span class="number">800px</span>)</span>{
    <span class="class">.navigation</span><span class="rules">{
        <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
    }</span>
}
<span class="at_rule">@<span class="keyword">media</span> all and (max-width: <span class="number">600px</span>)</span>{
    <span class="class">.navigation</span><span class="rules">{
        <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column wrap</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; 
    }</span>
    <span class="class">.navigation</span> <span class="tag">a</span><span class="rules">{
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">border-top</span>:<span class="value"> <span class="number">1px</span> solid <span class="function">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.3</span>)</span></span>;
        <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>)</span></span>;
    }</span>
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex3.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex4.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex5.jpg" alt=""></p>
<h1 id="自适应布局">自适应布局</h1><p>最后来一个很常用的自适应布局，主要用于适应移动端的屏幕尺寸。整体思路大概是先考虑移动端，设置所有<code>div</code>的宽度为100%；在中等屏幕中设置两个侧边栏在同一行；在宽屏中，设置左侧边栏在主要内容左侧，右侧边栏在主要内容右侧。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"wrapper"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"header"</span>&gt;Header&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;
        &lt;p&gt;this <span class="keyword">is</span> main作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"aside aside-1"</span>&gt;aside-<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"aside aside-2"</span>&gt;aside-<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;footer <span class="type">class</span>=<span class="string">"footer"</span>&gt;this <span class="keyword">is</span> footer&lt;/footer&gt;      
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.header</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> tomato</span></span>;
    }</span>
    <span class="class">.footer</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> lightgreen</span></span>;
    }</span>
    <span class="class">.main</span> <span class="rules">{
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> left</span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    }</span>
    <span class="class">.aside-1</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> gold</span></span>;
    }</span>
    <span class="class">.aside-2</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> hotpink</span></span>;
    }</span>
    <span class="comment">/*移动端*/</span>
    <span class="class">.wrapper</span> &gt; * <span class="rules">{
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span> <span class="number">100%</span></span></span>;
    }</span>
    <span class="comment">/*中等屏幕*/</span>
    <span class="at_rule">@<span class="keyword">media</span> all and (min-width: <span class="number">600px</span>)</span>{
        <span class="class">.aside</span><span class="rules">{
            <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span> auto</span></span>;
        }</span>
    }
    <span class="comment">/*宽屏*/</span>
    <span class="at_rule">@<span class="keyword">media</span> all and (min-width: <span class="number">800px</span>)</span>{
        <span class="class">.main</span> <span class="rules">{<span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">2</span> <span class="number">0</span></span></span>;}</span> <span class="comment">/*扩大比例为2缩小比例为0*/</span>
        <span class="class">.aside-1</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">1</span></span></span>;}</span>
        <span class="class">.main</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">2</span></span></span>;}</span>
        <span class="class">.aside-2</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"><span class="number">3</span></span></span>;}</span>
        <span class="class">.footer</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"><span class="number">4</span></span></span>;}</span>
    }
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex6.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex7.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex8.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在CSS Secret中提到了弹性布局，这里就简单写了四个实例来回顾下弹性布局</p>
</blockquote>
<h1 id="居中">居中</h1><p>可以利用<code>flex</code>，让子容器在父容器中居中。设置父容器<code>display</code>属性为<code>flex</code>，并设置子容器<code>margin</code>属性为<code>auto</code>即可。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child"</span>&gt;
            child
        &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.parent</span>,<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
}</span>
<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM(二)]]></title>
    <link href="http://blog.supce.com/2016/07/26/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%8011/"/>
    <id>http://blog.supce.com/2016/07/26/JavaScript之基础11/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2016-07-28T03:25:22.829Z</updated>
    <content type="html"><![CDATA[<hr>
<blockquote>
<p>这里主要记录下DOM基于CSS选择符和HTML5的一些扩展。</p>
</blockquote>
<h1 id="基于CSS选择符的扩展">基于CSS选择符的扩展</h1><p>有时候需要通过 CSS 选择符查询 DOM 文档取得元素的引用，可以使用以下两种方法：</p>
<ul>
<li><p><code>querySelector()</code></p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>this is header<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer"</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"#header"</span>).firstChild.nodeValue);
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"this is a paragraph."</span>);
<span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).appendChild(text);
<span class="comment">//获取类为footer的第一个元素</span>
<span class="built_in">document</span>.body.querySelector(<span class="string">".footer"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre></li>
</ul>
<a id="more"></a>
<p><code>querySelector()</code>方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p>
<ul>
<li><p><code>querySelectorAll()</code></p>
<pre><code><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName("em"))</span>
<span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).<span class="built_in">querySelectorAll</span>(<span class="string">"em"</span>);
</code></pre></li>
</ul>
<p><code>querySelectorAll()</code>方法接收的参数与<code>querySelector()</code>方法一样，都是一个CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList的实例。如果没有找到匹配的元素，NodeList就是空的。</p>
<p><em>要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号语法</em></p>
<ul>
<li><p><code>matchesSelector()</code><br>这个方法接收参数为CSS选择符，如果调用元素与该选择符匹配，返回true，否则，返回false。<br>为了兼容其他浏览器，可以这样写：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">matchesSelector</span><span class="params">(element, selector)</span>{</span>
    <span class="keyword">if</span><span class="params">(element.matches)</span>{
        return element.matches<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.matchesSelector)</span>{
        return element.matchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.webkitMatchesSelector)</span>{
        return element.webkitMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.msMatchesSelector)</span>{
        return element.msMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.mozMatchesSelector)</span>{
        return element.mozMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.oMatchesSelector)</span>{
        return element.oMatchesSelector<span class="params">(selector)</span>;
    }
}
</code></pre></li>
</ul>
<p>这个方法在做事件委托时可以用到，比如：</p>
<pre><code><span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>).addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{
    <span class="keyword">if</span>(matchesSelector(e.target,<span class="string">'a.btn'</span>)){
        alert(<span class="string">"do someting"</span>);
        <span class="built_in">console</span>.log(<span class="string">"do something"</span>);
        e.preventDefault();
        <span class="comment">//TODO something</span>
    }
    <span class="keyword">else</span>{
        alert(<span class="string">"..."</span>);
    }
},<span class="literal">false</span>);
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"wrap"</span>&gt;
    &lt;a <span class="type">class</span>=<span class="string">"btn"</span> href=<span class="string">"http://blog.supce.com"</span>&gt;点我&lt;/a&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><hr>
<h1 id="元素的遍历">元素的遍历</h1><p>对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。之前写过一个删除空白文本节点的函数。为了解决元素访问的一致性问题，DOM也提供了一种方法：</p>
<ul>
<li>childElementCount 返回不包括文本节点和注释的元素个数</li>
<li>firstElementChild 返回第一个子元素</li>
<li>lastElementChild 返回最后一个子元素</li>
<li>previousElementSibling 返回前一个同辈元素</li>
<li>nextElementSibling 返回后一个同辈元素</li>
</ul>
<p>利用这些属性可以更方便的忽视空白元素进行元素的相关操作了。</p>
<hr>
<h1 id="基于HTML5的扩展">基于HTML5的扩展</h1><p><em>HTML5对DOM节点的相关操作进行了扩展</em></p>
<h2 id="与类相关的扩展">与类相关的扩展</h2><p>为了更方便的利用JavaScript操作CSS类，比如动态修改类或者获取给定类的引用，HTML增加了一些API。</p>
<h3 id="getElementsByClassName方法"><code>getElementsByClassName</code>方法</h3><p><code>getElementsByClassName()</code>方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。比如：</p>
<pre><code><span class="keyword">var</span> test_class = document.getElementsByClassName('test');
console.log(test_class); //[<span class="keyword">div</span>.test, <span class="keyword">div</span>.test.demo]
<span class="literal">result</span> = document.getElementsByClassName('test demo');
console.log(<span class="literal">result</span>); //[<span class="keyword">div</span>.test.demo]
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"demo"</span>&gt;this <span class="keyword">is</span> a demo&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test demo"</span>&gt;this <span class="keyword">is</span> a test <span class="keyword">and</span> demo&lt;/<span class="keyword">div</span>&gt;
</code></pre><h3 id="classList属性"><code>classList</code>属性</h3><p>上面的方法可以根据类名获取元素的引用，而利用<code>classList</code>属性可以对类名进行增删与替换，该属性包含以下几种方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>classList.remove()</td>
<td>删除元素中某个类名</td>
</tr>
<tr>
<td>classList.add()</td>
<td>在元素中添加某个类名</td>
</tr>
<tr>
<td>classList.toggle()</td>
<td>如果类名列表中已经存在给定的值，删除它；如果没有给定的值，添加它。</td>
</tr>
<tr>
<td>classList.contains()</td>
<td>表示类名列表中是否存在给定的值，如果存在则返回 true ，否则返回 false</td>
</tr>
</tbody>
</table>
<p>举个改变div背景色的例子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
    test.classList.toggle(<span class="string">'red'</span>);
    <span class="built_in">console</span>.log(<span class="string">"done"</span>);
}
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="tag">div</span> id=<span class="string">"test"</span> class=<span class="string">"red"</span>&gt;this is <span class="tag">a</span> test&lt;/div&gt;
&lt;<span class="tag">button</span> id=<span class="string">"btn"</span> onclick=<span class="string">"changeColor()"</span>&gt;change <span class="attribute">color</span>&lt;/button&gt;
</code></pre><p>CSS代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
    <span class="id">#test</span><span class="rules">{
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
        <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
        <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
    }</span>
    <span class="class">.red</span><span class="rules">{
        <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red <span class="important">!important</span></span></span>;
    }</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre><p>考虑到兼容性问题，可以封装一个函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">classOperate</span><span class="params">(div,name,operate)</span></span>{
    <span class="keyword">var</span> <span class="keyword">list</span> = div.classList;
    <span class="keyword">if</span>(<span class="keyword">list</span>){
        <span class="keyword">switch</span>(operate){
            <span class="keyword">case</span> <span class="string">'add'</span>:
                <span class="keyword">list</span>.add(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'remove'</span>:
                <span class="keyword">list</span>.remove(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'contains'</span>:
                <span class="keyword">return</span> <span class="keyword">list</span>.contains(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'toggle'</span>:
                <span class="keyword">list</span>.toggle(name);
                <span class="keyword">break</span>;
        }
    }<span class="keyword">else</span>{
        <span class="keyword">switch</span>(operate){
            <span class="keyword">case</span> <span class="string">'add'</span>:
                addName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'remove'</span>:
                removeName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'contains'</span>:
                containName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'toggle'</span>:
                <span class="keyword">if</span>(containName(name)){
                    removeName(name);
                }<span class="keyword">else</span>{
                    addName(name);
                }
                <span class="keyword">break</span>;
        }
    }
    <span class="function"><span class="keyword">function</span> <span class="title">addName</span><span class="params">(name)</span></span>{
        div.className += (<span class="string">' '</span> + name);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">removeName</span><span class="params">(name)</span></span>{
        <span class="keyword">var</span> classNames = div.className.split(/\s+/);
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;classNames.length;i++){
            <span class="keyword">if</span>(classNames[i] == name){
                <span class="keyword">break</span>;
            }
        }
        classNames.splice(i,<span class="number">1</span>);
        div.className = classNames.join(<span class="string">' '</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">containName</span><span class="params">(name)</span></span>{
        <span class="keyword">var</span> classNames = div.className.split(/\s+/);
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;classNames.length;i++){
            <span class="keyword">if</span>(classNames[i] == name){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre><h2 id="焦点管理">焦点管理</h2><p>HTML5增加了辅助管理DOM焦点的功能。</p>
<ul>
<li><p><code>document.activeElement</code>属性<br>这个属性会引用DOM中当前获得了焦点的元素。比如：</p>
<pre><code><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);
btn.focus();
<span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === btn);<span class="comment">//true</span>
</code></pre></li>
</ul>
<blockquote>
<p>默认情况下,文档刚刚加载完成时，<code>document.activeElement</code> 中保存的是 <code>document.body</code> 元素的引用。文档加载期间，<code>document.activeElement</code>的值为 null 。</p>
</blockquote>
<ul>
<li><code>document.hasFocus()</code>方法</li>
</ul>
<p>这个方法用于确定文档是否获得了焦点。比如：</p>
<pre><code><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);
btn.focus();
<span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus());<span class="comment">//true</span>
</code></pre><h2 id="HTMLDocument的变化">HTMLDocument的变化</h2><p>HTML5 同时也扩展了 HTMLDocument ，增加了一些新的功能</p>
<h3 id="readyState属性"><code>readyState</code>属性</h3><p>Document 的 readyState 属性有两个可能的值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>loading</td>
<td>正在加载文档</td>
</tr>
<tr>
<td>complete</td>
<td>已经加载完文档</td>
</tr>
</tbody>
</table>
<p>一般会这样使用：</p>
<pre><code><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>){
    <span class="regexp">//</span><span class="keyword">do</span> something
}
</code></pre><h3 id="兼容模式">兼容模式</h3><p>自从IE6开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能。为此给 document 添加了一个名为 compatMode的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下，document.compatMode 的值等于 “BackCompat” 。</p>
<pre><code><span class="keyword">if</span><span class="params">(document.compatMode == <span class="string">"CSS1Compat"</span>)</span>{
    alert<span class="params">(<span class="string">"Standards mode"</span>)</span>;
}<span class="keyword">else</span>{
    alert<span class="params">(<span class="string">"Quirks mode"</span>)</span>;
}
</code></pre><h3 id="head属性"><code>head</code>属性</h3><p>HTML5 新增了 document.head 属性</p>
<pre><code><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];
</code></pre><h2 id="字符集属性">字符集属性</h2><p>HTML5 新增了几个与文档字符集有关的属性</p>
<ul>
<li><code>charset</code>属性</li>
</ul>
<p>charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。</p>
<ul>
<li><code>defaultCharset</code>属性</li>
</ul>
<p>该属性表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。</p>
<blockquote>
<p>如果文档没有使用默认字符集,charset和defaultCharset属性的值可能会不一样</p>
</blockquote>
<h2 id="自定义数据属性">自定义数据属性</h2><p>HTML5规定可以为元素添加非标准的属性，但要添加前缀 <code>data-</code>，比如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"test"</span> data-myname=<span class="string">"demo"</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>同时可以获取或者设置自定义数据的值</p>
<pre><code><span class="keyword">var</span> <span class="keyword">test</span> = document.getElementById('<span class="keyword">test</span>');
console.<span class="literal">log</span>(<span class="keyword">test</span>.dataset.myname);<span class="comment">//demo</span>
<span class="keyword">test</span>.dataset.myname = <span class="string">"newName"</span>;
console.<span class="literal">log</span>(<span class="keyword">test</span>.dataset.myname);<span class="comment">//newName</span>
</code></pre><h2 id="插入标记">插入标记</h2><p>有时候可能需要向文档中插入大量新的HTML标记，如果使用DOM创建一系列节点，并按正确顺序连接起来还是比较麻烦的。而使用下面几个属性和方法可以更简单，迅速的将标记插入到文本中。</p>
<h3 id="innerHTML属性">innerHTML属性</h3><p>在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.innerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom3.jpg-blogImg" alt=""><br>在写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。如果设置的值仅是文本而没有 HTML标签，那么结果就是设置纯文本。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.innerHTML);
test.innerHTML = <span class="string">"Hello &amp; welcome &lt;br /&gt; this is a test!"</span>;
<span class="built_in">console</span>.log(test.innerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom4.jpg-blogImg" alt=""></p>
<h3 id="outerHTML属性">outerHTML属性</h3><p>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.outerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom5.jpg-blogImg" alt=""><br>在写模式下， outerHTML会根据指定的 HTML 字符串创建新的 DOM子树，然后用这个 DOM 子树完全替换调用元素。比如：<br>使用 outerHTML 属性以下面这种方式设置值：<br><code>div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;;</code><br>这行代码完成的操作与下面这些 DOM 脚本代码一样：</p>
<pre><code>var p = document.createElement<span class="params">(<span class="string">"p"</span>)</span>;
p.appendChild<span class="params">(document.createTextNode<span class="params">(<span class="string">"This is a paragraph."</span>)</span>)</span>;
div.parentNode.replaceChild<span class="params">(p, div)</span>;
</code></pre><p>结果，就是新创建的<code>&lt;p&gt;</code>元素会取代DOM树中的<code>&lt;div&gt;</code>元素。</p>
<h3 id="insertAdjacentHTML()方法">insertAdjacentHTML()方法</h3><p>该接收两个参数：插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforebegin</td>
<td>在当前元素之前插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td>afterbegin</td>
<td>在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素</td>
</tr>
<tr>
<td>beforeend</td>
<td>在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素</td>
</tr>
<tr>
<td>afterend</td>
<td>在当前元素之后插入一个紧邻的同辈元素</td>
</tr>
</tbody>
</table>
<p><em>注意，这些值都必须是小写形式</em></p>
<p>第二个参数是一个HTML字符串，如果浏览器无法解析该字符串，就会抛出错误。比如：</p>
<pre><code><span class="comment">//作为前一个同辈元素插入</span>
element.insertAdjacentHTML<span class="params">(<span class="string">"beforebegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>)</span>;
</code></pre><h2 id="scrollIntoView方法"><code>scrollIntoView</code>方法</h2><p>scrollIntoView()方法，通过滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果参数为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。<br>可以写一个导航栏固定，点击导航栏滚动到相应<code>div</code>的小例子：</p>
<p>HTML代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"nav"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"floatFix"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"red"</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>第三部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"first_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"sec_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"third_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第三部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>CSS代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
*<span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
}</span>
<span class="id">#header</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;        
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgb</span>(<span class="number">83</span>,<span class="number">83</span>,<span class="number">83</span>)</span></span>;
}</span>
<span class="id">#nav</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto auto</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">60%</span></span></span>;
}</span>
<span class="id">#nav</span> <span class="tag">ul</span><span class="rules">{
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;
}</span>
<span class="id">#nav</span> <span class="tag">li</span><span class="rules">{
    <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">30%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="rule"><span class="attribute">.floatFix</span>:<span class="value">after{
    clear: both</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;
    ;<span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">0</span></span></span>;
}
<span class="class">.section</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="id">#first_section</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;
}</span>
<span class="id">#sec_section</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
}</span>
<span class="id">#third_section</span><span class="rules">{
<span class="rule"><span class="attribute">background-color</span>:<span class="value"> yellow</span></span>;
}</span>
<span class="class">.red</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;
}</span>
<span class="class">.green</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
}</span>
<span class="class">.yellow</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> yellow</span></span>;
}</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre><p>JavaScript代码：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>{
        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
    }
    <span class="keyword">var</span> client_height = screen.availHeight;
    <span class="keyword">var</span> array = [$(<span class="string">'first_section'</span>),$(<span class="string">'sec_section'</span>),$(<span class="string">'third_section'</span>)];
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){
        <span class="built_in">console</span>.log(array[i]);
        array[i].style.height = (client_height - <span class="number">50</span>) + <span class="string">"px"</span>;
        array[i].style.lineHeight = (client_height - <span class="number">50</span>) + <span class="string">"px"</span>;
    }
    <span class="keyword">var</span> li = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);
    li[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">"red"</span>;
        li[<span class="number">1</span>].className = <span class="string">" "</span>;
        li[<span class="number">2</span>].className = <span class="string">" "</span>;
        $(<span class="string">'first_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
    li[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">" "</span>;
        li[<span class="number">1</span>].className = <span class="string">"green"</span>;
        li[<span class="number">2</span>].className = <span class="string">" "</span>;
        $(<span class="string">'sec_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
    li[<span class="number">2</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">" "</span>;
        li[<span class="number">1</span>].className = <span class="string">" "</span>;
        li[<span class="number">2</span>].className = <span class="string">"yellow"</span>;
        $(<span class="string">'third_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom6.jpg-blogImg" alt=""></p>
<blockquote>
<p>文章导图</p>
</blockquote>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/DOM2.png-blogImg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<blockquote>
<p>这里主要记录下DOM基于CSS选择符和HTML5的一些扩展。</p>
</blockquote>
<h1 id="基于CSS选择符的扩展">基于CSS选择符的扩展</h1><p>有时候需要通过 CSS 选择符查询 DOM 文档取得元素的引用，可以使用以下两种方法：</p>
<ul>
<li><p><code>querySelector()</code></p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>this is header<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer"</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"#header"</span>).firstChild.nodeValue);
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"this is a paragraph."</span>);
<span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).appendChild(text);
<span class="comment">//获取类为footer的第一个元素</span>
<span class="built_in">document</span>.body.querySelector(<span class="string">".footer"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre></li>
</ul>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM(一)]]></title>
    <link href="http://blog.supce.com/2016/07/24/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%8010/"/>
    <id>http://blog.supce.com/2016/07/24/JavaScript之基础10/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2016-07-24T12:31:16.805Z</updated>
    <content type="html"><![CDATA[<hr>
<p>DOM是document object model的缩写，即：文档对象模型。DOM将HTML和XML描述为一个具有层次结构的节点树。DOM作为一个接口，可以对HTML或者XML进行添加，删除和修改。<br>根据 DOM，HTML 文档中的每个成分都是一个节点。DOM 是这样规定的： </p>
<ul>
<li>整个文档是一个文档节点 </li>
<li>每个 HTML 标签是一个元素节点 </li>
<li>包含在 HTML 元素中的文本是文本节点 </li>
<li>每一个 HTML 属性是一个属性节点 </li>
<li>注释属于注释节点<a id="more"></a>
</li>
</ul>
<h1 id="节点类型">节点类型</h1><p>JavaScript中总共有12种节点类型，这些节点类型全部继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>节点类型有在Node类型中定义的12个数值常量来表示：</p>
<pre><code>Node<span class="class">.ELEMENT_NODE</span> (<span class="number">1</span>)
Node<span class="class">.ATTRIBUTE_NODE</span> (<span class="number">2</span>)
Node<span class="class">.TEXT_NODE</span> (<span class="number">3</span>)
Node<span class="class">.CDATA_SECTION_NODE</span> (<span class="number">4</span>)
Node<span class="class">.ENTITY_REFERENCE_NODE</span> (<span class="number">5</span>)
Node<span class="class">.ENTITY_NODE</span> (<span class="number">6</span>)
Node<span class="class">.PROCESSING_INSTRUCTION_NODE</span> (<span class="number">7</span>)
Node<span class="class">.COMMENT_NODE</span> (<span class="number">8</span>)
Node<span class="class">.DOCUMENT_NODE</span> (<span class="number">9</span>)
Node<span class="class">.DOCUMENT_TYPE_NODE</span> (<span class="number">10</span>)
Node<span class="class">.DOCUMENT_FRAGMENT_NODE</span> (<span class="number">11</span>)
Node<span class="class">.NOTATION_NODE</span> (<span class="number">12</span>)
</code></pre><h2 id="常用属性">常用属性</h2><h3 id="nodeType属性">nodeType属性</h3><p>每个节点都有一个nodeType属性，可以确定节点的类型。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"test"</span>&gt;<span class="keyword">div</span>&lt;/<span class="keyword">div</span>&gt;
var test = document.getElementById(<span class="string">"test"</span>);
<span class="keyword">if</span>(test.nodeType == <span class="number">1</span>){
    console.<span class="command">log</span>(<span class="string">"This node is an element"</span>);
}
</code></pre><h3 id="nodeName属性">nodeName属性</h3><p>nodeName属性保存的是元素的标签名</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;div&lt;/div&gt;
<span class="keyword">var</span> <span class="keyword">test</span> = document.getElementById(<span class="string">"test"</span>);
<span class="keyword">if</span>(<span class="keyword">test</span>.nodeType == 1){
    console.<span class="literal">log</span>(<span class="keyword">test</span>.nodeName);  <span class="comment">//DIV</span>
}
</code></pre><h2 id="节点关系">节点关系</h2><p>节点的关系类似于家谱。<br>每个节点都有一个childNodes属性来表示子节点，其中保存着一个NodeList对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置或者<code>item()</code>方法来访问这些节点。</p>
<pre><code><span class="variable"><span class="keyword">var</span> firstChild</span> = someNode.childNodes[<span class="number">0</span>];
<span class="variable"><span class="keyword">var</span> secondChild</span> = someNode.childNodes.item(<span class="number">2</span>);
<span class="variable"><span class="keyword">var</span> length</span> = someNode.childNodes.length;
</code></pre><p><em>请注意，虽然可以通过方括号语法来访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。可以通过一个函数把它转换为数组</em></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">convert2Array</span><span class="params">(nodes)</span></span>{
    <span class="keyword">try</span>{
        <span class="keyword">return</span> <span class="keyword">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);
    }<span class="keyword">catch</span>(ex){
        <span class="keyword">var</span> <span class="keyword">array</span> = [];
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++){
            <span class="keyword">array</span>[i] = nodes[i];
        }
        <span class="keyword">return</span> <span class="keyword">array</span>;
    }
}
console.log(convert2Array({length:<span class="number">2</span>,<span class="number">0</span>:<span class="string">'first'</span>,<span class="number">1</span>:<span class="string">'second'</span>})); <span class="comment">//["first", "second"]</span>
</code></pre><p>还有一些其他关系</p>
<ul>
<li>parentNode 父节点</li>
<li>previousSibling 该节点的前一个兄弟节点</li>
<li>nextSibling 该节点的后一个兄弟节点</li>
</ul>
<h2 id="节点操作">节点操作</h2><h3 id="appendChild()">appendChild()</h3><p>该方法用于向childNodes列表末尾添加一个节点。返回值为新增的节点。比如：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = document.createElement(<span class="string">"li"</span>);
item.appendChild(document.createTextNode(<span class="string">"itme3"</span>));
<span class="keyword">list</span>.appendChild(item);   <span class="comment">//向ul中添加了一个li</span>
</code></pre><p>如果传入到 appendChild() 中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。比如将item1与item2互换：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = <span class="keyword">list</span>.childNodes[1];  <span class="comment">//0为空白文本节点</span>
<span class="keyword">list</span>.appendChild(item);
</code></pre><p>有时候，空白文本几点会影响操作，可以写一个函数把空白文本节点删除。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">cleanWhitespace</span><span class="params">(element)</span>{</span>   
    <span class="keyword">for</span><span class="params">(var i=<span class="number">0</span>; i&lt;element.childNodes.length; i++)</span>   
    {   
        var node = element.childNodes[i];   
        <span class="keyword">if</span><span class="params">(node.nodeType == <span class="number">3</span> &amp;&amp; !/\S/.test<span class="params">(node.nodeValue)</span>)</span>   
        {   
            node.parentNode.removeChild<span class="params">(node)</span>;   
        }   
    }   
} 
</code></pre><h3 id="insertBefore()">insertBefore()</h3><p>这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)，同时被方法返回。如果参照节点是null则<code>insertBefore()</code>与<code>appendChild()</code>执行相同的操作。比如在item1前面插入item0：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = document.createElement(<span class="string">"li"</span>);
item.appendChild(document.createTextNode(<span class="string">"item0"</span>));
<span class="keyword">list</span>.insertBefore(item,<span class="keyword">list</span>.firstChild);
</code></pre><h3 id="replaceChild()">replaceChild()</h3><p><code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</p>
<h3 id="removeChild()">removeChild()</h3><p><code>removeChild()</code>方法为移除某个节点，参数为要移除的节点</p>
<h3 id="cloneNode()">cloneNode()</h3><p>该方法用于复制调用该方法的节点，接收两个参数。</p>
<ul>
<li>当参数为true时，复制该节点和该节点下的整个子节点树</li>
<li>当参数为false时，只复制当前节点本身</li>
</ul>
<p><em>详细介绍可以参考上篇文章</em></p>
<h3 id="normalize()">normalize()</h3><p>这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</p>
<hr>
<h1 id="Document类型">Document类型</h1><p>Document类型表示文档。而我们常用的document对象是HTMLDocument(继承自Document类型)的一个实例。document对象也是window对象的一个属性，因此可以将其作为全局的对象来访问。</p>
<h2 id="document对象的常用属性">document对象的常用属性</h2><ul>
<li>documentElement属性用来获取页面中的<code>&lt;html&gt;</code>元素 </li>
<li><p>body属性可以直接获取页面中的<code>body</code>元素 </p>
<pre><code><span class="tag">var</span> <span class="tag">body</span> = document.body
</code></pre></li>
<li><p>doctype属性可以获取对<code>&lt;!DOCTYPE&gt;</code>的引用</p>
<pre><code>console.log(document.doctype); //<span class="doctype">&lt;!DOCTYPE html&gt;</span>
</code></pre></li>
<li><p>title属性可以获取网页的<code>&lt;title&gt;</code>元素</p>
<pre><code><span class="comment">//获取title</span>
<span class="keyword">var</span> title = <span class="built_in">document</span>.title;
<span class="comment">//设置title</span>
<span class="built_in">document</span>.title = <span class="string">"new title"</span>;
</code></pre></li>
<li><p>URL属性可以获取当前页面完整的url</p>
</li>
<li>domain属性可以获取当前页面的域名</li>
</ul>
<p>比如google首页：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom.jpg-blogImg" alt=""></p>
<h2 id="document对象的常用方法">document对象的常用方法</h2><p>在开发过程中，经常需要取得摸个元素的引用，再执行某些操作。Document类型为此提供了两个方法。</p>
<ul>
<li><code>getElementById()</code>参数为元素的ID名<br><em>IE8 及较低版本不区分 ID 的大小写。如果页面中多个元素的 ID 值相同， getElementById() 只返回文档中第一次出现的元素</em></li>
<li><p><code>getElementsByTagName()</code>参数为元素的标签名，在HTML文档中该方法返回的是包含零个或多个元素的HTMLCollection对象。</p>
<pre><code>&lt;img src=<span class="string">"#1"</span> name=<span class="string">"user_name"</span>&gt;
&lt;img src=<span class="string">"#2"</span> name=<span class="string">"user_age"</span>&gt;
&lt;img src=<span class="string">"#3"</span> name=<span class="string">"user_sex"</span>&gt;
<span class="comment">//获取页面中所有的&lt;img&gt;元素</span>
var images = document.getElementsByTagName<span class="params">(<span class="string">"img"</span>)</span>;
<span class="comment">//获取长度</span>
console.<span class="built_in">log</span><span class="params">(images.length)</span>;
<span class="comment">//通过索引获取src</span>
console.<span class="built_in">log</span><span class="params">(images[<span class="number">0</span>].src)</span>;
<span class="comment">//通过name获取src</span>
console.<span class="built_in">log</span><span class="params">(images[<span class="string">"user_age"</span>].src)</span>;
</code></pre></li>
<li><p><code>getElementsByName()</code>这个方法会返回带有给定name特性的所有元素。</p>
</li>
</ul>
<h2 id="特殊集合">特殊集合</h2><p>除了属性和方法，document对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，为访问文档常用的部分提供了快捷方式。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>document.anchors</td>
<td>包含文档中所有带 name 特性的 <code>&lt;a&gt;</code> 元素；</td>
</tr>
<tr>
<td>document.forms</td>
<td>包含文档中所有的 <code>&lt;form&gt;</code> 元素</td>
</tr>
<tr>
<td>document.images</td>
<td>包含文档中所有的 <code>&lt;img&gt;</code> 元素</td>
</tr>
<tr>
<td>document.links</td>
<td>包含文档中所有带href特性的 <code>&lt;a&gt;</code> 元素</td>
</tr>
</tbody>
</table>
<h2 id="文档写入">文档写入</h2><p><code>write()</code>和<code>writeln()</code><br>这两个方法都会接受一个字符串参数。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。<code>writeln()</code>方法会在写入末尾添加一个换行符。</p>
<pre><code>current date and <span class="tag">time</span> is :
&lt;script type=<span class="string">"text/javascript"</span>&gt;
    document.<span class="function"><span class="title">write</span><span class="params">(<span class="string">"&lt;p&gt;"</span> + (new Date()</span></span>).<span class="function"><span class="title">toString</span><span class="params">()</span></span> +<span class="string">"&lt;/p&gt;"</span>)
&lt;/script&gt;
</code></pre><hr>
<h1 id="Element类型">Element类型</h1><p>Element类型提供了对元素标签名、子节点及特性的访问。常见的属性为<code>id,title,classname</code>等</p>
<h2 id="元素的创建">元素的创建</h2><p>可以通过<code>document.createElement()</code>方法创建新元素。比如创建一个<code>div</code>元素</p>
<pre><code><span class="keyword">var</span> <span class="keyword">div</span> = document.createElement(<span class="variable">"div"</span>);
</code></pre><h2 id="元素特性的相关操作">元素特性的相关操作</h2><h3 id="取得特性">取得特性</h3><p><code>getAttribute()</code>方法来取得属性值。</p>
<pre><code>&lt;div id=<span class="string">"my_test_div"</span> class=<span class="string">"div_class"</span> title=<span class="string">"div_title"</span> align=<span class="string">"left"</span>&gt;&lt;/div&gt;
var div = document.getElementById<span class="params">(<span class="string">"my_test_div"</span>)</span>;
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"id"</span>)</span>)</span>;  <span class="comment">//或者div.id</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"class"</span>)</span>)</span>;<span class="comment">//或者div.class</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"title"</span>)</span>)</span>;<span class="comment">//或者div.title</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"align"</span>)</span>)</span>;<span class="comment">//或者div.align</span>
</code></pre><p>通过<code>getAttribute()</code>方法也可以取得自定义特性的值，以下面的元素为例：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"my_test_div"</span> my_special_attribute=<span class="string">"hello!"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>这个元素包含一个名为 my_special_attribute 的自定义特性，它的值是 “hello!” 。可以像取得其他特性一样取得这个值:</p>
<pre><code><span class="keyword">var</span> value = <span class="keyword">div</span>.getAttribute(<span class="variable">"my_special_attribute"</span>);
</code></pre><h3 id="设置特性">设置特性</h3><p><code>setAttribute()</code>用于设置特性，这个方法接受两个参数：要设置的特性名和<br>值。如果特性已经存在，<code>setAttribute()</code>会以指定的值替换现有的值；如果特性不存在，<code>setAttribute()</code>则创建该属性并设置相应的值。</p>
<pre><code>&lt;<span class="keyword">div</span> id=<span class="variable">"my_test_div"</span> &gt;&lt;/<span class="keyword">div</span>&gt;
<span class="keyword">var</span> <span class="keyword">div</span> = document.getElementById(<span class="variable">"my_test_div"</span>);
<span class="keyword">div</span>.setAttribute(<span class="variable">"class"</span>,<span class="variable">"div_class"</span>);//或者<span class="keyword">div</span>.class=<span class="variable">"div_class"</span>
<span class="keyword">div</span>.setAttribute(<span class="variable">"title"</span>,<span class="variable">"div_title"</span>);//或者<span class="keyword">div</span>.title=<span class="variable">"div_title"</span>
<span class="keyword">div</span>.setAttribute(<span class="variable">"align"</span>,<span class="variable">"right"</span>);//或者<span class="keyword">div</span>.align=<span class="variable">"right"</span>
</code></pre><h3 id="删除特性">删除特性</h3><p><code>removeAttribute()</code>，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。</p>
<h2 id="元素子节点">元素子节点</h2><blockquote>
<p>元素子节点部分见节点关系部分。</p>
</blockquote>
<hr>
<h1 id="Text类型">Text类型</h1><p>正如之前用到过的例子中，有时候需要向文档树中添加文本节点。<br>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。<br>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。</p>
<pre><code>&lt;<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;<span class="comment">//没有内容，没有文本节点</span>
&lt;<span class="keyword">div</span>&gt; &lt;/<span class="keyword">div</span>&gt;<span class="comment">//有空格，有一个文本节点</span>
&lt;<span class="keyword">div</span>&gt;hello world!&lt;/<span class="keyword">div</span>&gt;<span class="comment">//有内容，有一个文本节点</span>
</code></pre><p>可以获取文本节点的引用并利用<code>nodeValue</code>修改它。</p>
<pre><code><span class="keyword">var</span> textNode = <span class="keyword">div</span>.firstChild;
textNode.nodeValue = <span class="variable">"this is a test"</span>;
</code></pre><p>如果没有文本节点，可以创建一个文本节点，并插入到元素中</p>
<pre><code><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);
element.className = <span class="string">"test"</span>;
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world"</span>);
element.appendChild(text);
<span class="built_in">document</span>.body.appendChild(element);
</code></pre><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法<code>normalize()</code>。<br>这个方法是由 Node类型定义的。如果在一个包含两个或多个文本节点的父元素上调用<code>normalize()</code>方法，则会将所有文本节点合并成一个节点，结果节点的<code>nodeValue</code> 等于将合并前每个文本节点的<code>nodeValue</code>值拼接起来的值。比如：</p>
<pre><code>var element = document.createElement<span class="params">(<span class="string">"div"</span>)</span>;
element.className = <span class="string">"message"</span>;
var textNode = document.createTextNode<span class="params">(<span class="string">"Hello world!"</span>)</span>;
element.appendChild<span class="params">(textNode)</span>;
var anotherTextNode = document.createTextNode<span class="params">(<span class="string">"Nico!"</span>)</span>;
element.appendChild<span class="params">(anotherTextNode)</span>;
document.body.appendChild<span class="params">(element)</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//2</span>
element.normalize<span class="params">()</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//1</span>
console.<span class="built_in">log</span><span class="params">(element.firstChild.nodeValue)</span>; <span class="comment">// "Hello world!Nico!"</span>
</code></pre><p>Text 类型提供了一个作用与<code>normalize()</code>相反的方法:<code>splitText()</code>。<br>这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割<code>nodeValue</code>值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的<code>parentNode</code>相同。</p>
<pre><code>var element = document.createElement<span class="params">(<span class="string">"div"</span>)</span>;
element.className = <span class="string">"test"</span>;
var <span class="built_in">text</span> = document.createTextNode<span class="params">(<span class="string">"Nico&amp;Sora"</span>)</span>;
element.appendChild<span class="params">(text)</span>;
document.body.appendChild<span class="params">(element)</span>;
var newNode = element.childNodes[<span class="number">0</span>].splitText<span class="params">(<span class="number">4</span>)</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes[<span class="number">0</span>].nodeValue)</span>;  <span class="comment">//Nico</span>
console.<span class="built_in">log</span><span class="params">(newNode.nodeValue)</span>;  <span class="comment">//&amp;Sora</span>
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//2</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>DOM是document object model的缩写，即：文档对象模型。DOM将HTML和XML描述为一个具有层次结构的节点树。DOM作为一个接口，可以对HTML或者XML进行添加，删除和修改。<br>根据 DOM，HTML 文档中的每个成分都是一个节点。DOM 是这样规定的： </p>
<ul>
<li>整个文档是一个文档节点 </li>
<li>每个 HTML 标签是一个元素节点 </li>
<li>包含在 HTML 元素中的文本是文本节点 </li>
<li>每一个 HTML 属性是一个属性节点 </li>
<li>注释属于注释节点]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
