<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[vector's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.supce.com/"/>
  <updated>2016-09-19T13:29:56.990Z</updated>
  <id>http://blog.supce.com/</id>
  
  <author>
    <name><![CDATA[vector]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之梯形标签页&饼图]]></title>
    <link href="http://blog.supce.com/2016/09/19/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A2%AF%E5%BD%A2%E6%A0%87%E7%AD%BE%E9%A1%B5&%E9%A5%BC%E5%9B%BE/"/>
    <id>http://blog.supce.com/2016/09/19/CSS Secret 读书笔记之梯形标签页&饼图/</id>
    <published>2016-09-18T16:00:00.000Z</published>
    <updated>2016-09-19T13:29:56.990Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="梯形标签页">梯形标签页</h1><p>梯形标签在导航栏部分经常遇到，书中只提到3D旋转的方案，但是万能的裁切和渐变怎么能丢？于是有了下面三种方式。</p>
<h2 id="裁切方案">裁切方案</h2><p>在形状这部分，裁切是一种很强大的方式，以左上角为原点，梯形的绘制对于它来说很简单。</p>
<pre><code>&lt;div class=<span class="string">"echelon-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
div{
    margin:<span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">4</span>em;
    font:<span class="number">125</span>%/<span class="number">4</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.echelon-a{
    <span class="built_in">background</span>: #<span class="number">58</span>a;
    -webkit-clip-path: polygon(<span class="number">20</span>% <span class="number">0</span>,<span class="number">80</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">100</span>%);
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-1.jpg" alt=""></p>
<h2 id="渐变方案">渐变方案</h2><p>到现在为止，利用渐变已经实现了条纹背景、复杂背景、图像边框以及下面的梯形。不得不说渐变真是一把利器。只要注意多层渐变的覆盖，设置好每层渐变的大小和位置即可。</p>
<pre><code><span class="class">.echelon-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="number">120deg</span>,transparent <span class="number">40px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>) top left,
                <span class="function">linear-gradient</span>(-<span class="number">120deg</span>,transparent <span class="number">40px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>) top right</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-2.jpg" alt=""></p>
<h2 id="3D旋转方案">3D旋转方案</h2><p>在现实的三维世界中旋转一个矩形，然后其在平面上的投影就是一个梯形。利用这个思路，可以尝试使用3D旋转来模拟一个梯形。<br>如果对元素直接使用<code>transform: perspective(.5em) rotateX(5deg);</code>,元素内部也会进行旋转，这并不是我们想要的结果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-3.jpg" alt=""><br>这时候可以利用伪元素来生成一个矩形，设置其堆叠次序，然后旋转为一个矩形。<br>仔细观察上面的图还会发现，内部的文字不居中了而且也变矮了，这是由于元素是以自身的中心线为轴进行空间旋转的。因此投影到2D屏幕上尺寸会发生变化，导致高度缩减，宽度增加。<br>为了控制它的尺寸，这时候可以指定<code>transform-origin</code>为bottom，当它在3D空间旋转时，可以把它的底边固定住。保证宽度不增加，然后再通过变形属性，即<code>scaleY()</code>来保证高度不会变低。<br>下面是完整的代码：</p>
<pre><code><span class="class">.echelon-c</span><span class="rules">{
    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;
}</span>
<span class="rule"><span class="attribute">.echelon-c</span>:<span class="value">before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> -<span class="number">1</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fb3</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">scaleY</span>(<span class="number">1.7</span>) <span class="function">perspective</span>(.<span class="number">5em</span>) <span class="function">rotateX</span>(<span class="number">5deg</span>)</span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> bottom</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-4.jpg" alt=""></p>
<h2 id="梯形导航">梯形导航</h2><p>上面说了3种方式主要是用于实现导航，这里就简单模拟了一个梯形的导航。详细过程就不说了，直接上代码。</p>
<blockquote>
<p>一定要注意在使用3D旋转时的元素的堆叠顺序。</p>
</blockquote>
<pre><code>&lt;nav&gt;
    &lt;a href="#"&gt;Home&lt;/a&gt;
    &lt;a href="#" class="selected"&gt;Contact&lt;/a&gt;
    &lt;a href="#"&gt;About&lt;/a&gt;
&lt;/nav&gt;
&lt;main&gt;Content&lt;/main&gt;
nav{
    position: relative<span class="comment">;</span>
    padding-left: 1em<span class="comment">;</span>
}
nav &gt; a {
    position: relative<span class="comment">;</span>
    display: inline-block<span class="comment">;</span>
    padding: .3em 1em 0<span class="comment">;</span>
    color: inherit<span class="comment">;</span>
    text-decoration: none<span class="comment">;</span>
    margin: 0 -.3em<span class="comment">;</span>
}
nav&gt;<span class="number">a::bef</span>ore,main{
    border: .1em solid rgba(0,0,0,.4)<span class="comment">;</span>
}
nav <span class="number">a::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    z-index: -1<span class="comment">;</span>
    border-bottom: none<span class="comment">;</span>
    border-radius: .5em .5em 0 0<span class="comment">;</span>
    background: #ccc linear-gradient(hsla(0,0%,100%,.6),hsla(0,0%,100%,0))<span class="comment">;</span>
    box-shadow: 0 .15em white inset<span class="comment">;</span>
    transform: scale(<span class="number">1.1,1.3</span>) perspective(.5em) rotateX(5deg)<span class="comment">;</span>
    transform-origin: bottom<span class="comment">;</span>
}
main {
    width: 30em<span class="comment">;</span>
    display: block<span class="comment">;</span>
    margin-bottom: 1em<span class="comment">;</span>
    background: #eee<span class="comment">;</span>
    padding: 1em<span class="comment">;</span>
    border-radius: .15em<span class="comment">;</span>
}
nav a:hover{
    z-index: 2<span class="comment">;</span>
}
nav a:hover<span class="number">::bef</span>ore{
    background-color: #eee<span class="comment">;</span>
    margin-bottom: -1px<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-5.gif" alt=""></p>
<h1 id="饼图">饼图</h1><p>一般在统计图表、进度指示器、定时器等场景中会用到饼图。我们希望能够很简单的创建出对应百分比的饼图，比如创建一个20%的饼图，只需一行代码，不引入外部插件。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"pie"</span>&gt;<span class="number">20</span>%&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>可以用下面这种方式解决。</p>
<h2 id="基于transform的解决方案">基于transform的解决方案</h2><p>首先要利用之前的border-radius创建一个圆，然后利用渐变遮盖半个圆。即：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"pie-test"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
.pie-test{
    width: <span class="number">100</span>px;
    height: <span class="number">100</span>px;
    border-radius: <span class="number">50</span>%;
    background: yellowgreen;
    background-image: linear-gradient(<span class="keyword">to</span> right,transparent <span class="number">50</span>%,<span class="comment">#655 0);</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-6.jpg" alt=""></p>
<p>然后设置伪元素，对右半圆进行遮盖</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
}
</code></pre><blockquote>
<p>设置border只是为了演示方便</p>
</blockquote>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-7.jpg" alt=""></p>
<p>对于伪元素，有3件微小的工作需要它完成</p>
<ul>
<li>第一件，希望它能遮盖有半侧的黑色部分，设置<code>background-color:inherit</code>即可。</li>
<li>第二件，希望它绕着圆形的圆心旋转，设置<code>transform-origin: left</code>或者0 50%</li>
<li>第三件，不希望它是矩形的，可以设置.pie-test为<code>overflow:hidden</code>或者给伪元素设置合理的<code>border-radius</code></li>
</ul>
<blockquote>
<p>伪元素：很惭愧，就做了三件微小的工作，谢谢大家！希望下次能控制天气~</p>
</blockquote>
<p>如果想要显示比例20%，只要旋转.2turn即可</p>
<p>具体代码如下：</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> inherit</span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(.<span class="number">2turn</span>)</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-8.jpg" alt=""></p>
<p>如果我们想要60%的比例，设置.6turn会出现下面的结果：</p>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-9.jpg" alt=""></p>
<p>这时候可以把50%-100%看做另外一个问题，设置一个黑色的伪元素，让它在0-.5turn范围内旋转，此时，要得到一个60%比率的饼图，代码如下：</p>
<pre><code><span class="rule"><span class="attribute">.pie-test</span>:<span class="value">:before{
    content: <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> dashed black</span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
    <span class="rule"><span class="attribute">transform-origin</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">0</span> <span class="number">100%</span> <span class="number">100%</span> <span class="number">0</span> / <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(.<span class="number">1turn</span>)</span></span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-10.jpg" alt=""></p>
<p>利用上面的代码可以用动画来做一个从0-100%的进度指示器了</p>
<p>这里给出完整代码：</p>
<pre><code>&lt;div class="pie-a"&gt;&lt;/div&gt;
@keyframes spin{
    to {transform: rotate(.5turn)<span class="comment">;}</span>
}
@keyframes bg{
    50% {background: #655<span class="comment">;}</span>
}
.pie-a{
    width: 100px<span class="comment">;</span>
    height: 100px<span class="comment">;</span>
    border-radius: 50%<span class="comment">;</span>
    background: yellowgreen<span class="comment">;</span>
    background-image: linear-gradient(to right,transparent 50%,#655 0)<span class="comment">;</span>
}
.pie-<span class="number">a::bef</span>ore{
    content: ''<span class="comment">;</span>
    display: block<span class="comment">;</span>
    margin-left: 50%<span class="comment">;</span>
    height: 100%<span class="comment">;</span>
    background-color: inherit<span class="comment">;</span>
    transform-origin: 0 50%<span class="comment">;</span>
    border-radius: 0 100% 100% 0 / 50%<span class="comment">;</span>
    animation: spin 3s linear infinite,
               bg 6s step-end infinite<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-11.gif" alt=""></p>
<p>下面再来实现最初的需求，核心是利用动画。<br>一个负的延时值是合法的，它意味着动画会立即开始播放，但会自动前进到延时值的绝对处，这样在视觉上就好像动画跳过指定时间直接播放了。<br>然后再让它暂停到我们需要的位置即可。<br>我们可以设置一个长达100S的动画，便于计算。<br>代码如下：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>0%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>40%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie"</span>&gt;</span>80%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
@keyframes spin{
    to {transform: rotate(.5turn);}
}
@keyframes bg{
    50% {background: #655;}
}
.pie{
    position: relative;
    display: inline-block;
    width: 100px;
    line-height: 100px;
    border-radius: 50%;
    background: yellowgreen;
    background-image: linear-gradient(to right,transparent 50%,#655 0);
    color: transparent;
}
.pie::before{
    content: '';
    position: absolute;
    top: 0;left: 50%;
    width: 50%;height: 100%;
    border-radius: 0 100% 100% 0 / 50%;
    background-color: inherit; 
    transform-origin: left;
    animation: spin 50s linear infinite,
               bg 100s step-end infinite;
    animation-play-state: paused;
    animation-delay: inherit;
}
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">var</span> elements = context.querySelectorAll(selector);
        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);
    }
    $$(<span class="string">'.pie'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">pie</span>)</span>{
        <span class="keyword">var</span> p = pie.textContent;
        pie.style.animationDelay = <span class="string">'-'</span> + <span class="built_in">parseFloat</span>(p) + <span class="string">'s'</span>;
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-12.jpg" alt=""></p>
<h2 id="SVG解决方案">SVG解决方案</h2><p>还有一种是利用SVG来实现，主要原理的是stroke-dasharray属性，使它的虚线间隙超过圆的周长，利用描边来表示百分比。下面不在细说，直接给出实现代码：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie-svg"</span>&gt;</span>20%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pie-svg"</span>&gt;</span>80%<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="function"><span class="keyword">function</span> <span class="title">$$</span>(<span class="params">selector,context</span>)</span>{
        context = context || <span class="built_in">document</span>;
        <span class="keyword">var</span> elements = context.querySelectorAll(selector);
        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(elements);
    }
    $$(<span class="string">'.pie-svg'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">pie</span>)</span>{
        <span class="keyword">var</span> p = <span class="built_in">parseFloat</span>(pie.textContent);
        <span class="keyword">var</span> NS = <span class="string">"http://www.w3.org/2000/svg"</span>;
        <span class="keyword">var</span> svg = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"svg"</span>);
        <span class="keyword">var</span> circle = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"circle"</span>);
        <span class="keyword">var</span> title = <span class="built_in">document</span>.createElementNS(NS, <span class="string">"title"</span>);

        circle.setAttribute(<span class="string">"r"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"cx"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"cy"</span>, <span class="number">16</span>);
        circle.setAttribute(<span class="string">"stroke-dasharray"</span>, p + <span class="string">" 100"</span>);

        svg.setAttribute(<span class="string">"viewBox"</span>, <span class="string">"0 0 32 32"</span>);
        title.textContent = pie.textContent;
        pie.textContent = <span class="string">''</span>;
        svg.appendChild(title);
        svg.appendChild(circle);
        pie.appendChild(svg); 
    });
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-08-13.jpg" alt=""><br>上面直接利用JavaScript完成自动化。也可以自己编写SVG标签。</p>
<pre><code><span class="tag">svg</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;<span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(-<span class="number">90deg</span>)</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> yellowgreen</span></span>;
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;
}</span>
<span class="tag">circle</span><span class="rules">{
    <span class="rule"><span class="attribute">fill</span>:<span class="value"> yellowgreen</span></span>;
    <span class="rule"><span class="attribute">stroke</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
    <span class="rule"><span class="attribute">stroke-width</span>:<span class="value"> <span class="number">32</span></span></span>;
}</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="梯形标签页">梯形标签页</h1><p>梯形标签在导航栏部分经常遇到，书中只提到3D旋转的方案，但是万能的裁切和渐变怎么能丢？于是有了下面三种方式。</p>
<h2 id="裁切方案">裁切方案</h2><p>在形状这部分，裁切是一种很强大的方式，以左上角为原点，梯形的绘制对于它来说很简单。</p>
<pre><code>&lt;div class=<span class="string">"echelon-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
div{
    margin:<span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">4</span>em;
    font:<span class="number">125</span>%/<span class="number">4</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.echelon-a{
    <span class="built_in">background</span>: #<span class="number">58</span>a;
    -webkit-clip-path: polygon(<span class="number">20</span>% <span class="number">0</span>,<span class="number">80</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">100</span>%);
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之菱形图片&切角效果]]></title>
    <link href="http://blog.supce.com/2016/09/18/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%8F%B1%E5%BD%A2%E5%9B%BE%E7%89%87&%E5%88%87%E8%A7%92%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.supce.com/2016/09/18/CSS Secret 读书笔记之菱形图片&切角效果/</id>
    <published>2016-09-17T16:00:00.000Z</published>
    <updated>2016-09-18T13:05:37.670Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="菱形图片">菱形图片</h1><p>有时候可能会遇到菱形图片的需求，可以用下面两种方式实现。</p>
<h2 id="基于变形的方案">基于变形的方案</h2><p>这种方式与之前平行四边形的解决方案类似，需要把图片用一个div包裹，然后div和img进行相反的变形。</p>
<pre><code>&lt;div class=<span class="string">"diamond-a"</span>&gt;
    &lt;img src=<span class="string">"cat.jpg"</span>&gt;
&lt;/div&gt;
.diamond-a{
    margin: <span class="number">100</span>px;
    <span class="variable">width</span>: <span class="number">250</span>px;
    <span class="variable">height</span>:<span class="number">250</span>px;
    transform: <span class="built_in">rotate</span>(<span class="number">45</span>deg);
    overflow: hidden;
}
.diamond-a &gt; img{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">100</span>%;
    transform: <span class="built_in">rotate</span>(-<span class="number">45</span>deg);
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-1.jpg" alt=""><br>得到的结果是个八角形。原因就是<code>max-width: 100%;</code>会解析为外部容器的边长，如果图片的宽度与容器的菱形对角线长度相同，就会成为一个菱形。也就是设置宽度为外部容器边长的√2倍，即约为1.42倍。</p>
<pre><code><span class="class">.diamond-a</span> &gt; <span class="tag">img</span><span class="rules">{
    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">rotate</span>(-<span class="number">45deg</span>) <span class="function">scale</span>(<span class="number">1.42</span>)</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-2.jpg" alt=""></p>
<h2 id="裁切路径方案">裁切路径方案</h2><p>上面的方法首先破坏了原有的HTML结构，而且要求图片必须是正方形。<br>这里就可以用裁切的方法来实现。而且可以给图片添加动画，当鼠标悬停时，图片扩展为完整的面积。</p>
<pre><code>&lt;img <span class="keyword">class</span>=<span class="string">"diamond-b"</span> src=<span class="string">"cat.jpg"</span> /&gt;
.diamond-b{
    width: <span class="number">250</span>px;
    -webkit-clip-path: polygon(<span class="number">50</span>% <span class="number">0</span>,<span class="number">100</span>% <span class="number">50</span>%,<span class="number">50</span>% <span class="number">100</span>%,<span class="number">0</span> <span class="number">50</span>%);
    clip-path: polygon(<span class="number">50</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">50</span>%, <span class="number">50</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">50</span>%);
    transition: <span class="number">1</span>s;
}
.diamond-b:hover{
    -webkit-clip-path: polygon(<span class="number">0</span> <span class="number">0</span>, <span class="number">100</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">100</span>%);
    clip-path: polygon(<span class="number">0</span> <span class="number">0</span>, <span class="number">100</span>% <span class="number">0</span>, <span class="number">100</span>% <span class="number">100</span>%, <span class="number">0</span> <span class="number">100</span>%);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-4.gif" alt=""></p>
<hr>
<h1 id="切角效果">切角效果</h1><p>之前的切角效果大多是使用背景图片来达到目的，比如使用三角形盖住元素的顶角来模拟切角效果(当网页背景是纯色时)，或者使用一张或者多张已经切过角的图片来作为整个元素的背景。这些方法增加了额外的HTTP请求，而且也不够灵活，不易维护。<br>这时候可以根据场景用下面几种方式来实现。</p>
<h2 id="渐变方案">渐变方案</h2><p>在之前渐变已经帮助我们实现了好多特效比如条纹背景，复杂背景以及图像边框等。这次来帮助我们实现切角效果，后面也还有它大展神通的地方！<br>渐变方案很简单，把一个透明色放在切角处即可，以右下角为例：</p>
<pre><code>&lt;div class=<span class="string">"rad-a"</span>&gt;<span class="keyword">this</span> is a test&lt;/div&gt;
.rad-a{
    margin: <span class="number">20</span>px;
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">6</span>em;
    font: <span class="number">125</span>%/<span class="number">6</span>em sans-serif;
    <span class="built_in">text</span>-align: center;
    <span class="built_in">color</span>: white;
}
.rad-a{
    <span class="built_in">background</span>: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,#<span class="number">58</span>a <span class="number">15</span>px);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-5.jpg" alt=""></p>
<p>假设需要裁剪底部两个角。最初的想法可能会是这样：</p>
<pre><code>.rad-b{
    background: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px),</span>
                linear-gradient(<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#fb3 <span class="number">15</span>px);   </span>
}
</code></pre><p>但会发现结果是这样的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-6.jpg" alt=""><br>这是因为两层渐变互相覆盖的结果。<br>那可以对每层渐变进行位置和大小的修改来实现：</p>
<pre><code><span class="class">.rad-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(-<span class="number">45deg</span>,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) right,
                <span class="function">linear-gradient</span>(<span class="number">45deg</span>,transparent <span class="number">15px</span>,<span class="hexcolor">#fb3</span> <span class="number">15px</span>) left</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-7.jpg" alt=""></p>
<p>那么也可以做出切出四角的效果了:</p>
<pre><code>.rad-c{
    background: linear-gradient(-<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) bottom right,</span>
                linear-gradient(<span class="number">45</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) bottom left,</span>
                linear-gradient(<span class="number">135</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">58</span>a <span class="number">15</span>px) top left,</span>
                linear-gradient(-<span class="number">135</span>deg,transparent <span class="number">15</span>px,<span class="preprocessor">#<span class="number">48</span>a <span class="number">15</span>px) top right;</span>
    background-size: <span class="number">50</span>% <span class="number">50</span>%;
    background-repeat: no-repeat;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-8.jpg" alt=""></p>
<blockquote>
<p>可以用SCSS预处理下，需要的时候直接调用</p>
</blockquote>
<h2 id="弧形切角">弧形切角</h2><p>既然有了<code>linear-gradient</code>，那使用<code>radial-gradient</code>就可以创建出弧形切角</p>
<pre><code><span class="class">.rad-d</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">radial-gradient</span>(circle at top left,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) top left,
                <span class="function">radial-gradient</span>(circle at top right,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) top right,
                <span class="function">radial-gradient</span>(circle at bottom left,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) bottom left,
                <span class="function">radial-gradient</span>(circle at  bottom right,transparent <span class="number">15px</span>,<span class="hexcolor">#58a</span> <span class="number">15px</span>) bottom right</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">50%</span> <span class="number">50%</span></span></span>;
    <span class="rule"><span class="attribute">background-repeat</span>:<span class="value"> no-repeat</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-9.jpg" alt=""></p>
<h2 id="内联SVG与border-image方案">内联SVG与border-image方案</h2><p>这个方式，是利用<code>border-image</code>的缩放，设置SVG为一个八角形，那么得出的效果就是我们需要的切角效果。</p>
<pre><code><span class="class">.rad-e</span><span class="rules">{
    <span class="rule"><span class="attribute">color</span>:<span class="value"> black</span></span>;
    <span class="comment">/*border:20px solid transparent;*/</span>
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">20px</span> solid <span class="hexcolor">#58a</span></span></span>;
    <span class="rule"><span class="attribute">border-image</span>:<span class="value"> <span class="number">1</span> <span class="function">url</span>(<span class="string">'data:image/svg+xml,\
                  &lt;svg xmlns="http://www.w3.org/2000/svg" width="3" height="3" fill="%2358a"&gt;\
                  &lt;polygon points="0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2" /&gt;\
                  &lt;/svg&gt;'</span>)</span></span>;
    <span class="comment">/*background: #58a;*/</span>
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">radial-gradient</span>(circle at center,<span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">5</span>),<span class="hexcolor">#58a</span>)</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-10.jpg" alt=""></p>
<blockquote>
<p>注意，由于背景色会延伸到边框，所以一定要记着设置background-clip的值。为了平稳退化，防止浏览器不支持border-image，可以设置border的颜色与背景色相同</p>
</blockquote>
<h2 id="裁切路径方案-1">裁切路径方案</h2><p>跟上面提到的菱形一样，也可以用裁切路径的方案</p>
<pre><code>.rad-f{
    <span class="comment">/*background: #58a;*/</span>
    background: url(cat.jpg);
    background-size: <span class="number">100</span>% <span class="number">100</span>%;
    clip-path: polygon(<span class="number">20</span>px <span class="number">0</span>, calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">0</span>, <span class="number">100</span>% <span class="number">20</span>px, <span class="number">100</span>% calc(<span class="number">100</span>% - <span class="number">20</span>px),calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">100</span>%,
                               <span class="number">20</span>px <span class="number">100</span>%, <span class="number">0</span> calc(<span class="number">100</span>% - <span class="number">20</span>px), <span class="number">0</span> <span class="number">20</span>px);
    -webkit-clip-path: polygon(<span class="number">20</span>px <span class="number">0</span>, calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">0</span>, <span class="number">100</span>% <span class="number">20</span>px, <span class="number">100</span>% calc(<span class="number">100</span>% - <span class="number">20</span>px),calc(<span class="number">100</span>% - <span class="number">20</span>px) <span class="number">100</span>%,
                               <span class="number">20</span>px <span class="number">100</span>%, <span class="number">0</span> calc(<span class="number">100</span>% - <span class="number">20</span>px), <span class="number">0</span> <span class="number">20</span>px);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-07-11.jpg" alt=""></p>
<ul>
<li>使用这个方式的好处显而易见，就是可以使用任意类型的背景，就如上面的例子背景如果是图片也可以进行剪裁。而且想菱形那里设置hover动画效果等。</li>
</ul>
<ul>
<li>但是，它有一个缺点，当内边距不够宽时，它会裁切掉文本。因为它只能对元素做出统一的裁切，并不能区分元素的部分。而在渐变方案中，允许字体溢出并超出切角区域(因为它只是背景图案)，而<code>border-image</code>会起到普通边框的作用，使文字折行。</li>
</ul>
<p><em>今天天津好冷</em></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="菱形图片">菱形图片</h1><p>有时候可能会遇到菱形图片的需求，可以用下面两种方式实现。</p>
<h2 id="基于变形的方案">基于变形的方案</h2><p>这种方式与之前平行四边形的解决方案类似，需要把图片用一个div包裹，然后div和img进行相反的变形。</p>
<pre><code>&lt;div class=<span class="string">"diamond-a"</span>&gt;
    &lt;img src=<span class="string">"cat.jpg"</span>&gt;
&lt;/div&gt;
.diamond-a{
    margin: <span class="number">100</span>px;
    <span class="variable">width</span>: <span class="number">250</span>px;
    <span class="variable">height</span>:<span class="number">250</span>px;
    transform: <span class="built_in">rotate</span>(<span class="number">45</span>deg);
    overflow: hidden;
}
.diamond-a &gt; img{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">100</span>%;
    transform: <span class="built_in">rotate</span>(-<span class="number">45</span>deg);
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之自适应椭圆&平行四边形]]></title>
    <link href="http://blog.supce.com/2016/09/17/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E9%80%82%E5%BA%94%E6%A4%AD%E5%9C%86&%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/"/>
    <id>http://blog.supce.com/2016/09/17/CSS Secret 读书笔记之自适应椭圆&平行四边形/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2016-09-17T03:35:13.305Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="自适应椭圆">自适应椭圆</h1><p>对于一个正方形的元素，如果设置其属性<code>border-radius</code>的值大于等于边长的一半，那么该元素会变成一个圆形。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"round-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
body{
    display: flex;
    flex-flow: row wrap; 
    justify-content: <span class="constant">space</span>-<span class="keyword">around</span>;
}
.<span class="command">round</span>-a{
    background: <span class="comment">#fb3;</span>
    width: <span class="number">10</span>em;
    height: <span class="number">10</span>em;
    border-radius: <span class="number">50</span>%;
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-1.jpg" alt=""></p>
<p>那么对于矩形设置合适的水平与垂直<code>border-radius</code>就可以创建出一个椭圆了。<br>恰好<code>border-radius</code>可以单独指定水平和垂直半径，只要用一个斜杠(/)分隔这两个值即可。比如对于<code>200px * 150px</code>的元素，把它圆角的两个半径值分别设为宽高的一般(<code>border-radius: 100px / 75px</code>)，就可以得到一个椭圆了。<br>为了创建能够自适应的椭圆，只要把参数改为百分比。</p>
<pre><code><span class="class">.round-b</span>{
    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">20px</span>;
    <span class="attribute">background</span>: <span class="hexcolor">#fb3</span>;
    <span class="attribute">width</span>: <span class="number">10em</span>;
    <span class="attribute">height</span>: <span class="number">6em</span>;
}
<span class="class">.round-b</span>{
    <span class="attribute">border-radius</span>: <span class="number">50%</span> / <span class="number">50%</span>;
    <span class="comment">/*border-radius: 50%;*/</span>   <span class="comment">//简写</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-2.jpg" alt=""></p>
<h2 id="半椭圆">半椭圆</h2><p>由于<code>border-radius</code>的灵活性为我们创建半椭圆提供了可能性。<br>首先，它支持给每个角指定不同的半径。即展开式属性：</p>
<ul>
<li>border-top-left-radius</li>
<li>border-top-right-radius</li>
<li>border-bottom-right-radius</li>
<li>border-bottom-left-radius</li>
</ul>
<p>当然，也可以一次提供用空格分开的多个值来简写。</p>
<ul>
<li>如果指定四个值，则按照左上，右上，右下，左下 这种逆时针指定。</li>
<li>如果指定三个值，则第一个表左上，第二个表示右上与左下，第三个表示右下。</li>
<li>如果指定两个值，则第一个表示左上与右下，第二个表示右上与左下。</li>
<li>如果指定一个值，则表示四个角均为该值。</li>
</ul>
<p>但是<code>border-radius</code>比我之前想到的更加灵活，除了可以指定每个角为不同的半径，还可以为四个角提供完全不同的水平和垂直半径。<br>方法是在斜杠前指定1-4个值表示水平半径，在斜杠后指定1-4个值表示垂直半径。这两组值的简写规则与之前不同，是单独展开为四个值的。比如<code>border-radius: 10px / 5px 20px;</code>效果相当于<code>border-radius: 10px 10px 10px 10px / 5px 20px 5px 20px;</code></p>
<p>有了上面这些，就可以轻松创建一个沿横轴的半椭圆了：</p>
<pre><code>.round-c{
    border-radius: <span class="number">50</span>% / <span class="number">100</span>% <span class="number">100</span>% <span class="number">0</span> <span class="number">0</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-3.jpg" alt=""></p>
<p>也创建一个沿纵轴的半椭圆：</p>
<pre><code>.round-d{
    border-radius: <span class="number">0</span> <span class="number">100</span>% <span class="number">100</span>% <span class="number">0</span> / <span class="number">50</span>%;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-4.jpg" alt=""></p>
<h2 id="四分之一椭圆">四分之一椭圆</h2><p>按照上面的思路，要创建一个四分之一椭圆，其中一个角的水平和垂直半径都需要是100%，其他的三个角不能设为圆角。于是：</p>
<pre><code><span class="class">.round-e</span><span class="rules">{
    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-5.jpg" alt=""></p>
<hr>
<h1 id="平行四边形">平行四边形</h1><p>在导航栏有时候会用到平行四边形。之前也写过几种实现的方法，当时用到了背景图片，这里用纯CSS实现下。<br>最简单的方法就是对于一个普通的矩形进行斜向拉伸：</p>
<pre><code>&lt;div class="para-a"&gt;this is a test&lt;/div&gt;
.para-a{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    background: #58a<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
}
.para-a{
    transform: skewX(-45deg)<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-6.jpg" alt=""><br>但是这样带来一个问题，就是文字也随着被斜向拉伸了，可以用下面两种方式，只让容器形状倾斜，同时保持内容不被拉伸。</p>
<h2 id="嵌套元素方案">嵌套元素方案</h2><p>最容易想到的方法就是嵌套一个元素了。对容器内部的元素再进行一次反向拉伸，抵消外部容器的拉伸效果。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"para-b"</span>&gt;
    &lt;<span class="keyword">div</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
.para-b{
    margin: <span class="number">20</span>px <span class="number">20</span>px;
    width: <span class="number">10</span>em;
    height: <span class="number">4</span>em;
    background: <span class="comment">#58a;</span>
    color: white;
    <span class="type">text</span>-align: center;
    font: <span class="number">125</span>%/<span class="number">4</span>em sans-serif;
}
.para-b{
    transform: skewX(-<span class="number">45</span>deg);
}
.para-b &gt; <span class="keyword">div</span>{
    transform: skewX(<span class="number">45</span>deg);
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-7.jpg" alt=""></p>
<h2 id="伪元素方案">伪元素方案</h2><p>根据之前的经验，既然可以嵌套元素，那么应该也可以使用伪元素来避免污染原有的HTML结构。</p>
<pre><code>&lt;div class="para-c"&gt;this is a test&lt;/div&gt;
.para-c{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
    position: relative<span class="comment">;</span>
}
.para-<span class="number">c::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    background: #58a<span class="comment">;</span>
    z-index: -1<span class="comment">;</span>
    transform: skewX(-45deg)<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-8.jpg" alt=""></p>
<blockquote>
<p>注意，这种方式虽然在视觉上是平行四边形，但是他实际所占据的仍然是个矩形。</p>
</blockquote>
<h1 id="内边框圆角">内边框圆角</h1><p>利用这种思路，可以给之前的内边框圆角增加一种实现方式</p>
<pre><code>&lt;div class="bor-ra"&gt;this is a test&lt;/div&gt;
.bor-ra{
    margin: 20px 20px<span class="comment">;</span>
    width: 10em<span class="comment">;</span>
    height: 4em<span class="comment">;</span>
    color: white<span class="comment">;</span>
    text-align: center<span class="comment">;</span>
    font: 125%/4em sans-serif<span class="comment">;</span>
    position: relative<span class="comment">;</span>
}
.bor-ra{
    background: tan<span class="comment">;</span>
    border-radius: .8em<span class="comment">;</span>
    outline: .6em solid #655<span class="comment">;</span>
}
.bor-r<span class="number">a::bef</span>ore{
    content: ""<span class="comment">;</span>
    position: absolute<span class="comment">;</span>
    top: 0<span class="comment">;right: 0;bottom: 0;left: 0;</span>
    background: #655<span class="comment">;</span>
    z-index: -1<span class="comment">;</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-06-9.jpg" alt=""></p>
<p>OK 搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="自适应椭圆">自适应椭圆</h1><p>对于一个正方形的元素，如果设置其属性<code>border-radius</code>的值大于等于边长的一半，那么该元素会变成一个圆形。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"round-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
body{
    display: flex;
    flex-flow: row wrap; 
    justify-content: <span class="constant">space</span>-<span class="keyword">around</span>;
}
.<span class="command">round</span>-a{
    background: <span class="comment">#fb3;</span>
    width: <span class="number">10</span>em;
    height: <span class="number">10</span>em;
    border-radius: <span class="number">50</span>%;
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之伪随机背景&图像边框]]></title>
    <link href="http://blog.supce.com/2016/09/16/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BC%AA%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF&%E5%9B%BE%E5%83%8F%E8%BE%B9%E6%A1%86/"/>
    <id>http://blog.supce.com/2016/09/16/CSS Secret 读书笔记之伪随机背景&图像边框/</id>
    <published>2016-09-15T16:00:00.000Z</published>
    <updated>2016-09-16T13:34:24.303Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="伪随机背景">伪随机背景</h1><p>伪随机背景其实还是对条纹背景的扩展。假设一种场景，我们想得到不同颜色和不同宽度的垂直条纹。并且在背景平铺时不会产生接缝。利用<code>linear-gradient</code>好像可以轻松实现</p>
<pre><code>&lt;div class="rb-a"&gt;&lt;/div&gt;
body{
    display: flex<span class="comment">;</span>
    flex-flow: row wrap<span class="comment">;</span>
    justify-content: space-around<span class="comment">;</span>
}
div{
    margin: 20px 20px<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    min-width: 20em<span class="comment">;</span>
    min-height: 6em<span class="comment">;</span>
}
.rb-a{
    background: linear-gradient(90deg,#fb3 15%,#655 0,#655 40%,#ab4 0,#ab4 65%,hsl(20,40%,90%) 0)<span class="comment">;</span>
    background-size: 80px 100%<span class="comment">;</span>
}
</code></pre><a id="more"></a>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-1.jpg" alt=""><br>从效果图中可以看出这个背景图的重复规律非常明显，每水平80px就会重复一次。<br>这时候可以考虑另一种思路：<br>把这组条纹从一个平面图拆散为多个图层，一种颜色作为底色，另外三种颜色作为条纹，然后再让条纹以不同的间隔进行重复平铺，同时利用<code>background-size</code>控制条纹的间距。</p>
<pre><code>background: hsl(<span class="number">20</span>,<span class="number">40</span>%,<span class="number">90</span>%);
background-image: linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#fb3 <span class="number">10</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#ab4 <span class="number">20</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#<span class="number">655</span> <span class="number">20</span>px,transparent <span class="number">0</span>);</span>
background-size: <span class="number">80</span>px <span class="number">100</span>%,<span class="number">60</span>px <span class="number">100</span>%,<span class="number">40</span>px <span class="number">100</span>%;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-2.jpg" alt=""><br>随机的效果好了很多，但是仔细观察会发现每隔240px像素就会重复一次，且240正好是40 60 80 的最小公倍数。<br>如果我们将背景的宽度设置为质数，那么它们的最小公倍数就会很大，当大于屏幕宽度时就可以在视觉上满足随机背景了。于是将背景的宽度修改一下</p>
<pre><code>background: hsl(<span class="number">20</span>,<span class="number">40</span>%,<span class="number">90</span>%);
background-image: linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#fb3 <span class="number">11</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#ab4 <span class="number">23</span>px,transparent <span class="number">0</span>),</span>
                  linear-gradient(<span class="number">90</span>deg,<span class="preprocessor">#<span class="number">655</span> <span class="number">41</span>px,transparent <span class="number">0</span>);</span>
background-size: <span class="number">41</span>px <span class="number">100</span>%,<span class="number">61</span>px <span class="number">100</span>%,<span class="number">83</span>px <span class="number">100</span>%;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-3.jpg" alt=""><br>这时候的最小公倍数为41<em>61</em>83=207583，已经可以满足我们的需求了。</p>
<hr>
<h1 id="图像边框">图像边框</h1><p>图片经常作为容器的背景，但是有时候想把一副图片作为边框。也就是说一张图片被剪裁到边框所在的方形环状区域。同时，也希望图片能够随着元素的大小进行缩放并完整的覆盖边框的区域。<br>但是<code>border-image</code>是一种九宫格伸缩法，将图片裁剪为九块，放到边框所对应的变和角，显然是不符合我们的要求的。<br>可以尝试设置元素的背景色为白色，然后给元素外部嵌套一个父元素，并设置背景为图片。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"border-test"</span>&gt;
    &lt;<span class="keyword">div</span>&gt;this <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a test
    this <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a testthis <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
.border-test{
    background: url(stone-art.jpg);
    background-size: cover;
    padding: <span class="number">.5</span>em;
}
.border-test &gt; <span class="keyword">div</span>{
    background: white;
    padding: <span class="number">1</span>em;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-4.jpg" alt=""><br>在强迫症的作用下，并不想嵌套一个父元素，就得换一个思路了。<br>首先设置元素的背景为图片，然后在背景图之上叠加一层纯色的实色背景。设置背景边框为透明，并且为两层背景指定不同的<code>background-clip</code>的值。由于只能在多重背景的最底层设置背景色，因此需要用一道从白色过渡到白色的CSS渐变来模拟出纯白色背景的效果。</p>
<pre><code>&lt;div class=<span class="string">"border-a"</span>&gt;<span class="keyword">this</span> is a testthis is a testthis is a testthis is a testthis is a testthis is a testthis is a test&lt;/div&gt;
.border-a,.border-b{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">20</span>em;
    <span class="built_in">max</span>-<span class="variable">height</span>: <span class="number">10</span>em;
    padding: <span class="number">1</span>em;
    border: <span class="number">1</span>em solid transparent;
}
.border-a{
    <span class="built_in">background</span>: linear-gradient(white,white),
                url(stone-art.jpg);
    <span class="built_in">background</span>-<span class="built_in">size</span>: cover; 
    <span class="built_in">background</span>-clip: padding-<span class="built_in">box</span>,border-<span class="built_in">box</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-5.jpg" alt=""><br><code>background-origin</code> 属性规定 <code>background-position</code> 属性相对于什么位置来定位。其默认值为<code>padding-box</code>，因此边框的图片出现了奇怪的拼接效果。于是添加一条属性：<br><code>background-origin: border-box;</code><br>就可以到达下面这个结果了：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-7.jpg" alt=""></p>
<p>既然可以使用渐变那就可以模拟更多的边框效果了~ 比如下面这种：</p>
<pre><code>background: linear-gradient(white,white) padding-box,
                repeating-linear-gradient(-<span class="number">45</span>deg,red <span class="number">0</span>,red <span class="number">12.5</span>%,transparent <span class="number">0</span>,transparent <span class="number">25</span>%,<span class="preprocessor">#<span class="number">58</span>a <span class="number">0</span>,</span>
                    <span class="preprocessor">#<span class="number">58</span>a <span class="number">37.5</span>%,transparent <span class="number">0</span>,transparent <span class="number">50</span>%) <span class="number">0</span> <span class="number">0</span> / <span class="number">4</span>em <span class="number">4</span>em;</span>
</code></pre><p>一种漂亮的信封效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-8.jpg" alt=""></p>
<p>当然，也可以给边框添加动画。</p>
<pre><code><span class="at_rule">@<span class="keyword">keyframes</span> ants </span>{<span class="tag">to</span> <span class="rules">{<span class="rule"><span class="attribute">background-position</span>:<span class="value"> <span class="number">100%</span>}}
.border-c{
    border: <span class="number">1px</span> solid transparent</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(white,white) padding-box,
                <span class="function">repeating-linear-gradient</span>(-<span class="number">45deg</span>,black <span class="number">0</span>,black <span class="number">25%</span>,white <span class="number">0</span>,white <span class="number">50%</span>) <span class="number">0</span> <span class="number">0</span> / .<span class="number">6em</span> .<span class="number">6em</span></span></span>;
    <span class="rule"><span class="attribute">animation</span>:<span class="value"> ants <span class="number">12s</span> ease-out infinite</span></span>;
}</span>
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-05-9.jpg" alt=""><br>可惜图片看不出动画效果了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="伪随机背景">伪随机背景</h1><p>伪随机背景其实还是对条纹背景的扩展。假设一种场景，我们想得到不同颜色和不同宽度的垂直条纹。并且在背景平铺时不会产生接缝。利用<code>linear-gradient</code>好像可以轻松实现</p>
<pre><code>&lt;div class="rb-a"&gt;&lt;/div&gt;
body{
    display: flex<span class="comment">;</span>
    flex-flow: row wrap<span class="comment">;</span>
    justify-content: space-around<span class="comment">;</span>
}
div{
    margin: 20px 20px<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    min-width: 20em<span class="comment">;</span>
    min-height: 6em<span class="comment">;</span>
}
.rb-a{
    background: linear-gradient(90deg,#fb3 15%,#655 0,#655 40%,#ab4 0,#ab4 65%,hsl(20,40%,90%) 0)<span class="comment">;</span>
    background-size: 80px 100%<span class="comment">;</span>
}
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之条纹背景&复杂背景]]></title>
    <link href="http://blog.supce.com/2016/09/16/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%9D%A1%E7%BA%B9%E8%83%8C%E6%99%AF&%E5%A4%8D%E6%9D%82%E8%83%8C%E6%99%AF/"/>
    <id>http://blog.supce.com/2016/09/16/CSS Secret 读书笔记之条纹背景&复杂背景/</id>
    <published>2016-09-15T16:00:00.000Z</published>
    <updated>2016-09-16T11:43:11.307Z</updated>
    <content type="html"><![CDATA[<h1 id="条纹背景">条纹背景</h1><p>通常条纹背景是由一个图片来代替，或者使用SVG。能不能利用CSS直接创建条纹图案呢，答案是肯定的。<br>假设背景是垂直线性渐变。比如：<code>background:linear-gradient(#fb3,#58a);</code><br>效果是这个样子的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-1.jpg" alt=""><br>如果让渐变区域变的更窄，产生一个无限小的渐变区域，比如：<code>background:linear-gradient(#fb3 50%,#58a 50%);</code> 就可以得到想要的结果了。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-2.jpg" alt=""><br><a id="more"></a></p>
<h2 id="横向条纹">横向条纹</h2><p>利用上面的方法可以轻松利用CSS绘出横向条纹，同时还可以设置多种颜色的条纹，以及每个条纹的尺寸。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-b"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test-c"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="tag">body</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
}</span>
<span class="tag">div</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span> <span class="number">20px</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">10em</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">6em</span></span></span>;
}</span>
<span class="class">.test-a</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">50%</span>, <span class="hexcolor">#58a</span> <span class="number">50%</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">24px</span></span></span>;
}</span>
<span class="class">.test-b</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">30%</span>, <span class="hexcolor">#58a</span> <span class="number">30%</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">24px</span></span></span>;
}</span>
<span class="class">.test-c</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">linear-gradient</span>(<span class="hexcolor">#fb3</span> <span class="number">33.3%</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">66.6%</span>,yellowgreen <span class="number">0</span>)</span></span>;
    <span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">100%</span> <span class="number">36px</span></span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-3.jpg" alt=""></p>
<h2 id="垂直条纹">垂直条纹</h2><p>幸好<code>linear-gradient</code>足够的灵活，利用它可以轻松创建出垂直条纹。<br>代码：</p>
<pre><code>&lt;<span class="operator">div</span> class=<span class="string">"test-d"</span>&gt;&lt;/<span class="operator">div</span>&gt;
.test-d{
    background: linear-gradient(<span class="built_in">to</span> <span class="constant">right</span>,<span class="comment">#fb3 50%,#58a 50%);</span>
    <span class="comment">/*background: linear-gradient(90deg,#fb3 50%,#58a 50%);*/</span>
    background-size: <span class="number">32</span>px <span class="number">100</span>%;   <span class="comment">/*颠倒下宽度和高度值*/</span>
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-11.jpg" alt=""></p>
<h2 id="斜向条纹">斜向条纹</h2><p>在绘制斜向条纹之前，如果对<code>linear-gradient</code>的斜向线性渐变不太理解，可以参考下张鑫旭大神的这篇<a href="http://www.zhangxinxu.com/wordpress/?p=3639" target="_blank" rel="external">博文</a><br>在完成水平和垂直条纹后，好像斜向条纹也很就简单，稍微修改下渐变方向和<code>background-size</code>的值就可以了。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="hexcolor">#fb3</span> <span class="number">50%</span>,<span class="hexcolor">#58a</span> <span class="number">50%</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p>但是得到的结果并不是想要的。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-4.jpg" alt=""><br>如果观察下斜向条纹，会发现斜向条纹是由四条条纹的“贴片”组成的。如下图：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-5.jpg" alt=""><br>这样的话解决思路就有了。</p>
<pre><code>background:linear-gradient(<span class="number">45</span>deg,<span class="preprocessor">#fb3 <span class="number">25</span>%,#<span class="number">58</span>a <span class="number">0</span>,#<span class="number">58</span>a <span class="number">50</span>%,#fb3 <span class="number">0</span>,#fb3 <span class="number">75</span>%,#<span class="number">58</span>a <span class="number">0</span>);</span>
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-6.jpg" alt=""><br>但是会发现条纹的宽度并不是16像素，因为<code>background-size</code>指定的长度是最左下角的直角三角形的直角边长度。而条纹的宽度是直角三角形的高，对于45度的三角形，要想高为16px，直角边设置为16√2，即<code>background-size</code>设置为2*16√2的约值。<br>好了，45度的斜向条纹完成了，好像其他度数的条纹比葫芦画瓢轻松得来，设置度数为60度</p>
<pre><code>background:linear-gradient(<span class="number">60</span>deg,<span class="preprocessor">#fb3 <span class="number">25</span>%,#<span class="number">58</span>a <span class="number">0</span>,#<span class="number">58</span>a <span class="number">50</span>%,#fb3 <span class="number">0</span>,#fb3 <span class="number">75</span>%,#<span class="number">58</span>a <span class="number">0</span>);</span>
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p>结果是这个样子：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-7.jpg" alt=""><br>看来得换个思路了。<br>这时候可以祭出<code>repeating-linear-gradient()</code>了，它的工作方式与<code>linear-gradient</code>类似，只有一点不同，色标是无限循环重复的，直至填满整个背景。比如：</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">45deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#58a</span> <span class="number">30px</span>)</span></span>;
</code></pre><p>就等于</p>
<pre><code>background:repeating-linear-gradient(<span class="number">45</span>deg,
                    <span class="preprocessor">#fb3,#<span class="number">58</span>a <span class="number">30</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">30</span>px,#<span class="number">58</span>a <span class="number">60</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">60</span>px,#<span class="number">58</span>a <span class="number">90</span>px,</span>
                    <span class="preprocessor">#fb3 <span class="number">90</span>px,#<span class="number">58</span>a <span class="number">120</span>px,...);</span>
</code></pre><p>45°斜向条纹就可以轻松创建了</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">45deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#fb3a</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>;
</code></pre><p>同时<code>background-size</code>也不用设置，因为长度就是直接在渐变轴上进行度量的。<br>现在试试60°的斜向条纹</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"><span class="function">repeating-linear-gradient</span>(<span class="number">60deg</span>, <span class="hexcolor">#fb3</span>,<span class="hexcolor">#fb3</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>;
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-8.jpg" alt=""></p>
<h2 id="灵活的同色系条纹">灵活的同色系条纹</h2><p>存在这样一种场景，我们想要的条纹图案并不是由差异极大的几种颜色组成的，而是由同色系但亮度不同的条纹组成。比如：</p>
<pre><code><span class="attribute">background</span>: <span class="function"><span class="title">repeating-linear-gradient</span><span class="params">(<span class="number">30deg</span>,<span class="hexcolor">#79b</span>,<span class="hexcolor">#79b</span> <span class="number">16px</span>,<span class="hexcolor">#58a</span> <span class="number">0</span>,<span class="hexcolor">#58a</span> <span class="number">32px</span>)</span></span>
</code></pre><p>是这种效果<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-9.jpg" alt=""><br>但是，如果想要修改颜色，就需要对上面的代码进行4处修改。身为懒癌患者，这是不能忍受的。于是诞生了下面这种方式：<br>先把最深的颜色指定为背景色，同时把半透明的白色条纹叠加在背景色之上来得到浅色条纹。</p>
<pre><code>background: <span class="preprocessor">#<span class="number">58</span>a;</span>
background-image: repeating-linear-gradient(<span class="number">30</span>deg,hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.1</span>),hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.1</span>) <span class="number">16</span>px,
transparent <span class="number">16</span>px, transparent <span class="number">32</span>px);
</code></pre><p>这样就舒服多了：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-10.jpg" alt=""></p>
<h1 id="复杂的背景图案">复杂的背景图案</h1><p>这里所说的复杂背景图案是指下面的网格、波点和棋盘背景。其实这些都是<code>gradient</code>的一些扩展应用。</p>
<h2 id="网格">网格</h2><p>有了上面的水平和垂直条纹，网格背景其实就是两者的结合。举个最简单的例子。</p>
<pre><code>background: white;
background-image: linear-gradient(<span class="number">90</span>deg,rgba(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>) <span class="number">50</span>%,transparent <span class="number">50</span>%),
    linear-gradient(rgba(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.5</span>) <span class="number">50</span>%,transparent <span class="number">50</span>%);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-12.jpg" alt=""><br>常用的可能会需要下面这种细线条单色网格背景。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#58a</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">linear-gradient</span>(white <span class="number">1px</span>,transparent <span class="number">1px</span>),
                      <span class="function">linear-gradient</span>(<span class="number">90deg</span>,white <span class="number">1px</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-13.jpg" alt=""></p>
<p>偶尔还可能会用到两幅不同线宽的网格图案。显得更为真实一些，比如：</p>
<pre><code>background: <span class="preprocessor">#<span class="number">58</span>a;</span>
background-image: linear-gradient(white <span class="number">2</span>px,transparent <span class="number">0</span>),
                linear-gradient(<span class="number">90</span>deg,white <span class="number">2</span>px,transparent <span class="number">0</span>),
                linear-gradient(hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.3</span>) <span class="number">1</span>px,transparent <span class="number">0</span>),
                linear-gradient(<span class="number">90</span>deg,hsla(<span class="number">0</span>,<span class="number">0</span>%,<span class="number">100</span>%,<span class="number">.3</span>) <span class="number">1</span>px,transparent <span class="number">0</span>);
background-size: <span class="number">48</span>px <span class="number">48</span>px,<span class="number">48</span>px <span class="number">48</span>px,<span class="number">16</span>px <span class="number">16</span>px,<span class="number">16</span>px <span class="number">16</span>px;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-14.jpg" alt=""></p>
<h2 id="波点">波点</h2><p>相对于网格背景，我个人更偏向于波点背景，波点背景其实是利用的径向渐变。最简单的就是圆点的阵列。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-15.jpg" alt=""><br>但是，这样看起来不是很自然。这时候可以考虑把两个径向渐变图像错位相排。</p>
<pre><code><span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#655</span></span></span>;
<span class="rule"><span class="attribute">background-image</span>:<span class="value"> <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>),
                <span class="function">radial-gradient</span>(tan <span class="number">30%</span>,transparent <span class="number">0</span>)</span></span>;
<span class="rule"><span class="attribute">background-size</span>:<span class="value"> <span class="number">32px</span> <span class="number">32px</span></span></span>;
<span class="rule"><span class="attribute">background-position</span>:<span class="value"> <span class="number">0px</span> <span class="number">0px</span>,<span class="number">16px</span> <span class="number">16px</span></span></span>; 
</code></pre><p>这样的话就比较自然了<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-16.jpg" alt=""><br>但是这段代码的可维护性确实很差，幸好Sass大法好。</p>
<pre><code><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> polka</span>(<span class="variable">$size</span>,<span class="variable">$dot</span>,<span class="variable">$base</span>,<span class="variable">$accent</span>){</span>
    <span class="attribute">background</span><span class="value">: <span class="variable">$base</span>;</span>
    <span class="attribute">background-image</span><span class="value">: <span class="function">radial-gradient</span>(<span class="variable">$accent</span> <span class="variable">$dot</span>,transparent <span class="number">0</span>),
                      <span class="function">radial-gradient</span>(<span class="variable">$accent</span> <span class="variable">$dot</span>,transparent <span class="number">0</span>);</span>
    <span class="attribute">background-size</span><span class="value">: <span class="variable">$size</span> <span class="variable">$size</span>;</span>
    <span class="attribute">background-position</span><span class="value">: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span>/<span class="number">2</span> <span class="variable">$size</span>/<span class="number">2</span>
}
@include <span class="function">polka</span>(<span class="number">32px</span>,<span class="number">30%</span>,<span class="hexcolor">#655</span>,tan);</span>
</code></pre><blockquote>
<p>每次$dot都打成$dota</p>
</blockquote>
<h2 id="棋盘">棋盘</h2><p>棋盘的话，见得并不多，调试的时候可以看见透明色就是用灰色棋盘来表示的。<br>棋盘的实现稍微复杂些，首先，利用渐变绘制出如图案：</p>
<pre><code>background: <span class="preprocessor">#eee;</span>
background-image: linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,
            transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-17.jpg" alt=""><br>这时候会发现，再绘制一份相同的背景，然后错下位就可以实现棋盘效果了。</p>
<pre><code>background: <span class="preprocessor">#eee;</span>
background-image: linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>),
                  linear-gradient(<span class="number">45</span>deg,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">25</span>%,transparent <span class="number">0</span>,transparent <span class="number">75</span>%,rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.25</span>) <span class="number">0</span>);
background-size: <span class="number">32</span>px <span class="number">32</span>px;
background-position: <span class="number">0</span> <span class="number">0</span> ,<span class="number">16</span>px <span class="number">16</span>px;
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-18.jpg" alt=""></p>
<p>当然在懒人癌的作用下，利用Sass处理下：</p>
<pre><code><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> checkerboard</span>(<span class="variable">$size</span>,<span class="variable">$base</span>,<span class="variable">$accent</span>){</span>
    <span class="attribute">background</span><span class="value">: <span class="variable">$base</span>;</span>
    <span class="attribute">background-image</span><span class="value">: <span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="variable">$accent</span> <span class="number">25%</span>,transparent <span class="number">0</span>, transparent <span class="number">75%</span>,<span class="variable">$accent</span> <span class="number">0</span>),
    <span class="function">linear-gradient</span>(<span class="number">45deg</span>,<span class="variable">$accent</span> <span class="number">25%</span>,transparent <span class="number">0</span>, transparent <span class="number">75%</span>,<span class="variable">$accent</span> <span class="number">0</span>);</span>
    <span class="attribute">background-size</span><span class="value">: <span class="number">2</span>*<span class="variable">$size</span> <span class="number">2</span>*<span class="variable">$size</span>;</span>
    <span class="attribute">background-position</span><span class="value">: <span class="number">0</span> <span class="number">0</span>, <span class="variable">$size</span> <span class="variable">$size</span>;</span>
}
<span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> checkerboard</span>(<span class="number">16px</span>,<span class="hexcolor">#eee</span>,<span class="function">rgba</span>(<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>));</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="条纹背景">条纹背景</h1><p>通常条纹背景是由一个图片来代替，或者使用SVG。能不能利用CSS直接创建条纹图案呢，答案是肯定的。<br>假设背景是垂直线性渐变。比如：<code>background:linear-gradient(#fb3,#58a);</code><br>效果是这个样子的：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-1.jpg" alt=""><br>如果让渐变区域变的更窄，产生一个无限小的渐变区域，比如：<code>background:linear-gradient(#fb3 50%,#58a 50%);</code> 就可以得到想要的结果了。<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-04-2.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret读书笔记之灵活定位&边框内圆角]]></title>
    <link href="http://blog.supce.com/2016/09/14/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D&%E8%BE%B9%E6%A1%86%E5%86%85%E5%9C%86%E8%A7%92/"/>
    <id>http://blog.supce.com/2016/09/14/CSS Secret 读书笔记之灵活定位&边框内圆角/</id>
    <published>2016-09-13T16:00:00.000Z</published>
    <updated>2016-09-14T12:27:01.556Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="灵活的背景定位">灵活的背景定位</h1><p>假设一种场景，需要对容器某个角对背景图片做偏移定位，比如说右下角。在定位的同时，也希望图片和容易边角之间能够够留出一定的空隙，以避免下图这种效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-1.jpg" alt=""><br>当容器的尺寸固定时，很好解决。但是容器的尺寸不固定时，可以利用下面三种方法来解决。<br><a id="more"></a></p>
<h2 id="background-position的扩展语法方案"><code>background-position</code>的扩展语法方案</h2><p>在CSS3中，<code>background-position</code>已经得到扩展，它允许我们指定背景图片距离任意角的偏移量。</p>
<blockquote>
<p>当然，还需要一个合适的回退方案。避免浏览器的不支持。</p>
</blockquote>
<p>代码：</p>
<pre><code>&lt;div class=<span class="string">"position"</span>&gt;
    Code Pirate
&lt;/div&gt;
.position{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">10</span>px;
    <span class="built_in">color</span>: white;
    font: <span class="number">100</span>%/<span class="number">1</span> sans-serif;
    <span class="built_in">background</span>:url(http:<span class="comment">//csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;   /*回退方案*/</span>
}
.position{
    <span class="built_in">background</span>-position: right <span class="number">10</span>% bottom <span class="number">20</span>%;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-2.jpg" alt=""></p>
<h2 id="background-origin方案"><code>background-origin</code>方案</h2><p>在上个方案中有一个缺陷，当修改容器的内边距时，需要在3处做出修改。希望有一种方式，能够让背景图片自动根据设定的内边距定位，而不用声明额外的偏移量。<br>在默认情况下<code>background-position</code>是以padding box为基准的。可以利用属性<code>background-origin</code>来改变这种行为。当把它的值设置为<code>content-box</code>时，<code>background-position</code>会以内容区边缘作为基准。此时，背景图片的距离的边角偏移量就可以和内边距保持一致了。<br>代码：</p>
<pre><code>&lt;div class=<span class="string">"origin"</span>&gt;
    Code Pirate
&lt;/div&gt;
.origin{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">10</span>px;
    <span class="built_in">color</span>: white;
    font: <span class="number">100</span>%/<span class="number">1</span> sans-serif;
    <span class="built_in">background</span>:url(http:<span class="comment">//csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a;</span>
}
.origin{
    <span class="built_in">background</span>-origin: content-<span class="built_in">box</span>;
 }
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-3.jpg" alt=""></p>
<h2 id="calc()方案"><code>calc()</code>方案</h2><p>如果想把背景图片定位到距离底边10px 距离右边20px。可以使用<code>calc()</code><br>即：<code>background-position: calc(100% - 20px) calc(100% - 10px);</code>也可以达到同样的效果。</p>
<blockquote>
<p>注意：在calc()函数内部的- + 运算符两侧需要加一个空格符，否则会产生解析错误。</p>
</blockquote>
<hr>
<h1 id="边框内圆角">边框内圆角</h1><p>考虑一种场景，需要一个容器，只在内侧有圆角，而<code>border</code>或者<code>outline</code>仍然是直角，可以用下面两种方式实现。</p>
<h2 id="嵌套容器">嵌套容器</h2><p>这个方式很简单，直接在原容器外侧嵌套一个容器，设置内部容器有圆角即可<br>代码：</p>
<pre><code>&lt;div class=<span class="string">"radius"</span>&gt;
    &lt;div&gt;
        <span class="keyword">this</span> is a test
    &lt;/div&gt;
&lt;/div&gt;
.radius{
    <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
    margin: <span class="number">20</span>px auto;
    padding: <span class="number">.8</span>em;
    <span class="built_in">background</span>: #<span class="number">655</span>;
}
.radius &gt; div{
    <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">3.4</span>em;
    <span class="built_in">background</span>: <span class="built_in">tan</span>;
    border-radius: <span class="number">.8</span>em;
    padding: <span class="number">1</span>em;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-5.jpg" alt=""></p>
<h2 id="box-shadow填充"><code>box-shadow</code>填充</h2><p>有时候，可能稍微有些强迫症，不想破坏原有的HTML结构。可以使用<code>box-shadow</code>进行颜色填充。<br>之前已经知道，<code>outline</code>并不会沿着元素的圆角走。可以在元素外侧设置<code>outline</code><br>代码如下：</p>
<pre><code>&lt;div class=<span class="string">"shadow_outline"</span>&gt;
    <span class="keyword">this</span> is a test
&lt;/div&gt;
.shadow_outline{
        <span class="built_in">max</span>-<span class="variable">width</span>: <span class="number">10</span>em;
        <span class="built_in">min</span>-<span class="variable">height</span>: <span class="number">5</span>em;
        margin: <span class="number">20</span>px auto;
        padding: <span class="number">.8</span>em;
        <span class="built_in">background</span>: <span class="built_in">tan</span>;
        border-radius: <span class="number">.8</span>em;
        outline: <span class="number">.6</span>em solid #<span class="number">655</span>;
    }
</code></pre><p>此时的效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-07.jpg" alt=""><br>会发现在四个角会有空白，这个空白可以利用<code>box-shadow</code>进行颜色填充。由几何数学可知，当圆角的半径为r时，<code>box-shadow</code>的投影扩张值不能小于(√2-1)r。上面的<code>border-radius</code>为0.8，计算得约为0.33，<br>因此只要设置<code>box-shadow: 0 0 0 .34em #655;</code>即可。<br>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-6.jpg" alt=""></p>
<blockquote>
<p>最后说句题外话，Chrome v53.0.2785.113m版本的界面挺好看，没错，我就是扁平脑残粉。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="灵活的背景定位">灵活的背景定位</h1><p>假设一种场景，需要对容器某个角对背景图片做偏移定位，比如说右下角。在定位的同时，也希望图片和容易边角之间能够够留出一定的空隙，以避免下图这种效果：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/secret-03-1.jpg" alt=""><br>当容器的尺寸固定时，很好解决。但是容器的尺寸不固定时，可以利用下面三种方法来解决。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之半透明与多重边框]]></title>
    <link href="http://blog.supce.com/2016/09/13/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%8A%E9%80%8F%E6%98%8E%E4%B8%8E%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86/"/>
    <id>http://blog.supce.com/2016/09/13/CSS Secret 读书笔记之半透明与多重边框/</id>
    <published>2016-09-12T16:00:00.000Z</published>
    <updated>2016-09-13T13:04:59.411Z</updated>
    <content type="html"><![CDATA[<h1 id="半透明边框">半透明边框</h1><p>由于背景色会侵入到边框所在的范围，如果想要半透明的边框，可以使用<code>background-clip</code>属性。这个属性规定背景的绘制区域，其初始值为<code>border-box</code>，如果将属性值设置为<code>padding-box</code>，背景就会被裁剪到内边距框。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;
        this <span class="keyword">is</span> a test
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><a id="more"></a>
<p>CSS代码：</p>
<pre><code><span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
<span class="class">.test</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">50px</span> auto</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">10px</span> solid <span class="function">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">100%</span>,.<span class="number">5</span>)</span></span>;
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">background-clip</span>:<span class="value"> padding-box</span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran1.jpg" alt=""></p>
<h1 id="多重边框">多重边框</h1><p>想要使用多重边框，但是又不想添加无用的额外元素破坏HTML结构。可以使用<code>box-shadow</code>或者<code>outline</code>来模拟多重边框。</p>
<h2 id="box-shadow方案"><code>box-shadow</code>方案</h2><p>想要模拟多重边框，可以利用<code>box-shadow</code>的第四个参数，用来设置阴影的尺寸。一个正值的阴影加上两个为零的偏移量以及为零的模糊值，得到的效果就像一道实线的边框。</p>
<blockquote>
<p>恰巧，box-shadow支持都好分隔语法，可以创建任意数量的阴影。</p>
</blockquote>
<p>于是可以模拟出多重边框。例如：<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box-shadow-test"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code>.box-shadow-test{
    margin: <span class="number">50</span>px <span class="keyword">auto</span>;
    padding: <span class="number">0</span>;
    width: <span class="number">50</span>px;
    height: <span class="number">50</span>px;
}
.box-shadow-test{
    background: <span class="preprocessor">#<span class="number">6</span>b0;</span>
    box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span>px <span class="preprocessor">#<span class="number">655</span>,</span>
    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px deeppink,
    <span class="number">0</span>px <span class="number">2</span>px <span class="number">5</span>px <span class="number">15</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">.6</span>)</span></span>;
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran2.jpg" alt=""></p>
<h2 id="outline方案"><code>outline</code>方案</h2><p><code>box-shadow</code>虽然可以模拟边框，但是有一个缺陷，就是只能模拟实线边框，不能模拟出虚线边框。而且，可以设置<code>outline-offset</code>属性来控制它和元素边缘之间的间距，如果设置成负值可以模拟出缝边效果。比如：<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"outline-a"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.outline-a</span><span class="rules">{
        <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">50px</span> auto</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> yellowgreen</span></span>;
        <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">10px</span> solid <span class="hexcolor">#655</span></span></span>;
        <span class="rule"><span class="attribute">outline</span>:<span class="value"> <span class="number">1px</span> dashed deeppink</span></span>;
        <span class="rule"><span class="attribute">outline-offset</span>:<span class="value"> -<span class="number">5px</span></span></span>;
        <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">5px</span></span></span>;
    }</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran3.jpg" alt=""></p>
<blockquote>
<p>可以看出来，使用outline方案，适用于两层边框的场景。如果需要更多的边框，只能使用box-shadow方案了。</p>
</blockquote>
<p><code>outline</code>还有一个缺陷，<code>outline</code>模拟的边框并不能贴合<code>border-radius</code>产生圆角。比如：</p>
<p>代码：</p>
<pre><code>&lt;div class="outline-b"&gt;&lt;/div&gt;
.outline-b{
    margin: 50px auto<span class="comment">;</span>
    padding: 0<span class="comment">;</span>
    width: 50px<span class="comment">;</span>
    height: 50px<span class="comment">;</span>
    background: yellowgreen<span class="comment">;</span>
    border: 10px solid #655<span class="comment">;</span>
    outline: 5px solid deeppink<span class="comment">;</span>
    border-radius: 5px<span class="comment">;</span>
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/tran4.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="半透明边框">半透明边框</h1><p>由于背景色会侵入到边框所在的范围，如果想要半透明的边框，可以使用<code>background-clip</code>属性。这个属性规定背景的绘制区域，其初始值为<code>border-box</code>，如果将属性值设置为<code>padding-box</code>，背景就会被裁剪到内边距框。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;
        this <span class="keyword">is</span> a test
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS Secret 读书笔记之弹性布局]]></title>
    <link href="http://blog.supce.com/2016/09/12/CSS%20Secret%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.supce.com/2016/09/12/CSS Secret 读书笔记之弹性布局/</id>
    <published>2016-09-11T16:00:00.000Z</published>
    <updated>2016-09-12T13:12:20.547Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在CSS Secret中提到了弹性布局，这里就简单写了四个实例来回顾下弹性布局</p>
</blockquote>
<h1 id="居中">居中</h1><p>可以利用<code>flex</code>，让子容器在父容器中居中。设置父容器<code>display</code>属性为<code>flex</code>，并设置子容器<code>margin</code>属性为<code>auto</code>即可。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child"</span>&gt;
            child
        &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.parent</span>,<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
}</span>
<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
</code></pre><a id="more"></a>
<p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex0.jpg" alt=""></p>
<h1 id="自适应列表">自适应列表</h1><p>有一组列表，有固定的宽度，但是想让它们能够根据浏览器窗口的大小进行自适应调整，可以使用弹性布局。<br>HTML代码：</p>
<pre><code>&lt;ul <span class="keyword">class</span>=<span class="string">"flex-container"</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;2&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;3&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;4&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;5&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"flex-item"</span>&gt;6&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.flex-container</span><span class="rules">{
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> row wrap</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
}</span>
<span class="class">.flex-item</span><span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> tomato</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">10px</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">3em</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
}</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex1.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex2.jpg" alt=""></p>
<h1 id="自适应导航">自适应导航</h1><p>为了适应移动端的屏幕尺寸，可以根据屏幕由小到大依次设置为多行居中、单行居中以及单行左(右)对齐。<br>HTML代码：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"navigation"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Details<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span>&gt;</span>About<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.navigation</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">1em</span> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;

    <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> flex-end</span></span>;

}</span>
<span class="class">.navigation</span> <span class="tag">a</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">1em</span></span></span>; 
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="class">.navigation</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover{
    background: tomato</span></span>;
}
<span class="at_rule">@<span class="keyword">media</span> all and (max-width: <span class="number">800px</span>)</span>{
    <span class="class">.navigation</span><span class="rules">{
        <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> space-around</span></span>;
    }</span>
}
<span class="at_rule">@<span class="keyword">media</span> all and (max-width: <span class="number">600px</span>)</span>{
    <span class="class">.navigation</span><span class="rules">{
        <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> column wrap</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; 
    }</span>
    <span class="class">.navigation</span> <span class="tag">a</span><span class="rules">{
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">border-top</span>:<span class="value"> <span class="number">1px</span> solid <span class="function">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.3</span>)</span></span>;
        <span class="rule"><span class="attribute">border-bottom</span>:<span class="value"> <span class="number">1px</span> solid <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>)</span></span>;
    }</span>
}
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex3.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex4.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex5.jpg" alt=""></p>
<h1 id="自适应布局">自适应布局</h1><p>最后来一个很常用的自适应布局，主要用于适应移动端的屏幕尺寸。整体思路大概是先考虑移动端，设置所有<code>div</code>的宽度为100%；在中等屏幕中设置两个侧边栏在同一行；在宽屏中，设置左侧边栏在主要内容左侧，右侧边栏在主要内容右侧。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"wrapper"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"header"</span>&gt;Header&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;
        &lt;p&gt;this <span class="keyword">is</span> main作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。&lt;/p&gt;
    &lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"aside aside-1"</span>&gt;aside-<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"aside aside-2"</span>&gt;aside-<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;footer <span class="type">class</span>=<span class="string">"footer"</span>&gt;this <span class="keyword">is</span> footer&lt;/footer&gt;      
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.header</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> tomato</span></span>;
    }</span>
    <span class="class">.footer</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> lightgreen</span></span>;
    }</span>
    <span class="class">.main</span> <span class="rules">{
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> left</span></span>;
        <span class="rule"><span class="attribute">background</span>:<span class="value"> deepskyblue</span></span>;
    }</span>
    <span class="class">.aside-1</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> gold</span></span>;
    }</span>
    <span class="class">.aside-2</span> <span class="rules">{
        <span class="rule"><span class="attribute">background</span>:<span class="value"> hotpink</span></span>;
    }</span>
    <span class="comment">/*移动端*/</span>
    <span class="class">.wrapper</span> &gt; * <span class="rules">{
        <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>;
        <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span> <span class="number">100%</span></span></span>;
    }</span>
    <span class="comment">/*中等屏幕*/</span>
    <span class="at_rule">@<span class="keyword">media</span> all and (min-width: <span class="number">600px</span>)</span>{
        <span class="class">.aside</span><span class="rules">{
            <span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">1</span> auto</span></span>;
        }</span>
    }
    <span class="comment">/*宽屏*/</span>
    <span class="at_rule">@<span class="keyword">media</span> all and (min-width: <span class="number">800px</span>)</span>{
        <span class="class">.main</span> <span class="rules">{<span class="rule"><span class="attribute">flex</span>:<span class="value"> <span class="number">2</span> <span class="number">0</span></span></span>;}</span> <span class="comment">/*扩大比例为2缩小比例为0*/</span>
        <span class="class">.aside-1</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">1</span></span></span>;}</span>
        <span class="class">.main</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"> <span class="number">2</span></span></span>;}</span>
        <span class="class">.aside-2</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"><span class="number">3</span></span></span>;}</span>
        <span class="class">.footer</span> <span class="rules">{<span class="rule"><span class="attribute">order</span>:<span class="value"><span class="number">4</span></span></span>;}</span>
    }
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex6.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex7.jpg" alt=""><br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/flex8.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在CSS Secret中提到了弹性布局，这里就简单写了四个实例来回顾下弹性布局</p>
</blockquote>
<h1 id="居中">居中</h1><p>可以利用<code>flex</code>，让子容器在父容器中居中。设置父容器<code>display</code>属性为<code>flex</code>，并设置子容器<code>margin</code>属性为<code>auto</code>即可。<br>HTML代码：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;
        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child"</span>&gt;
            child
        &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>CSS代码：</p>
<pre><code><span class="class">.parent</span>,<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid <span class="hexcolor">#333</span></span></span>;
}</span>
<span class="class">.parent</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>;
}</span>
<span class="class">.child</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
}</span>
</code></pre>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://blog.supce.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM(二)]]></title>
    <link href="http://blog.supce.com/2016/07/26/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%8011/"/>
    <id>http://blog.supce.com/2016/07/26/JavaScript之基础11/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2016-07-28T03:25:22.829Z</updated>
    <content type="html"><![CDATA[<hr>
<blockquote>
<p>这里主要记录下DOM基于CSS选择符和HTML5的一些扩展。</p>
</blockquote>
<h1 id="基于CSS选择符的扩展">基于CSS选择符的扩展</h1><p>有时候需要通过 CSS 选择符查询 DOM 文档取得元素的引用，可以使用以下两种方法：</p>
<ul>
<li><p><code>querySelector()</code></p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>this is header<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer"</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"#header"</span>).firstChild.nodeValue);
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"this is a paragraph."</span>);
<span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).appendChild(text);
<span class="comment">//获取类为footer的第一个元素</span>
<span class="built_in">document</span>.body.querySelector(<span class="string">".footer"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre></li>
</ul>
<a id="more"></a>
<p><code>querySelector()</code>方法接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，返回null。</p>
<ul>
<li><p><code>querySelectorAll()</code></p>
<pre><code><span class="comment">//取得某&lt;div&gt;中的所有&lt;em&gt;元素(类似于getElementsByTagName("em"))</span>
<span class="keyword">var</span> ems = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).<span class="built_in">querySelectorAll</span>(<span class="string">"em"</span>);
</code></pre></li>
</ul>
<p><code>querySelectorAll()</code>方法接收的参数与<code>querySelector()</code>方法一样，都是一个CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个NodeList的实例。如果没有找到匹配的元素，NodeList就是空的。</p>
<p><em>要取得返回的NodeList中的每一个元素，可以使用item()方法，也可以使用方括号语法</em></p>
<ul>
<li><p><code>matchesSelector()</code><br>这个方法接收参数为CSS选择符，如果调用元素与该选择符匹配，返回true，否则，返回false。<br>为了兼容其他浏览器，可以这样写：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">matchesSelector</span><span class="params">(element, selector)</span>{</span>
    <span class="keyword">if</span><span class="params">(element.matches)</span>{
        return element.matches<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.matchesSelector)</span>{
        return element.matchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.webkitMatchesSelector)</span>{
        return element.webkitMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.msMatchesSelector)</span>{
        return element.msMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.mozMatchesSelector)</span>{
        return element.mozMatchesSelector<span class="params">(selector)</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span><span class="params">(element.oMatchesSelector)</span>{
        return element.oMatchesSelector<span class="params">(selector)</span>;
    }
}
</code></pre></li>
</ul>
<p>这个方法在做事件委托时可以用到，比如：</p>
<pre><code><span class="built_in">document</span>.querySelector(<span class="string">'#wrap'</span>).addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>{
    <span class="keyword">if</span>(matchesSelector(e.target,<span class="string">'a.btn'</span>)){
        alert(<span class="string">"do someting"</span>);
        <span class="built_in">console</span>.log(<span class="string">"do something"</span>);
        e.preventDefault();
        <span class="comment">//TODO something</span>
    }
    <span class="keyword">else</span>{
        alert(<span class="string">"..."</span>);
    }
},<span class="literal">false</span>);
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"wrap"</span>&gt;
    &lt;a <span class="type">class</span>=<span class="string">"btn"</span> href=<span class="string">"http://blog.supce.com"</span>&gt;点我&lt;/a&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><hr>
<h1 id="元素的遍历">元素的遍历</h1><p>对于元素间的空格，IE9及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。之前写过一个删除空白文本节点的函数。为了解决元素访问的一致性问题，DOM也提供了一种方法：</p>
<ul>
<li>childElementCount 返回不包括文本节点和注释的元素个数</li>
<li>firstElementChild 返回第一个子元素</li>
<li>lastElementChild 返回最后一个子元素</li>
<li>previousElementSibling 返回前一个同辈元素</li>
<li>nextElementSibling 返回后一个同辈元素</li>
</ul>
<p>利用这些属性可以更方便的忽视空白元素进行元素的相关操作了。</p>
<hr>
<h1 id="基于HTML5的扩展">基于HTML5的扩展</h1><p><em>HTML5对DOM节点的相关操作进行了扩展</em></p>
<h2 id="与类相关的扩展">与类相关的扩展</h2><p>为了更方便的利用JavaScript操作CSS类，比如动态修改类或者获取给定类的引用，HTML增加了一些API。</p>
<h3 id="getElementsByClassName方法"><code>getElementsByClassName</code>方法</h3><p><code>getElementsByClassName()</code>方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。比如：</p>
<pre><code><span class="keyword">var</span> test_class = document.getElementsByClassName('test');
console.log(test_class); //[<span class="keyword">div</span>.test, <span class="keyword">div</span>.test.demo]
<span class="literal">result</span> = document.getElementsByClassName('test demo');
console.log(<span class="literal">result</span>); //[<span class="keyword">div</span>.test.demo]
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"demo"</span>&gt;this <span class="keyword">is</span> a demo&lt;/<span class="keyword">div</span>&gt;
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test demo"</span>&gt;this <span class="keyword">is</span> a test <span class="keyword">and</span> demo&lt;/<span class="keyword">div</span>&gt;
</code></pre><h3 id="classList属性"><code>classList</code>属性</h3><p>上面的方法可以根据类名获取元素的引用，而利用<code>classList</code>属性可以对类名进行增删与替换，该属性包含以下几种方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>classList.remove()</td>
<td>删除元素中某个类名</td>
</tr>
<tr>
<td>classList.add()</td>
<td>在元素中添加某个类名</td>
</tr>
<tr>
<td>classList.toggle()</td>
<td>如果类名列表中已经存在给定的值，删除它；如果没有给定的值，添加它。</td>
</tr>
<tr>
<td>classList.contains()</td>
<td>表示类名列表中是否存在给定的值，如果存在则返回 true ，否则返回 false</td>
</tr>
</tbody>
</table>
<p>举个改变div背景色的例子：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
    test.classList.toggle(<span class="string">'red'</span>);
    <span class="built_in">console</span>.log(<span class="string">"done"</span>);
}
</code></pre><p>HTML代码为：</p>
<pre><code>&lt;<span class="tag">div</span> id=<span class="string">"test"</span> class=<span class="string">"red"</span>&gt;this is <span class="tag">a</span> test&lt;/div&gt;
&lt;<span class="tag">button</span> id=<span class="string">"btn"</span> onclick=<span class="string">"changeColor()"</span>&gt;change <span class="attribute">color</span>&lt;/button&gt;
</code></pre><p>CSS代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
    <span class="id">#test</span><span class="rules">{
        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">150px</span></span></span>;
        <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
        <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
        <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
    }</span>
    <span class="class">.red</span><span class="rules">{
        <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red <span class="important">!important</span></span></span>;
    }</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre><p>考虑到兼容性问题，可以封装一个函数：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">classOperate</span><span class="params">(div,name,operate)</span></span>{
    <span class="keyword">var</span> <span class="keyword">list</span> = div.classList;
    <span class="keyword">if</span>(<span class="keyword">list</span>){
        <span class="keyword">switch</span>(operate){
            <span class="keyword">case</span> <span class="string">'add'</span>:
                <span class="keyword">list</span>.add(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'remove'</span>:
                <span class="keyword">list</span>.remove(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'contains'</span>:
                <span class="keyword">return</span> <span class="keyword">list</span>.contains(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'toggle'</span>:
                <span class="keyword">list</span>.toggle(name);
                <span class="keyword">break</span>;
        }
    }<span class="keyword">else</span>{
        <span class="keyword">switch</span>(operate){
            <span class="keyword">case</span> <span class="string">'add'</span>:
                addName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'remove'</span>:
                removeName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'contains'</span>:
                containName(name);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">'toggle'</span>:
                <span class="keyword">if</span>(containName(name)){
                    removeName(name);
                }<span class="keyword">else</span>{
                    addName(name);
                }
                <span class="keyword">break</span>;
        }
    }
    <span class="function"><span class="keyword">function</span> <span class="title">addName</span><span class="params">(name)</span></span>{
        div.className += (<span class="string">' '</span> + name);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">removeName</span><span class="params">(name)</span></span>{
        <span class="keyword">var</span> classNames = div.className.split(/\s+/);
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;classNames.length;i++){
            <span class="keyword">if</span>(classNames[i] == name){
                <span class="keyword">break</span>;
            }
        }
        classNames.splice(i,<span class="number">1</span>);
        div.className = classNames.join(<span class="string">' '</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">containName</span><span class="params">(name)</span></span>{
        <span class="keyword">var</span> classNames = div.className.split(/\s+/);
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;classNames.length;i++){
            <span class="keyword">if</span>(classNames[i] == name){
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre><h2 id="焦点管理">焦点管理</h2><p>HTML5增加了辅助管理DOM焦点的功能。</p>
<ul>
<li><p><code>document.activeElement</code>属性<br>这个属性会引用DOM中当前获得了焦点的元素。比如：</p>
<pre><code><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);
btn.focus();
<span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === btn);<span class="comment">//true</span>
</code></pre></li>
</ul>
<blockquote>
<p>默认情况下,文档刚刚加载完成时，<code>document.activeElement</code> 中保存的是 <code>document.body</code> 元素的引用。文档加载期间，<code>document.activeElement</code>的值为 null 。</p>
</blockquote>
<ul>
<li><code>document.hasFocus()</code>方法</li>
</ul>
<p>这个方法用于确定文档是否获得了焦点。比如：</p>
<pre><code><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);
btn.focus();
<span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus());<span class="comment">//true</span>
</code></pre><h2 id="HTMLDocument的变化">HTMLDocument的变化</h2><p>HTML5 同时也扩展了 HTMLDocument ，增加了一些新的功能</p>
<h3 id="readyState属性"><code>readyState</code>属性</h3><p>Document 的 readyState 属性有两个可能的值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>loading</td>
<td>正在加载文档</td>
</tr>
<tr>
<td>complete</td>
<td>已经加载完文档</td>
</tr>
</tbody>
</table>
<p>一般会这样使用：</p>
<pre><code><span class="keyword">if</span>(<span class="built_in">document</span>.readyState == <span class="string">'complete'</span>){
    <span class="regexp">//</span><span class="keyword">do</span> something
}
</code></pre><h3 id="兼容模式">兼容模式</h3><p>自从IE6开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能。为此给 document 添加了一个名为 compatMode的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式在标准模式下， document.compatMode 的值等于 “CSS1Compat” ，而在混杂模式下，document.compatMode 的值等于 “BackCompat” 。</p>
<pre><code><span class="keyword">if</span><span class="params">(document.compatMode == <span class="string">"CSS1Compat"</span>)</span>{
    alert<span class="params">(<span class="string">"Standards mode"</span>)</span>;
}<span class="keyword">else</span>{
    alert<span class="params">(<span class="string">"Quirks mode"</span>)</span>;
}
</code></pre><h3 id="head属性"><code>head</code>属性</h3><p>HTML5 新增了 document.head 属性</p>
<pre><code><span class="keyword">var</span> head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];
</code></pre><h2 id="字符集属性">字符集属性</h2><p>HTML5 新增了几个与文档字符集有关的属性</p>
<ul>
<li><code>charset</code>属性</li>
</ul>
<p>charset 属性表示文档中实际使用的字符集，也可以用来指定新字符集。</p>
<ul>
<li><code>defaultCharset</code>属性</li>
</ul>
<p>该属性表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。</p>
<blockquote>
<p>如果文档没有使用默认字符集,charset和defaultCharset属性的值可能会不一样</p>
</blockquote>
<h2 id="自定义数据属性">自定义数据属性</h2><p>HTML5规定可以为元素添加非标准的属性，但要添加前缀 <code>data-</code>，比如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"test"</span> data-myname=<span class="string">"demo"</span>&gt;this <span class="keyword">is</span> a test&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>同时可以获取或者设置自定义数据的值</p>
<pre><code><span class="keyword">var</span> <span class="keyword">test</span> = document.getElementById('<span class="keyword">test</span>');
console.<span class="literal">log</span>(<span class="keyword">test</span>.dataset.myname);<span class="comment">//demo</span>
<span class="keyword">test</span>.dataset.myname = <span class="string">"newName"</span>;
console.<span class="literal">log</span>(<span class="keyword">test</span>.dataset.myname);<span class="comment">//newName</span>
</code></pre><h2 id="插入标记">插入标记</h2><p>有时候可能需要向文档中插入大量新的HTML标记，如果使用DOM创建一系列节点，并按正确顺序连接起来还是比较麻烦的。而使用下面几个属性和方法可以更简单，迅速的将标记插入到文本中。</p>
<h3 id="innerHTML属性">innerHTML属性</h3><p>在读模式下，innerHTML属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.innerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom3.jpg-blogImg" alt=""><br>在写模式下，innerHTML的值会被解析为DOM子树，替换调用元素原来的所有子节点。因为它的值被认为是HTML，所以其中的所有标签都会按照浏览器处理HTML的标准方式转换为元素。如果设置的值仅是文本而没有 HTML标签，那么结果就是设置纯文本。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.innerHTML);
test.innerHTML = <span class="string">"Hello &amp; welcome &lt;br /&gt; this is a test!"</span>;
<span class="built_in">console</span>.log(test.innerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom4.jpg-blogImg" alt=""></p>
<h3 id="outerHTML属性">outerHTML属性</h3><p>在读模式下，outerHTML返回调用它的元素及所有子节点的HTML标签。比如：</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a test&lt;/p&gt;
    &lt;p&gt;<span class="keyword">this</span> <span class="keyword">is</span> a demo&lt;/p&gt;
&lt;/div&gt;
<span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);
<span class="built_in">console</span>.log(test.outerHTML);
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom5.jpg-blogImg" alt=""><br>在写模式下， outerHTML会根据指定的 HTML 字符串创建新的 DOM子树，然后用这个 DOM 子树完全替换调用元素。比如：<br>使用 outerHTML 属性以下面这种方式设置值：<br><code>div.outerHTML = &quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;;</code><br>这行代码完成的操作与下面这些 DOM 脚本代码一样：</p>
<pre><code>var p = document.createElement<span class="params">(<span class="string">"p"</span>)</span>;
p.appendChild<span class="params">(document.createTextNode<span class="params">(<span class="string">"This is a paragraph."</span>)</span>)</span>;
div.parentNode.replaceChild<span class="params">(p, div)</span>;
</code></pre><p>结果，就是新创建的<code>&lt;p&gt;</code>元素会取代DOM树中的<code>&lt;div&gt;</code>元素。</p>
<h3 id="insertAdjacentHTML()方法">insertAdjacentHTML()方法</h3><p>该接收两个参数：插入位置和要插入的 HTML 文本。第一个参数必须是下列值之一：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforebegin</td>
<td>在当前元素之前插入一个紧邻的同辈元素</td>
</tr>
<tr>
<td>afterbegin</td>
<td>在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素</td>
</tr>
<tr>
<td>beforeend</td>
<td>在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素</td>
</tr>
<tr>
<td>afterend</td>
<td>在当前元素之后插入一个紧邻的同辈元素</td>
</tr>
</tbody>
</table>
<p><em>注意，这些值都必须是小写形式</em></p>
<p>第二个参数是一个HTML字符串，如果浏览器无法解析该字符串，就会抛出错误。比如：</p>
<pre><code><span class="comment">//作为前一个同辈元素插入</span>
element.insertAdjacentHTML<span class="params">(<span class="string">"beforebegin"</span>, <span class="string">"&lt;p&gt;Hello world!&lt;/p&gt;"</span>)</span>;
</code></pre><h2 id="scrollIntoView方法"><code>scrollIntoView</code>方法</h2><p>scrollIntoView()方法，通过滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果参数为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。<br>可以写一个导航栏固定，点击导航栏滚动到相应<code>div</code>的小例子：</p>
<p>HTML代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"nav"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"floatFix"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"red"</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
            <span class="tag">&lt;<span class="title">li</span>&gt;</span>第三部分<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"first_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第一部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"sec_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第二部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"third_section"</span> <span class="attribute">class</span>=<span class="value">"section"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>第三部分<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p>CSS代码为：</p>
<pre><code><span class="tag">&lt;<span class="title">style</span> <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span><span class="css">
*<span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;
}</span>
<span class="id">#header</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;        
    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="function">rgb</span>(<span class="number">83</span>,<span class="number">83</span>,<span class="number">83</span>)</span></span>;
}</span>
<span class="id">#nav</span><span class="rules">{
    <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto auto</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">60%</span></span></span>;
}</span>
<span class="id">#nav</span> <span class="tag">ul</span><span class="rules">{
    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;
    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;
}</span>
<span class="id">#nav</span> <span class="tag">li</span><span class="rules">{
    <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">30%</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">50px</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="rule"><span class="attribute">.floatFix</span>:<span class="value">after{
    clear: both</span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
    <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>;
    <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">""</span></span></span>;
    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;
    ;<span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">0</span></span></span>;
}
<span class="class">.section</span><span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;
    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> white</span></span>;
}</span>
<span class="id">#first_section</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;
}</span>
<span class="id">#sec_section</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
}</span>
<span class="id">#third_section</span><span class="rules">{
<span class="rule"><span class="attribute">background-color</span>:<span class="value"> yellow</span></span>;
}</span>
<span class="class">.red</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> red</span></span>;
}</span>
<span class="class">.green</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> green</span></span>;
}</span>
<span class="class">.yellow</span><span class="rules">{
    <span class="rule"><span class="attribute">background-color</span>:<span class="value"> yellow</span></span>;
}</span>
</span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
</code></pre><p>JavaScript代码：</p>
<pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>{
        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
    }
    <span class="keyword">var</span> client_height = screen.availHeight;
    <span class="keyword">var</span> array = [$(<span class="string">'first_section'</span>),$(<span class="string">'sec_section'</span>),$(<span class="string">'third_section'</span>)];
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){
        <span class="built_in">console</span>.log(array[i]);
        array[i].style.height = (client_height - <span class="number">50</span>) + <span class="string">"px"</span>;
        array[i].style.lineHeight = (client_height - <span class="number">50</span>) + <span class="string">"px"</span>;
    }
    <span class="keyword">var</span> li = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);
    li[<span class="number">0</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">"red"</span>;
        li[<span class="number">1</span>].className = <span class="string">" "</span>;
        li[<span class="number">2</span>].className = <span class="string">" "</span>;
        $(<span class="string">'first_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
    li[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">" "</span>;
        li[<span class="number">1</span>].className = <span class="string">"green"</span>;
        li[<span class="number">2</span>].className = <span class="string">" "</span>;
        $(<span class="string">'sec_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
    li[<span class="number">2</span>].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        li[<span class="number">0</span>].className = <span class="string">" "</span>;
        li[<span class="number">1</span>].className = <span class="string">" "</span>;
        li[<span class="number">2</span>].className = <span class="string">"yellow"</span>;
        $(<span class="string">'third_section'</span>).scrollIntoView(<span class="literal">false</span>);
    }
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom6.jpg-blogImg" alt=""></p>
<blockquote>
<p>文章导图</p>
</blockquote>
<p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/DOM2.png-blogImg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<blockquote>
<p>这里主要记录下DOM基于CSS选择符和HTML5的一些扩展。</p>
</blockquote>
<h1 id="基于CSS选择符的扩展">基于CSS选择符的扩展</h1><p>有时候需要通过 CSS 选择符查询 DOM 文档取得元素的引用，可以使用以下两种方法：</p>
<ul>
<li><p><code>querySelector()</code></p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"header"</span>&gt;</span>this is header<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"footer"</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"#header"</span>).firstChild.nodeValue);
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"this is a paragraph."</span>);
<span class="built_in">document</span>.querySelector(<span class="string">"p"</span>).appendChild(text);
<span class="comment">//获取类为footer的第一个元素</span>
<span class="built_in">document</span>.body.querySelector(<span class="string">".footer"</span>);
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre></li>
</ul>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DOM(一)]]></title>
    <link href="http://blog.supce.com/2016/07/24/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%8010/"/>
    <id>http://blog.supce.com/2016/07/24/JavaScript之基础10/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2016-07-24T12:31:16.805Z</updated>
    <content type="html"><![CDATA[<hr>
<p>DOM是document object model的缩写，即：文档对象模型。DOM将HTML和XML描述为一个具有层次结构的节点树。DOM作为一个接口，可以对HTML或者XML进行添加，删除和修改。<br>根据 DOM，HTML 文档中的每个成分都是一个节点。DOM 是这样规定的： </p>
<ul>
<li>整个文档是一个文档节点 </li>
<li>每个 HTML 标签是一个元素节点 </li>
<li>包含在 HTML 元素中的文本是文本节点 </li>
<li>每一个 HTML 属性是一个属性节点 </li>
<li>注释属于注释节点<a id="more"></a>
</li>
</ul>
<h1 id="节点类型">节点类型</h1><p>JavaScript中总共有12种节点类型，这些节点类型全部继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。<br>节点类型有在Node类型中定义的12个数值常量来表示：</p>
<pre><code>Node<span class="class">.ELEMENT_NODE</span> (<span class="number">1</span>)
Node<span class="class">.ATTRIBUTE_NODE</span> (<span class="number">2</span>)
Node<span class="class">.TEXT_NODE</span> (<span class="number">3</span>)
Node<span class="class">.CDATA_SECTION_NODE</span> (<span class="number">4</span>)
Node<span class="class">.ENTITY_REFERENCE_NODE</span> (<span class="number">5</span>)
Node<span class="class">.ENTITY_NODE</span> (<span class="number">6</span>)
Node<span class="class">.PROCESSING_INSTRUCTION_NODE</span> (<span class="number">7</span>)
Node<span class="class">.COMMENT_NODE</span> (<span class="number">8</span>)
Node<span class="class">.DOCUMENT_NODE</span> (<span class="number">9</span>)
Node<span class="class">.DOCUMENT_TYPE_NODE</span> (<span class="number">10</span>)
Node<span class="class">.DOCUMENT_FRAGMENT_NODE</span> (<span class="number">11</span>)
Node<span class="class">.NOTATION_NODE</span> (<span class="number">12</span>)
</code></pre><h2 id="常用属性">常用属性</h2><h3 id="nodeType属性">nodeType属性</h3><p>每个节点都有一个nodeType属性，可以确定节点的类型。</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"test"</span>&gt;<span class="keyword">div</span>&lt;/<span class="keyword">div</span>&gt;
var test = document.getElementById(<span class="string">"test"</span>);
<span class="keyword">if</span>(test.nodeType == <span class="number">1</span>){
    console.<span class="command">log</span>(<span class="string">"This node is an element"</span>);
}
</code></pre><h3 id="nodeName属性">nodeName属性</h3><p>nodeName属性保存的是元素的标签名</p>
<pre><code>&lt;div id=<span class="string">"test"</span>&gt;div&lt;/div&gt;
<span class="keyword">var</span> <span class="keyword">test</span> = document.getElementById(<span class="string">"test"</span>);
<span class="keyword">if</span>(<span class="keyword">test</span>.nodeType == 1){
    console.<span class="literal">log</span>(<span class="keyword">test</span>.nodeName);  <span class="comment">//DIV</span>
}
</code></pre><h2 id="节点关系">节点关系</h2><p>节点的关系类似于家谱。<br>每个节点都有一个childNodes属性来表示子节点，其中保存着一个NodeList对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置或者<code>item()</code>方法来访问这些节点。</p>
<pre><code><span class="variable"><span class="keyword">var</span> firstChild</span> = someNode.childNodes[<span class="number">0</span>];
<span class="variable"><span class="keyword">var</span> secondChild</span> = someNode.childNodes.item(<span class="number">2</span>);
<span class="variable"><span class="keyword">var</span> length</span> = someNode.childNodes.length;
</code></pre><p><em>请注意，虽然可以通过方括号语法来访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。可以通过一个函数把它转换为数组</em></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">convert2Array</span><span class="params">(nodes)</span></span>{
    <span class="keyword">try</span>{
        <span class="keyword">return</span> <span class="keyword">Array</span>.prototype.slice.call(nodes,<span class="number">0</span>);
    }<span class="keyword">catch</span>(ex){
        <span class="keyword">var</span> <span class="keyword">array</span> = [];
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nodes.length;i++){
            <span class="keyword">array</span>[i] = nodes[i];
        }
        <span class="keyword">return</span> <span class="keyword">array</span>;
    }
}
console.log(convert2Array({length:<span class="number">2</span>,<span class="number">0</span>:<span class="string">'first'</span>,<span class="number">1</span>:<span class="string">'second'</span>})); <span class="comment">//["first", "second"]</span>
</code></pre><p>还有一些其他关系</p>
<ul>
<li>parentNode 父节点</li>
<li>previousSibling 该节点的前一个兄弟节点</li>
<li>nextSibling 该节点的后一个兄弟节点</li>
</ul>
<h2 id="节点操作">节点操作</h2><h3 id="appendChild()">appendChild()</h3><p>该方法用于向childNodes列表末尾添加一个节点。返回值为新增的节点。比如：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = document.createElement(<span class="string">"li"</span>);
item.appendChild(document.createTextNode(<span class="string">"itme3"</span>));
<span class="keyword">list</span>.appendChild(item);   <span class="comment">//向ul中添加了一个li</span>
</code></pre><p>如果传入到 appendChild() 中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。比如将item1与item2互换：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = <span class="keyword">list</span>.childNodes[1];  <span class="comment">//0为空白文本节点</span>
<span class="keyword">list</span>.appendChild(item);
</code></pre><p>有时候，空白文本几点会影响操作，可以写一个函数把空白文本节点删除。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">cleanWhitespace</span><span class="params">(element)</span>{</span>   
    <span class="keyword">for</span><span class="params">(var i=<span class="number">0</span>; i&lt;element.childNodes.length; i++)</span>   
    {   
        var node = element.childNodes[i];   
        <span class="keyword">if</span><span class="params">(node.nodeType == <span class="number">3</span> &amp;&amp; !/\S/.test<span class="params">(node.nodeValue)</span>)</span>   
        {   
            node.parentNode.removeChild<span class="params">(node)</span>;   
        }   
    }   
} 
</code></pre><h3 id="insertBefore()">insertBefore()</h3><p>这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)，同时被方法返回。如果参照节点是null则<code>insertBefore()</code>与<code>appendChild()</code>执行相同的操作。比如在item1前面插入item0：</p>
<pre><code>&lt;ul id=<span class="string">"list"</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item1&lt;/<span class="keyword">li</span>&gt;
    &lt;<span class="keyword">li</span>&gt;item2&lt;/<span class="keyword">li</span>&gt;
&lt;/ul&gt;
<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);
<span class="keyword">var</span> item = document.createElement(<span class="string">"li"</span>);
item.appendChild(document.createTextNode(<span class="string">"item0"</span>));
<span class="keyword">list</span>.insertBefore(item,<span class="keyword">list</span>.firstChild);
</code></pre><h3 id="replaceChild()">replaceChild()</h3><p><code>replaceChild()</code>方法接收两个参数：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。</p>
<h3 id="removeChild()">removeChild()</h3><p><code>removeChild()</code>方法为移除某个节点，参数为要移除的节点</p>
<h3 id="cloneNode()">cloneNode()</h3><p>该方法用于复制调用该方法的节点，接收两个参数。</p>
<ul>
<li>当参数为true时，复制该节点和该节点下的整个子节点树</li>
<li>当参数为false时，只复制当前节点本身</li>
</ul>
<p><em>详细介绍可以参考上篇文章</em></p>
<h3 id="normalize()">normalize()</h3><p>这个方法唯一的作用就是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</p>
<hr>
<h1 id="Document类型">Document类型</h1><p>Document类型表示文档。而我们常用的document对象是HTMLDocument(继承自Document类型)的一个实例。document对象也是window对象的一个属性，因此可以将其作为全局的对象来访问。</p>
<h2 id="document对象的常用属性">document对象的常用属性</h2><ul>
<li>documentElement属性用来获取页面中的<code>&lt;html&gt;</code>元素 </li>
<li><p>body属性可以直接获取页面中的<code>body</code>元素 </p>
<pre><code><span class="tag">var</span> <span class="tag">body</span> = document.body
</code></pre></li>
<li><p>doctype属性可以获取对<code>&lt;!DOCTYPE&gt;</code>的引用</p>
<pre><code>console.log(document.doctype); //<span class="doctype">&lt;!DOCTYPE html&gt;</span>
</code></pre></li>
<li><p>title属性可以获取网页的<code>&lt;title&gt;</code>元素</p>
<pre><code><span class="comment">//获取title</span>
<span class="keyword">var</span> title = <span class="built_in">document</span>.title;
<span class="comment">//设置title</span>
<span class="built_in">document</span>.title = <span class="string">"new title"</span>;
</code></pre></li>
<li><p>URL属性可以获取当前页面完整的url</p>
</li>
<li>domain属性可以获取当前页面的域名</li>
</ul>
<p>比如google首页：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/dom.jpg-blogImg" alt=""></p>
<h2 id="document对象的常用方法">document对象的常用方法</h2><p>在开发过程中，经常需要取得摸个元素的引用，再执行某些操作。Document类型为此提供了两个方法。</p>
<ul>
<li><code>getElementById()</code>参数为元素的ID名<br><em>IE8 及较低版本不区分 ID 的大小写。如果页面中多个元素的 ID 值相同， getElementById() 只返回文档中第一次出现的元素</em></li>
<li><p><code>getElementsByTagName()</code>参数为元素的标签名，在HTML文档中该方法返回的是包含零个或多个元素的HTMLCollection对象。</p>
<pre><code>&lt;img src=<span class="string">"#1"</span> name=<span class="string">"user_name"</span>&gt;
&lt;img src=<span class="string">"#2"</span> name=<span class="string">"user_age"</span>&gt;
&lt;img src=<span class="string">"#3"</span> name=<span class="string">"user_sex"</span>&gt;
<span class="comment">//获取页面中所有的&lt;img&gt;元素</span>
var images = document.getElementsByTagName<span class="params">(<span class="string">"img"</span>)</span>;
<span class="comment">//获取长度</span>
console.<span class="built_in">log</span><span class="params">(images.length)</span>;
<span class="comment">//通过索引获取src</span>
console.<span class="built_in">log</span><span class="params">(images[<span class="number">0</span>].src)</span>;
<span class="comment">//通过name获取src</span>
console.<span class="built_in">log</span><span class="params">(images[<span class="string">"user_age"</span>].src)</span>;
</code></pre></li>
<li><p><code>getElementsByName()</code>这个方法会返回带有给定name特性的所有元素。</p>
</li>
</ul>
<h2 id="特殊集合">特殊集合</h2><p>除了属性和方法，document对象还有一些特殊的集合。这些集合都是 HTMLCollection 对象，为访问文档常用的部分提供了快捷方式。</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>document.anchors</td>
<td>包含文档中所有带 name 特性的 <code>&lt;a&gt;</code> 元素；</td>
</tr>
<tr>
<td>document.forms</td>
<td>包含文档中所有的 <code>&lt;form&gt;</code> 元素</td>
</tr>
<tr>
<td>document.images</td>
<td>包含文档中所有的 <code>&lt;img&gt;</code> 元素</td>
</tr>
<tr>
<td>document.links</td>
<td>包含文档中所有带href特性的 <code>&lt;a&gt;</code> 元素</td>
</tr>
</tbody>
</table>
<h2 id="文档写入">文档写入</h2><p><code>write()</code>和<code>writeln()</code><br>这两个方法都会接受一个字符串参数。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容。<code>writeln()</code>方法会在写入末尾添加一个换行符。</p>
<pre><code>current date and <span class="tag">time</span> is :
&lt;script type=<span class="string">"text/javascript"</span>&gt;
    document.<span class="function"><span class="title">write</span><span class="params">(<span class="string">"&lt;p&gt;"</span> + (new Date()</span></span>).<span class="function"><span class="title">toString</span><span class="params">()</span></span> +<span class="string">"&lt;/p&gt;"</span>)
&lt;/script&gt;
</code></pre><hr>
<h1 id="Element类型">Element类型</h1><p>Element类型提供了对元素标签名、子节点及特性的访问。常见的属性为<code>id,title,classname</code>等</p>
<h2 id="元素的创建">元素的创建</h2><p>可以通过<code>document.createElement()</code>方法创建新元素。比如创建一个<code>div</code>元素</p>
<pre><code><span class="keyword">var</span> <span class="keyword">div</span> = document.createElement(<span class="variable">"div"</span>);
</code></pre><h2 id="元素特性的相关操作">元素特性的相关操作</h2><h3 id="取得特性">取得特性</h3><p><code>getAttribute()</code>方法来取得属性值。</p>
<pre><code>&lt;div id=<span class="string">"my_test_div"</span> class=<span class="string">"div_class"</span> title=<span class="string">"div_title"</span> align=<span class="string">"left"</span>&gt;&lt;/div&gt;
var div = document.getElementById<span class="params">(<span class="string">"my_test_div"</span>)</span>;
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"id"</span>)</span>)</span>;  <span class="comment">//或者div.id</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"class"</span>)</span>)</span>;<span class="comment">//或者div.class</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"title"</span>)</span>)</span>;<span class="comment">//或者div.title</span>
console.<span class="built_in">log</span><span class="params">(div.getAttribute<span class="params">(<span class="string">"align"</span>)</span>)</span>;<span class="comment">//或者div.align</span>
</code></pre><p>通过<code>getAttribute()</code>方法也可以取得自定义特性的值，以下面的元素为例：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"my_test_div"</span> my_special_attribute=<span class="string">"hello!"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>这个元素包含一个名为 my_special_attribute 的自定义特性，它的值是 “hello!” 。可以像取得其他特性一样取得这个值:</p>
<pre><code><span class="keyword">var</span> value = <span class="keyword">div</span>.getAttribute(<span class="variable">"my_special_attribute"</span>);
</code></pre><h3 id="设置特性">设置特性</h3><p><code>setAttribute()</code>用于设置特性，这个方法接受两个参数：要设置的特性名和<br>值。如果特性已经存在，<code>setAttribute()</code>会以指定的值替换现有的值；如果特性不存在，<code>setAttribute()</code>则创建该属性并设置相应的值。</p>
<pre><code>&lt;<span class="keyword">div</span> id=<span class="variable">"my_test_div"</span> &gt;&lt;/<span class="keyword">div</span>&gt;
<span class="keyword">var</span> <span class="keyword">div</span> = document.getElementById(<span class="variable">"my_test_div"</span>);
<span class="keyword">div</span>.setAttribute(<span class="variable">"class"</span>,<span class="variable">"div_class"</span>);//或者<span class="keyword">div</span>.class=<span class="variable">"div_class"</span>
<span class="keyword">div</span>.setAttribute(<span class="variable">"title"</span>,<span class="variable">"div_title"</span>);//或者<span class="keyword">div</span>.title=<span class="variable">"div_title"</span>
<span class="keyword">div</span>.setAttribute(<span class="variable">"align"</span>,<span class="variable">"right"</span>);//或者<span class="keyword">div</span>.align=<span class="variable">"right"</span>
</code></pre><h3 id="删除特性">删除特性</h3><p><code>removeAttribute()</code>，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性。</p>
<h2 id="元素子节点">元素子节点</h2><blockquote>
<p>元素子节点部分见节点关系部分。</p>
</blockquote>
<hr>
<h1 id="Text类型">Text类型</h1><p>正如之前用到过的例子中，有时候需要向文档树中添加文本节点。<br>文本节点由Text类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。<br>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。</p>
<pre><code>&lt;<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;<span class="comment">//没有内容，没有文本节点</span>
&lt;<span class="keyword">div</span>&gt; &lt;/<span class="keyword">div</span>&gt;<span class="comment">//有空格，有一个文本节点</span>
&lt;<span class="keyword">div</span>&gt;hello world!&lt;/<span class="keyword">div</span>&gt;<span class="comment">//有内容，有一个文本节点</span>
</code></pre><p>可以获取文本节点的引用并利用<code>nodeValue</code>修改它。</p>
<pre><code><span class="keyword">var</span> textNode = <span class="keyword">div</span>.firstChild;
textNode.nodeValue = <span class="variable">"this is a test"</span>;
</code></pre><p>如果没有文本节点，可以创建一个文本节点，并插入到元素中</p>
<pre><code><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);
element.className = <span class="string">"test"</span>;
<span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">"hello world"</span>);
element.appendChild(text);
<span class="built_in">document</span>.body.appendChild(element);
</code></pre><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法<code>normalize()</code>。<br>这个方法是由 Node类型定义的。如果在一个包含两个或多个文本节点的父元素上调用<code>normalize()</code>方法，则会将所有文本节点合并成一个节点，结果节点的<code>nodeValue</code> 等于将合并前每个文本节点的<code>nodeValue</code>值拼接起来的值。比如：</p>
<pre><code>var element = document.createElement<span class="params">(<span class="string">"div"</span>)</span>;
element.className = <span class="string">"message"</span>;
var textNode = document.createTextNode<span class="params">(<span class="string">"Hello world!"</span>)</span>;
element.appendChild<span class="params">(textNode)</span>;
var anotherTextNode = document.createTextNode<span class="params">(<span class="string">"Nico!"</span>)</span>;
element.appendChild<span class="params">(anotherTextNode)</span>;
document.body.appendChild<span class="params">(element)</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//2</span>
element.normalize<span class="params">()</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//1</span>
console.<span class="built_in">log</span><span class="params">(element.firstChild.nodeValue)</span>; <span class="comment">// "Hello world!Nico!"</span>
</code></pre><p>Text 类型提供了一个作用与<code>normalize()</code>相反的方法:<code>splitText()</code>。<br>这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割<code>nodeValue</code>值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的<code>parentNode</code>相同。</p>
<pre><code>var element = document.createElement<span class="params">(<span class="string">"div"</span>)</span>;
element.className = <span class="string">"test"</span>;
var <span class="built_in">text</span> = document.createTextNode<span class="params">(<span class="string">"Nico&amp;Sora"</span>)</span>;
element.appendChild<span class="params">(text)</span>;
document.body.appendChild<span class="params">(element)</span>;
var newNode = element.childNodes[<span class="number">0</span>].splitText<span class="params">(<span class="number">4</span>)</span>;
console.<span class="built_in">log</span><span class="params">(element.childNodes[<span class="number">0</span>].nodeValue)</span>;  <span class="comment">//Nico</span>
console.<span class="built_in">log</span><span class="params">(newNode.nodeValue)</span>;  <span class="comment">//&amp;Sora</span>
console.<span class="built_in">log</span><span class="params">(element.childNodes.length)</span>; <span class="comment">//2</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>DOM是document object model的缩写，即：文档对象模型。DOM将HTML和XML描述为一个具有层次结构的节点树。DOM作为一个接口，可以对HTML或者XML进行添加，删除和修改。<br>根据 DOM，HTML 文档中的每个成分都是一个节点。DOM 是这样规定的： </p>
<ul>
<li>整个文档是一个文档节点 </li>
<li>每个 HTML 标签是一个元素节点 </li>
<li>包含在 HTML 元素中的文本是文本节点 </li>
<li>每一个 HTML 属性是一个属性节点 </li>
<li>注释属于注释节点]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[客户端检测]]></title>
    <link href="http://blog.supce.com/2016/07/23/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%809/"/>
    <id>http://blog.supce.com/2016/07/23/JavaScript之基础9/</id>
    <published>2016-07-22T16:00:00.000Z</published>
    <updated>2016-07-23T13:06:33.961Z</updated>
    <content type="html"><![CDATA[<p>不同浏览器之间或者相同浏览器不同版本之间存在着不一致性问题，可以使用客户端检测来解决不一致性带来的兼容问题。</p>
<hr>
<h1 id="能力检测_(特性检测)">能力检测 (特性检测)</h1><p>能力检测不是用来识别特定的浏览器，而是识别浏览器的能力。它并不关心用户使用的是什么浏览器，该方法只要确定浏览器支持某种特定的功能，就可以根据该功能提出解决方案。</p>
<pre><code><span class="keyword">if</span>(<span class="class"><span class="keyword">object</span>.<span class="title">someProperty</span>){</span>
    <span class="comment">//do something</span>
}
</code></pre><a id="more"></a>
<pre><code><span class="comment">//确定浏览器是否具有DOM1级规定的能力</span>
<span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp; <span class="built_in">document</span>.getElementsByTagName);
<span class="built_in">console</span>.log(hasDOM1);
</code></pre><p><em>能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器。</em></p>
<hr>
<h1 id="怪癖(quirk)检测">怪癖(quirk)检测</h1><p>怪癖检测主要是想知道浏览器存在哪些缺陷，通常会运行一小段代码，以确定浏览器的某个特性不能正常工作。<br>比如：IE8及更早版本与其他浏览器处理空白字符的方式不一样，IE9之前的版本不会为空白符创建节点</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"test"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>);
    <span class="keyword">var</span> copyList = myList.cloneNode(<span class="literal">true</span>);
    <span class="built_in">console</span>.log(copyList.childNodes.length); 
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>上面的代码中，IE&lt;9时，长度为3，而其他浏览器为7</p>
<p>IE7及以下版本有一个有意思的怪癖：name特性与给定ID匹配的表单元素（<code>&lt;input&gt;,&lt;textarea&gt;,&lt;button&gt;及&lt;select&gt;</code>）也会被该方法返回</p>
<pre><code><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"myElement"</span> <span class="attribute">value</span>=<span class="value">"Text"</span> /&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myElement"</span>&gt;</span>div<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    alert(<span class="built_in">document</span>.getElementById(<span class="string">"myElement"</span>));
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>IE&lt;8返回的是<code>input</code>,其他浏览器返回的为<code>div</code></p>
<p>还有书上的一个例子：IE8及更早版本中存在一个bug，即如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么该实例属性将不会出现在for—in循环当中<br>。</p>
<hr>
<h1 id="用户代理检测">用户代理检测</h1><p>用户代理检测主要是用来检测用户具体是什么浏览器、什么呈现引擎(内核)、什么版本、什么平台。<br>常见的浏览器内核分别为：</p>
<ul>
<li>Gecko (Firefox)</li>
<li>WebKit (Safari)</li>
<li>Blink (Opera Chrome)</li>
<li>Trident (IE)<br><em>括号内为对应的浏览器</em></li>
</ul>
<blockquote>
<p>完整的用户代理检测脚本在高级程序第九章中，这里就不贴了</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>不同浏览器之间或者相同浏览器不同版本之间存在着不一致性问题，可以使用客户端检测来解决不一致性带来的兼容问题。</p>
<hr>
<h1 id="能力检测_(特性检测)">能力检测 (特性检测)</h1><p>能力检测不是用来识别特定的浏览器，而是识别浏览器的能力。它并不关心用户使用的是什么浏览器，该方法只要确定浏览器支持某种特定的功能，就可以根据该功能提出解决方案。</p>
<pre><code><span class="keyword">if</span>(<span class="class"><span class="keyword">object</span>.<span class="title">someProperty</span>){</span>
    <span class="comment">//do something</span>
}
</code></pre>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript BOM 知识整理 (二)]]></title>
    <link href="http://blog.supce.com/2016/07/22/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%808/"/>
    <id>http://blog.supce.com/2016/07/22/JavaScript之基础8/</id>
    <published>2016-07-21T16:00:00.000Z</published>
    <updated>2016-07-22T03:23:32.930Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="navigator">navigator</h1><p>navigator对象通常用于检测浏览器和识别操作系统的版本。<br>navigator中最重要的是userAgent属性，返回包含浏览器版本等信息的字符串，其次cookieEnabled也是很重要滴，使用它可以判断用户浏览器是否开启cookie。<br>下面的表格为常用的navigator属性，详细属性可以参考代码</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>appCodeName</td>
<td>浏览器代码名的字符串表示</td>
</tr>
<tr>
<td>appName</td>
<td>官方浏览器名的字符串表示</td>
</tr>
<tr>
<td>appVersion</td>
<td>浏览器版本信息的字符串表示</td>
</tr>
<tr>
<td>cookieEnabled</td>
<td>如果启用cookie返回true，否则返回false</td>
</tr>
<tr>
<td>javaEnabled</td>
<td>如果启用java返回true，否则返回false</td>
</tr>
<tr>
<td>platform</td>
<td>浏览器所在计算机平台的字符串表示</td>
</tr>
<tr>
<td>plugins</td>
<td>安装在浏览器中的插件数组</td>
</tr>
<tr>
<td>taintEnabled</td>
<td>如果启用了数据污点返回true，否则返回false</td>
</tr>
<tr>
<td>userAgent</td>
<td>用户代理头的字符串表示</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>以下为详细代码：</p>
<pre><code>&lt;script type=<span class="string">"text/javascript"</span>&gt;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器名称："</span> + navigator.appCodeName)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"次版本信息："</span> + navigator.appMinorVersion)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"完整浏览器名称："</span> + navigator.appName)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器的版本："</span> + navigator.appVersion)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器编译版本："</span> + navigator.buildID)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"是否启用cookie："</span> + navigator.cookieEnabled)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"CPU类型："</span> + navigator.cpuClass)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"是否启用Java："</span> + navigator.javaEnabled<span class="params">()</span>)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器主语言："</span> + navigator.language)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器中注册的MIME类型数组："</span> + navigator.mimeTypes)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"是否连接到网络："</span> + navigator.onLine)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"客户端计算机操作系统或者CPU："</span> + navigator.oscpu)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器所在系统平台："</span> + navigator.platform)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器中安装的插件信息数组："</span> + navigator.plugins)</span>;
    <span class="comment">//console.log("用户的首选项：" + navigator.preference());</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"产品名称："</span> + navigator.product)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"产品的次要信息："</span> + navigator.productSub)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"操作系统的语言："</span> + navigator.systemLanguage)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"用户代理字符串："</span> + navigator.userAgent)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"操作系统的默认语言："</span> + navigator.userLanguage)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"借以访问用户个人信息的对象："</span> + navigator.userProfile)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"浏览器的品牌："</span> + navigator.vendor)</span>;
    console.<span class="built_in">log</span><span class="params">(<span class="string">"有关供应商的次要信息："</span> + navigator.vendorSub)</span>;
&lt;/script&gt;
</code></pre><p>Chrome浏览器<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/navigator.jpg-blogImg" alt=""><br>IE浏览器<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/navigator1.jpg-blogImg" alt=""></p>
<hr>
<h2 id="检测插件">检测插件</h2><p>有时候需要检测浏览器是否安装了某些插件，可以利用<code>navigator</code>的<code>plugins</code>属性来实现</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>)</span>{
    <span class="keyword">var</span> np = navigator.plugins;
    <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject){
        <span class="keyword">var</span> activeObejctName = name + <span class="string">"."</span> + name;
        <span class="keyword">try</span>{
            <span class="keyword">var</span> axobj = <span class="built_in">eval</span>(<span class="string">"new ActiveXObject(activeObejctName);"</span>);
            <span class="keyword">return</span> axobj ? <span class="literal">true</span> : <span class="literal">false</span>;
        }<span class="keyword">catch</span>(e){
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    }<span class="keyword">else</span> <span class="keyword">if</span>(np &amp;&amp; np.length){
        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;np.length;i++){
            <span class="keyword">if</span>(np[i].name.toLowerCase().indexOf(name.toLowerCase()) &gt; -<span class="number">1</span>){
                <span class="keyword">return</span> <span class="literal">true</span>;
            }
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
}
<span class="built_in">console</span>.log(hasPlugin(<span class="string">"Flash"</span>));
</code></pre><hr>
<h1 id="screen对象">screen对象</h1><p>screen对象主要用于获取用户的屏幕信息。其主要的属性如下表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>availHeight</td>
<td>窗口可以使用的屏幕高度，单位像素</td>
</tr>
<tr>
<td>availWidth</td>
<td>窗口可以使用的屏幕宽度，单位像素</td>
</tr>
<tr>
<td>colorDepth</td>
<td>用户浏览器表示的颜色位数，通常为32位(每像素的位数)</td>
</tr>
<tr>
<td>pixelDepth</td>
<td>用户浏览器表示的颜色位数，通常为32位(每像素的位数)（IE不支持此属性）</td>
</tr>
<tr>
<td>height</td>
<td>屏幕的高度，单位像素</td>
</tr>
<tr>
<td>width</td>
<td>屏幕的宽度，单位像素</td>
</tr>
</tbody>
</table>
<p>screen对象不是很常用，但有时候可以利用到availWidth和availHeight属性。<br>例如：可以使用下面的代码填充用户的屏幕</p>
<pre><code><span class="keyword">var</span> <span class="keyword">win</span> = <span class="keyword">window</span>.<span class="keyword">open</span>(<span class="string">""</span>,<span class="string">""</span>,<span class="string">"width=100,height=100"</span>);
<span class="keyword">win</span>.<span class="keyword">window</span>.moveTo(0,0);
<span class="keyword">win</span>.<span class="keyword">window</span>.resizeTo(screen.availWidth,screen.availHeight);
</code></pre><hr>
<h1 id="history对象">history对象</h1><p>history对象保存着用户上网的历史记录。</p>
<ol>
<li><code>go()</code>方法<ul>
<li>参数为正时向前 <code>history.go(2) //前进两页</code></li>
<li>参数为负时向后</li>
<li>参数为字符串时，会跳转到历史记录中包含该字符串的第一个位置（可能后退，也可能前进，具体要看哪个位置最近）如果历史记录中不包含该字符串，那么这个方法什么也不做</li>
</ul>
</li>
<li><code>back()</code>方法，后退一页</li>
<li><code>forward</code>方法，前进一页</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="navigator">navigator</h1><p>navigator对象通常用于检测浏览器和识别操作系统的版本。<br>navigator中最重要的是userAgent属性，返回包含浏览器版本等信息的字符串，其次cookieEnabled也是很重要滴，使用它可以判断用户浏览器是否开启cookie。<br>下面的表格为常用的navigator属性，详细属性可以参考代码</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>appCodeName</td>
<td>浏览器代码名的字符串表示</td>
</tr>
<tr>
<td>appName</td>
<td>官方浏览器名的字符串表示</td>
</tr>
<tr>
<td>appVersion</td>
<td>浏览器版本信息的字符串表示</td>
</tr>
<tr>
<td>cookieEnabled</td>
<td>如果启用cookie返回true，否则返回false</td>
</tr>
<tr>
<td>javaEnabled</td>
<td>如果启用java返回true，否则返回false</td>
</tr>
<tr>
<td>platform</td>
<td>浏览器所在计算机平台的字符串表示</td>
</tr>
<tr>
<td>plugins</td>
<td>安装在浏览器中的插件数组</td>
</tr>
<tr>
<td>taintEnabled</td>
<td>如果启用了数据污点返回true，否则返回false</td>
</tr>
<tr>
<td>userAgent</td>
<td>用户代理头的字符串表示</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript BOM 知识整理 (一)]]></title>
    <link href="http://blog.supce.com/2016/07/21/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%807/"/>
    <id>http://blog.supce.com/2016/07/21/JavaScript之基础7/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2016-07-22T01:29:41.058Z</updated>
    <content type="html"><![CDATA[<h1 id="BOM">BOM</h1><p>BOM是browser object model的缩写，即：浏览器对象模型。BOM主要用于访问浏览器的功能，这些功能与网页的内容无关。</p>
<h2 id="window对象">window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，也是ECMAScript规定的Global对象。<br>因此，在全局作用域中声明的变量和函数都会成为window对象的属性和方法。但是，声明的全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以通过delete删除。</p>
<pre><code><span class="keyword">var</span> age = <span class="number">22</span>;
<span class="built_in">window</span>.name = <span class="string">"Nico"</span>;
<span class="keyword">delete</span> <span class="built_in">window</span>.age;
<span class="keyword">delete</span> <span class="built_in">window</span>.name;
<span class="built_in">console</span>.log(<span class="built_in">window</span>.age);   <span class="comment">//22</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>.name);  <span class="comment">//undefined</span>
</code></pre><a id="more"></a>
<h3 id="窗口关系与框架">窗口关系与框架</h3><ul>
<li>当页面中包含框架时，浏览器会为每一个框架创建window对象，并且保存在frames集合中</li>
<li>在frames集合中，可以通过数值索引（从0开始，从左至由，从上至下）或者框架名称来访问相应的window对象</li>
<li>top对象始终指向最高（最外）层的框架，也就是浏览器窗口</li>
<li>parent对象始终指向当前框架的直接上层框架</li>
<li>self对象始终指向window</li>
</ul>
<h3 id="窗口位置">窗口位置</h3><ul>
<li>screenLeft与screenX属性表示窗口相对于屏幕左边的位置</li>
<li><p>screenRight与screenY属性表示窗口相对于屏幕上边的位置<br>为了跨浏览器使用，可以利用二元操作符:</p>
<pre><code><span class="keyword">var</span> left = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;

<span class="keyword">var</span> top = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;
</code></pre></li>
<li><p>moveTo(x,y)将窗口移动到坐标值为(x,y)的位置</p>
</li>
<li>moveBy(x,y)将窗口在水平方向移动x个像素，在垂直方向移动y个像素</li>
</ul>
<h3 id="窗口大小">窗口大小</h3><ul>
<li>outerWidth和outerHeight表示浏览器窗口本身的尺寸</li>
<li><p>innerWidth和innerHeight表示页面视图区的大小<br>这样说可能不如代码直观，比如下面这段代码：</p>
<pre><code>console.<span class="built_in">log</span><span class="params">(<span class="string">"-----窗口大小-----"</span>)</span>;
console.<span class="built_in">log</span><span class="params">(<span class="string">"window.outerHeight = "</span> + window.outerHeight)</span>;
console.<span class="built_in">log</span><span class="params">(<span class="string">"window.innerHeight = "</span> + window.innerHeight)</span>;
</code></pre></li>
</ul>
<p>效果如下：<br><img src="http://7xqkrz.com1.z0.glb.clouddn.com/size.jpg-blogImg" alt="窗口大小"></p>
<p>也可以通过<code>document.documentElememt.clientWidth</code>和<code>document.documentElement.clientHeight</code>来获取页面视图区的大小</p>
<p>使用 <code>resizeTo()</code> 和 <code>resizeBy()</code>方法可以调整浏览器窗口的大小。这两个方法都接收两个<br>参数，其中 <code>resizeTo()</code> 接收浏览器窗口的新宽度和新高度， <code>resizeBy()</code>接收新窗口与原窗口的宽度和高度之差。</p>
<blockquote>
<p>这两种方法可能被浏览器禁用，对于resizeTo,chrome只支持resize新建的空白窗口，可以这样使用：</p>
</blockquote>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">openWin</span><span class="params">()</span>{</span>
    myWindow=window.<span class="keyword">open</span>(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'width=200,height=200'</span>);
}
<span class="function"><span class="keyword">function</span> <span class="title">moveWin</span><span class="params">()</span>{</span>
    myWindow.moveTo(<span class="number">0</span>,<span class="number">0</span>);
    myWindow.resizeTo(<span class="number">500</span>,<span class="number">500</span>)
    myWindow.focus();
}
&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Open 'myWindow'"</span> onclick=<span class="string">"openWin()"</span> /&gt;
&lt;<span class="keyword">br</span> /&gt;&lt;<span class="keyword">br</span> /&gt;
&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"Move 'myWindow'"</span> onclick=<span class="string">"moveWin()"</span> /&gt;
</code></pre><h3 id="打开窗口">打开窗口</h3><p>使用<code>window.open</code>可以打开新的浏览器窗口。这个方法可以接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p>
<p>如果给<code>window.open()</code>传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的 URL。<br>比如：</p>
<pre><code><span class="built_in">window</span>.open(<span class="string">'http://www.supce.com'</span>,<span class="string">'_blank'</span>,<span class="string">'height=200,widht=200,top=5,left=5,resizable=yes'</span>);
</code></pre><p>打开一个新的可以调整大小的窗口，窗口初始大小为200×200像素，并且距屏幕顶部和左边各5像素。</p>
<p>也可以使用<code>window.close()</code>来关闭页面窗口。</p>
<h3 id="超时调用和间歇调用">超时调用和间歇调用</h3><ul>
<li>超时调用：<code>setTimeout()</code><br>它接受两个参数：要执行的代码和以毫秒表示的时间。其中，第一个参数可以是一个包含 JavaScript 代码的字符串，也可以是一个函数。<br>该方法会返回一个数值ID，表示该超时调用。</li>
<li><p>取消超时调用：<code>clearTimeout()</code><br>比如:</p>
<pre><code><span class="comment">//设置取消调用</span>
<span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    alert(<span class="string">"Nico"</span>);
},<span class="number">2000</span>);
<span class="comment">//取消超时调用</span>
clearTimeout(timeout);
</code></pre></li>
<li><p>间歇调用：<code>setInterval()</code><br>它的参数与<code>setTimeout</code>相同，也会返回一个数值ID，表示该间歇调用。</p>
<pre><code>var num = <span class="number">0</span>;
var <span class="built_in">max</span> = <span class="number">5</span>;
var intervalId = null;
<span class="function"><span class="keyword">function</span> <span class="title">interval</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"Nico"</span>)</span>;
    num ++;
    <span class="keyword">if</span><span class="params">(num == max)</span>{
        clearInterval<span class="params">(intervalId)</span>;
    }
}
intervalId = setInterval<span class="params">(interval,<span class="number">1000</span>)</span>;
</code></pre><p>以上代码，每一秒输出一次nico，输出5次后结束</p>
</li>
</ul>
<blockquote>
<p>间歇调用也可以使用超时调用来实现，比如：</p>
</blockquote>
<pre><code>var num = <span class="number">0</span>;
var <span class="built_in">max</span> = <span class="number">5</span>;
<span class="function"><span class="keyword">function</span> <span class="title">timeout</span><span class="params">()</span>{</span>
    console.<span class="built_in">log</span><span class="params">(<span class="string">"Nico"</span> + num)</span>;
    num ++;
    <span class="keyword">if</span><span class="params">(num &lt; max)</span>{
        setTimeout<span class="params">(timeout,<span class="number">1000</span>)</span>;
    }<span class="keyword">else</span>{
        console.<span class="built_in">log</span><span class="params">(<span class="string">"complete"</span>)</span>;
    }
}
setTimeout<span class="params">(timeout,<span class="number">1000</span>)</span>;
</code></pre><h3 id="系统对话框">系统对话框</h3><ul>
<li>警告对话框：<code>alert()</code></li>
<li>确认对话框：<code>confirm()</code><br>该方法返回一个布尔值，true表示点击了OK，false表示点击了Cancel，或者关闭了对话框</li>
<li>文本输入框：<code>prompt()</code><br>如果用户单击了OK，则<code>prompt()</code>返回文本输入域的值。如果用户单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。</li>
</ul>
<h2 id="Location对象">Location对象</h2><p><code>window.location</code>和<code>document.location</code>引用的是同一个对象。Location 对象包含有关当前URL的信息以及与当前窗口中加载的文档有关的信息。</p>
<h3 id="Location对象的属性">Location对象的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>设置或返回从井号 (#) 开始的 URL（锚）。</td>
</tr>
<tr>
<td>host</td>
<td>设置或返回主机名和当前 URL 的端口号。</td>
</tr>
<tr>
<td>hostname</td>
<td>设置或返回当前 URL 的主机名。</td>
</tr>
<tr>
<td>href</td>
<td>设置或返回完整的 URL。</td>
</tr>
<tr>
<td>pathname</td>
<td>设置或返回当前 URL 的路径部分。</td>
</tr>
<tr>
<td>port</td>
<td>设置或返回当前 URL 的端口号。</td>
</tr>
<tr>
<td>protocol</td>
<td>设置或返回当前 URL 的协议。</td>
</tr>
<tr>
<td>search</td>
<td>设置或返回从问号 (?) 开始的 URL（查询部分）</td>
</tr>
</tbody>
</table>
<p>如果URL查询字符串为多个，可以使用下面的函数</p>
<pre><code>function getQueryStringArgs(){
    //<span class="keyword">var</span> qs = location.search.length&gt;<span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>;
    <span class="keyword">var</span> qs = <span class="string">"a=1&amp;b=2&amp;c=3"</span>;
    <span class="keyword">var</span> args = {},
    items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],
    name = null,
    value = null;
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++){
        <span class="keyword">var</span> item = items[i].split(<span class="string">"="</span>);
        name = decodeURIComponent(item[<span class="number">0</span>]);
        value = decodeURIComponent(item[<span class="number">1</span>]);
        <span class="keyword">if</span>(name.length){
            args[name] = value;
        }
    }
    <span class="keyword">return</span> args;
}
<span class="keyword">var</span> <span class="literal">result</span> = getQueryStringArgs();
console.log(<span class="literal">result</span>[<span class="string">"a"</span>]+<span class="literal">result</span>[<span class="string">"b"</span>]+<span class="literal">result</span>[<span class="string">"c"</span>]);
</code></pre><h3 id="页面跳转">页面跳转</h3><ol>
<li>有历史记录<ul>
<li><code>location.assign(&quot;http:/www.supce.com&quot;)</code></li>
<li><code>window.location = &quot;http:/www.supce.com&quot;</code></li>
<li><code>location.href = &quot;http:/www.supce.com&quot;</code></li>
</ul>
</li>
<li>不产生历史记录<ul>
<li><code>location.replace(&quot;http:/www.supce.com&quot;)</code></li>
</ul>
</li>
<li>重新加载<ul>
<li><code>location.reload()       //有可能从缓存中加载</code></li>
<li><code>location.reload(true)   //从服务器端重新加载</code>  </li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="BOM">BOM</h1><p>BOM是browser object model的缩写，即：浏览器对象模型。BOM主要用于访问浏览器的功能，这些功能与网页的内容无关。</p>
<h2 id="window对象">window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，也是ECMAScript规定的Global对象。<br>因此，在全局作用域中声明的变量和函数都会成为window对象的属性和方法。但是，声明的全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以通过delete删除。</p>
<pre><code><span class="keyword">var</span> age = <span class="number">22</span>;
<span class="built_in">window</span>.name = <span class="string">"Nico"</span>;
<span class="keyword">delete</span> <span class="built_in">window</span>.age;
<span class="keyword">delete</span> <span class="built_in">window</span>.name;
<span class="built_in">console</span>.log(<span class="built_in">window</span>.age);   <span class="comment">//22</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>.name);  <span class="comment">//undefined</span>
</code></pre>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数表达式]]></title>
    <link href="http://blog.supce.com/2016/07/14/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%806/"/>
    <id>http://blog.supce.com/2016/07/14/JavaScript之基础6/</id>
    <published>2016-07-13T16:00:00.000Z</published>
    <updated>2016-07-14T11:46:08.233Z</updated>
    <content type="html"><![CDATA[<h1 id="闭包">闭包</h1><hr>
<p>闭包，在JavaScript中很有意思。JavaScript是链式作用域，所以可以将函数内部与函数外部连接起来。由于在Javascript中，只有函数内部的子函数才能读取函数内部的变量，因此可以把内部的函数返回，通过返回的函数就能够读取到函数内部的变量。<br>于是，可以把闭包简单理解成定义在一个函数内部的函数，并且该内部函数访问了外部的变量。</p>
<pre><code>console.log(<span class="string">"-----闭包-----"</span>);
function <span class="function"><span class="title">fun</span><span class="params">()</span>{</span>
    <span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span>;
    <span class="keyword">return</span> function f(){
        console.log(a);
    };
}
<span class="variable"><span class="keyword">var</span> result</span> = <span class="function"><span class="title">fun</span><span class="params">()</span><span class="params">()</span>;</span>
</code></pre><a id="more"></a>
<h2 id="闭包与变量">闭包与变量</h2><p>链式作用域会带来一个问题，在闭包中，取得的包含函数的变量，是其最终值。举个例子</p>
<pre><code>console.log(<span class="string">"-----闭包与变量-----"</span>);
function createFunctions(){
    <span class="keyword">var</span> <span class="type">array</span> = new <span class="type">Array</span>();
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
        <span class="type">array</span>[i] = function(){
            <span class="keyword">return</span> i;
        }
    }
    <span class="keyword">return</span> <span class="type">array</span>;
}
<span class="keyword">var</span> <span class="literal">result</span> = createFunctions();
console.log(<span class="literal">result</span>[<span class="number">0</span>]());  //<span class="number">10</span>
</code></pre><p>上面的例子中，得到的是10并不是0<br>可以通过建立一个匿名函数。并且立即执行该匿名函数来解决</p>
<pre><code>function createFunctions(){
    <span class="keyword">var</span> <span class="type">array</span> = new <span class="type">Array</span>();
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){
        <span class="type">array</span>[i] = function(num){
            <span class="keyword">return</span> function(){
                <span class="keyword">return</span> num;
            }
        }(i);
    }
    <span class="keyword">return</span> <span class="type">array</span>;
}
<span class="keyword">var</span> <span class="literal">result</span> = createFunctions();
console.log(<span class="literal">result</span>[<span class="number">0</span>]());  //<span class="number">0</span>
</code></pre><h2 id="关于this对象">关于this对象</h2><pre><code><span class="built_in">console</span>.log(<span class="string">"-----关于this对象-----"</span>);
<span class="keyword">var</span> name = <span class="string">"The Windows"</span>;
<span class="keyword">var</span> o = {
    name : <span class="string">"The O"</span>,
    getNameFun : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> <span class="keyword">this</span>.name;
        };
    }
}
<span class="built_in">console</span>.log(o.getNameFun()());  <span class="comment">//The Windows</span>
<span class="keyword">var</span> object = {
    name : <span class="string">"The Object"</span>,
    getNameFun : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">var</span> that = <span class="keyword">this</span>;
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> that.name;
        };
    }
}
<span class="built_in">console</span>.log(object.getNameFun()());  <span class="comment">//The Object</span>
<span class="keyword">var</span> myObject = {
    name :  <span class="string">"myObject"</span>,
    getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
    }
}
<span class="built_in">console</span>.log(myObject.getName());
<span class="built_in">console</span>.log((fun=myObject.getName)());  <span class="comment">//The Windows</span>
</code></pre><h1 id="模仿块级作用域">模仿块级作用域</h1><p>JavaScript 没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含在函数中而非语句中创建的</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">(num)</span>{</span>
    <span class="keyword">for</span><span class="params">(var i=<span class="number">0</span>;i&lt;num;i++)</span>{
        <span class="comment">//do something</span>
    }
    console.<span class="built_in">log</span><span class="params">(i)</span>;
}
fun<span class="params">(<span class="number">5</span>)</span>;  <span class="comment">//5</span>
</code></pre><p>可以看出变量i并不会如同在C++和Java等语言中，随着循环的结束而销毁，即便是重新声明，不初始化，也不会改变它的值。<br>可以利用匿名函数来膜（模？）仿块级作用域来解决这个问题</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    //块级作用域
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>使用这种方式，可以限制向全局作用域中添加过多的变量和函数，同时减少闭包占用内存的问题。</p>
<h1 id="私有变量">私有变量</h1><p>JavaScript中任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量，但是可以通过闭包来访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>
<pre><code>console.log(<span class="string">"---私有变量---"</span>);
function <span class="keyword">Person</span>(name){
    this.age = 22;
    this.getName = function(){
        return name;
    };
    this.setName = function(value){
        name = value;
    }
}
var <span class="keyword">person</span> = new <span class="keyword">Person</span>(<span class="string">"Nico"</span>);
console.log(<span class="keyword">person</span>.age);         //22
console.log(<span class="keyword">person</span>.name);        //undefined
console.log(<span class="keyword">person</span>.getName());   //Nico
</code></pre><p>上面的例子中有个问题，就是每个实例都会创建一组相同的方法。为了解决这个问题，可以使用静态私有变量。</p>
<h2 id="静态私有变量">静态私有变量</h2><pre><code>console.log(<span class="string">"-----静态私有变量-----"</span>);
(function(){
    var name = <span class="string">""</span>;
    <span class="keyword">Person</span> = function(value){
        name = value;
    }
    <span class="keyword">Person</span>.prototype.getName = function(){
        return name;
    };
    <span class="keyword">Person</span>.prototype.setName = function(value){
        name = value;
    }
})();
var staticPerson1 = new <span class="keyword">Person</span>(<span class="string">"Nico"</span>);
var staticPerson2 = new <span class="keyword">Person</span>(<span class="string">"Sora"</span>);
console.log(staticPerson1.getName());   //Sora
</code></pre><p>这个例子中的 Person 构造函数与 getName() 和 setName()方法一样，都有权访问私有变量 name 。在这种模式下，变量 name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用 setName() 会影响所有实例。而调用 setName() 或新建一个 Person 实例都会赋予 name属性一个新值。结果就是所有实例都会返回相同的值。<br>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。</p>
<h2 id="模块模式">模块模式</h2><p>模块模式主要是为单列创建私有变量和特权方法的。其语法如下：</p>
<pre><code><span class="built_in">console</span>.log(<span class="string">"-----模块模式-----"</span>);
<span class="keyword">var</span> single = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> privateProperty = <span class="string">"private"</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">privateFun</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="string">"privateFun"</span>
    };
    <span class="keyword">return</span> {
        publicProperty : <span class="string">"public"</span>,
        publicFun : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> <span class="string">"publicFun"</span>;
        },
        getPrivate : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> privateProperty;
        }
    };
}();
<span class="built_in">console</span>.log(single.publicFun());   <span class="comment">//publicFun</span>
<span class="built_in">console</span>.log(single.getPrivate());  <span class="comment">//private</span>
</code></pre><p>模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。<br>由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。例如：</p>
<pre><code><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//私有变量</span>
    components.push(<span class="keyword">new</span> BaseComponent());  <span class="comment">//私有变量初始化</span>
    <span class="comment">//公共方法</span>
    <span class="keyword">return</span> {
        getComponentCount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> components.length;
        },
        registerComponent : <span class="function"><span class="keyword">function</span>(<span class="params">component</span>)</span>{
            <span class="keyword">if</span>(<span class="keyword">typeof</span> component == <span class="string">"object"</span>){
                components.push(component);
            }
        }
    };
}();
</code></pre><p>对于必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，适合模块模式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="闭包">闭包</h1><hr>
<p>闭包，在JavaScript中很有意思。JavaScript是链式作用域，所以可以将函数内部与函数外部连接起来。由于在Javascript中，只有函数内部的子函数才能读取函数内部的变量，因此可以把内部的函数返回，通过返回的函数就能够读取到函数内部的变量。<br>于是，可以把闭包简单理解成定义在一个函数内部的函数，并且该内部函数访问了外部的变量。</p>
<pre><code>console.log(<span class="string">"-----闭包-----"</span>);
function <span class="function"><span class="title">fun</span><span class="params">()</span>{</span>
    <span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span>;
    <span class="keyword">return</span> function f(){
        console.log(a);
    };
}
<span class="variable"><span class="keyword">var</span> result</span> = <span class="function"><span class="title">fun</span><span class="params">()</span><span class="params">()</span>;</span>
</code></pre>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我胡汉三又回来了]]></title>
    <link href="http://blog.supce.com/2016/07/13/Comeback/"/>
    <id>http://blog.supce.com/2016/07/13/Comeback/</id>
    <published>2016-07-12T16:00:00.000Z</published>
    <updated>2016-07-13T01:44:49.151Z</updated>
    <content type="html"><![CDATA[<p>今天开始有时间写一些自己的东西了 O(∩_∩)O哈！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天开始有时间写一些自己的东西了 O(∩_∩)O哈！</p>
]]>
    </summary>
    
      <category term="心情杂记" scheme="http://blog.supce.com/tags/%E5%BF%83%E6%83%85%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对象的创建与继承]]></title>
    <link href="http://blog.supce.com/2016/07/13/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%805/"/>
    <id>http://blog.supce.com/2016/07/13/JavaScript之基础5/</id>
    <published>2016-07-12T16:00:00.000Z</published>
    <updated>2016-07-13T11:15:28.855Z</updated>
    <content type="html"><![CDATA[<p><em>再把JavaScript中对象的创建与继承复习下</em></p>
<h1 id="对象的创建">对象的创建</h1><hr>
<h2 id="工厂模式">工厂模式</h2><pre><code>console.log(<span class="string">"-----工厂模式-----"</span>);
    function CreatePerson(name,age){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.sayName = function(){
            return name;
        };
        return o;
    }
var <span class="keyword">person</span> = CreatePerson(<span class="string">"Nico"</span>,28);
console.log(<span class="keyword">person</span>.sayName());
</code></pre><p>工厂模式虽然解决了对象的创建问题，但是并没有解决对象的识别问题。<br><code>alert(person.constructor);</code> 得到的并不是想要的结果。<br><a id="more"></a></p>
<h2 id="构造函数模式">构造函数模式</h2><pre><code>console.log(<span class="string">"-----构造函数模式-----"</span>);
    function <span class="keyword">Person</span>(name,age){
        this.name = name;
        this.age = age;
        this.sayName = function(){
            return this.name;
        };
    }
var person1 = new <span class="keyword">Person</span>(<span class="string">"Sora"</span>,28);
var person2 = new <span class="keyword">Person</span>(<span class="string">"Mimo"</span>,29);
console.log(person1.sayName());
console.log(person1.constructor==<span class="keyword">Person</span>);  //true
console.log(person1.sayName == person2.sayName); //false 
</code></pre><p>构造函数模式虽然解决了类的识别问题，但是带来了另一个问题：<em>构造函数中的每个方法都要在每个实例上重新创建一遍</em>。虽然可以把函数的创建放在构造函数外部，通过设置属性等于外部函数来解决，但这样跟对象封装的初衷不相符，而且造成过多的全局函数。</p>
<h2 id="原型模式">原型模式</h2><pre><code>console.log(<span class="string">"-----原型模式-----"</span>);
    function <span class="keyword">Person</span>(){
    }
    <span class="keyword">Person</span>.prototype = {
        constructor : <span class="keyword">Person</span>, 
        name : <span class="string">"Nico"</span>,
        age : <span class="string">"28"</span>,
        friends : <span class="comment">["Mimo"]</span>,
        sayName : function(){
            return this.name;
        }
    };
var person1 = new <span class="keyword">Person</span>();
var person2 = new <span class="keyword">Person</span>();
person2.friends.push(<span class="string">"Pile"</span>);
console.log(person1.sayName==person2.sayName); //true
console.log(person1.friends);  //<span class="comment">["Mimo", "Pile"]</span>
</code></pre><p>使用原型模式会出现引用类型的数据共享问题，于是引入了组合使用构造函数与原型模式</p>
<h2 id="组合模式">组合模式</h2><pre><code>console.log(<span class="string">"-----组合使用-----"</span>)
    function <span class="keyword">Person</span>(name,age){
        this.name = name;
        this.age = age;
        this.friends = <span class="comment">[]</span>;
    };
    <span class="keyword">Person</span>.prototype={
        constructor : <span class="keyword">Person</span>,
        sayName : function(){
            return this.name;
        }
    }
var person1 = new <span class="keyword">Person</span>();
var person2 = new <span class="keyword">Person</span>();
person1.friends.push(<span class="string">"Mimo"</span>);
person2.friends.push(<span class="string">"Pile"</span>);
console.log(person1.sayName==person2.sayName); //true
console.log(person1.friends);  //<span class="comment">["Mimo"]</span>
</code></pre><p>利用组合模式解决了之前的几个问题。这种解决问题的方式特别像学习《操作系统》课程中问题的解决方式。</p>
<h2 id="动态原型模式">动态原型模式</h2><p>动态原型模式主要是把对象的创建信息都封装于对象的构造函数中</p>
<pre><code>console.log(<span class="string">"-----动态原型-----"</span>);
    function <span class="keyword">Person</span>(name,age){
        this.name = name;
        this.age = age;
        if(typeof sayName != 'function'){
            <span class="keyword">Person</span>.prototype.sayName = function(){
                return this.name;
            }
        }
    }
</code></pre><p><em>使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</em></p>
<h2 id="寄生构造函数">寄生构造函数</h2><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>{
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();
    o.name = name;
    o.age = age;
    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">return</span> <span class="keyword">this</span>.name;
    }
    <span class="keyword">return</span> o;
}
</code></pre><p>当我们想基于原有数组创建一个更多方法的数组，但是又不想对原有数据类型进行修改，就可以使用这种模式</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span><span class="params">()</span></span>{
    <span class="keyword">var</span> <span class="keyword">array</span> = <span class="keyword">new</span> <span class="keyword">Array</span>();
    <span class="keyword">array</span>.push.apply(<span class="keyword">array</span>,arguments);
    <span class="keyword">array</span>.toMyString = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">return</span> this.join(<span class="string">"|"</span>);
    }
    <span class="keyword">return</span> <span class="keyword">array</span>;
}
<span class="keyword">var</span> myarray = <span class="keyword">new</span> MyArray(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);
console.log(myarray.toMyString());  <span class="comment">//1|2|3</span>
</code></pre><h1 id="对象的继承">对象的继承</h1><hr>
<blockquote>
<p>在JavaScript中，主要还是利用原型链来实现继承的。</p>
<h2 id="原型链">原型链</h2><pre><code><span class="built_in">console</span>.log(<span class="string">"-----原型链-----"</span>);
<span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.superProperty = <span class="string">"super"</span>;
    <span class="keyword">this</span>.friends = [<span class="string">"nico"</span>];
}
SuperClass.prototype.getSuperProperty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.superProperty;
}
<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.subProperty = <span class="string">"sub"</span>;
}
SubClass.prototype = <span class="keyword">new</span> SuperClass();
SubClass.prototype.getSubProperty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.subProperty;
}
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass();
<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass();
<span class="built_in">console</span>.log(instance1.getSuperProperty());  <span class="comment">//super</span>
<span class="built_in">console</span>.log(instance2.constructor);  <span class="comment">//superclass</span>
instance1.friends.push(<span class="string">"mimo"</span>);  
<span class="built_in">console</span>.log(instance2.friends);  <span class="comment">//["nico", "mimo"]</span>
</code></pre></blockquote>
<p>使用原型会带来两个问题</p>
<ul>
<li>父类中的属性如果是引用类型，会在子类中出现共享问题</li>
<li>在创建子类实例时，不能通过父类的构造函数来传递参数<h2 id="借用构造函数">借用构造函数</h2><pre><code><span class="built_in">console</span>.log(<span class="string">"-----借用构造函数-----"</span>);
<span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>)</span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.friends = [<span class="string">"nico"</span>];
}
SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
}
<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">age</span>)</span>{
    SuperClass.call(<span class="keyword">this</span>,<span class="string">"sora"</span>);
    <span class="keyword">this</span>.age = age;
}
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">21</span>);
<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">22</span>);
instance1.friends.push(<span class="string">"mimo"</span>);
<span class="built_in">console</span>.log(instance2.friends);  <span class="comment">//["nico"]</span>
<span class="built_in">console</span>.log(instance1.getName);  <span class="comment">//undefined</span>
</code></pre></li>
</ul>
<p>借用构造函数解决了引用类型的问题，但是带来了其他的问题，在超类型中原型定义的方法对于子类来说是不可见的，因此，也就不能函数复用了。</p>
<h2 id="组合继承">组合继承</h2><pre><code><span class="built_in">console</span>.log(<span class="string">"-----组合继承-----"</span>);
<span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name,friends</span>)</span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.friends = friends;
}
SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
}
<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,friends,age</span>)</span>{
    SuperClass.call(<span class="keyword">this</span>,name,friends);
    <span class="keyword">this</span>.age = age;
}
SubClass.prototype = <span class="keyword">new</span> SuperClass();
SubClass.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.age;
}
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">"sora"</span>,[<span class="string">"mimo"</span>],<span class="number">28</span>);
<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">"pile"</span>,[<span class="string">"kussn"</span>],<span class="number">27</span>);
instance1.friends.push(<span class="string">"emi"</span>);
<span class="built_in">console</span>.log(instance1.friends);  <span class="comment">//["mimo", "emi"]</span>
<span class="built_in">console</span>.log(instance2.friends);  <span class="comment">//kussn</span>
<span class="built_in">console</span>.log(instance1.getName() + instance1.getAge()); <span class="comment">//sora28</span>
</code></pre><p>组合继承是将原型链与借用构造函数二者的长处结合起来，使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p>
<h2 id="原型式继承">原型式继承</h2><pre><code>console.log(<span class="string">"-----原型式继承-----"</span>);
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
var <span class="keyword">person</span> = {
    name:<span class="string">"sora"</span>,
    friends:<span class="comment">["mimo"]</span>
}
var person1 = object(<span class="keyword">person</span>);
person1.name = <span class="string">"pile"</span>;
person1.friends.push(<span class="string">"emi"</span>);
var person2 = object(<span class="keyword">person</span>);
person2.name = <span class="string">"kussn"</span>;
person2.friends.push(<span class="string">"rippi"</span>);
console.log(<span class="keyword">person</span>.friends);   //<span class="comment">["mimo", "emi", "rippi"]</span>
console.log(person2.friends);  //<span class="comment">["mimo", "emi", "rippi"]</span>
</code></pre><p>object其实是对传入的对象进行了一次浅复制 对于引用类型来说，跟原型链一样是共享的</p>
<h2 id="寄生式继承">寄生式继承</h2><pre><code>console.log(<span class="string">"-------寄生式继承--------"</span>);
var <span class="keyword">person</span> = {
    name:<span class="string">"sora"</span>,
    friends:<span class="comment">["mimo"]</span>
}
function createAnother(original){
    var clone = Object.create(original);
    clone.sayName = function(){
        return this.name;
    };
    return clone;
}
var instance = createAnother(<span class="keyword">person</span>);
console.log(instance.sayName());
</code></pre><p>寄生式继承其实与寄生构造函数和工厂模式类似，创建一个封装继承的函数，然后在函数中对传入的对象进行某种增强，最后返回被增强的对象</p>
<h2 id="寄生组合式继承">寄生组合式继承</h2><p>组合继承会有一个问题，就是无论什么情况下，都会调用两次超类型构造函数。为了解决这个问题，引入了寄生组合式继承</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>{
    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);
    prototype.constructor = subType;
    subType.prototype = prototype;
}
<span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name,friends</span>)</span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.friends = friends;
}
SuperType.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.name;
}
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,friends,age</span>)</span>{
    SuperType.call(<span class="keyword">this</span>,name,friends);
    <span class="keyword">this</span>.age = age;
}
inheritPrototype(SubType,SuperType);
SubType.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="keyword">return</span> <span class="keyword">this</span>.age;
}
<span class="keyword">var</span> person1 = <span class="keyword">new</span> SubType(<span class="string">"Nico"</span>,[<span class="string">"emi"</span>],<span class="number">22</span>)
<span class="keyword">var</span> person2 = <span class="keyword">new</span> SubType(<span class="string">"Sora"</span>,[<span class="string">"kussn"</span>],<span class="number">33</span>);
person1.friends.push(<span class="string">"Mimo"</span>);
<span class="built_in">console</span>.log(person1.getName() + person1.getAge() + person1.friends);
<span class="built_in">console</span>.log(person2.getName() + person2.getAge() + person2.friends);
</code></pre><p>其实在继承过程中，不必为了指定子类型的原型而调用超类型的构造函数。子类型可以利用寄生式继承来继承超类型的原型。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><em>再把JavaScript中对象的创建与继承复习下</em></p>
<h1 id="对象的创建">对象的创建</h1><hr>
<h2 id="工厂模式">工厂模式</h2><pre><code>console.log(<span class="string">"-----工厂模式-----"</span>);
    function CreatePerson(name,age){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.sayName = function(){
            return name;
        };
        return o;
    }
var <span class="keyword">person</span> = CreatePerson(<span class="string">"Nico"</span>,28);
console.log(<span class="keyword">person</span>.sayName());
</code></pre><p>工厂模式虽然解决了对象的创建问题，但是并没有解决对象的识别问题。<br><code>alert(person.constructor);</code> 得到的并不是想要的结果。<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RegExp类型]]></title>
    <link href="http://blog.supce.com/2016/05/25/JavaScript%E4%B9%8BRegExp%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.supce.com/2016/05/25/JavaScript之RegExp类型/</id>
    <published>2016-05-24T16:00:00.000Z</published>
    <updated>2016-05-25T03:51:07.516Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>今天用到了JavaScript的RegExp，顺便把这部分内容复习了下，敲了敲demo<br>课题组要结题，断更了一段时间，以后会慢慢恢复正常</p>
</blockquote>
<h1 id="RegExp类型">RegExp类型</h1><hr>
<p>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。有两种创建方式</p>
<ul>
<li>字面量<br><code>var p = /pattern/attributes;</code><br>比如：匹配第一个“bat”或“cat”，不区分大小写<br><code>var pattern = /[bc]at/i;</code></li>
<li>RegExp构造函数<br><code>var p = new RegExp(pattern,attributes);</code><br>比如：匹配第一个“bat”或“cat”，不区分大小写<br><code>var pattern = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</code><a id="more"></a>
</li>
</ul>
<blockquote>
<p>注意双重转义</p>
</blockquote>
<pre><code><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;
<span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"i"</span>);  <span class="comment">//由于是字符串所以要进行双重转义</span>
</code></pre><h1 id="RegExp实例方法">RegExp实例方法</h1><p>RegExp对象的主要方法是exec和test</p>
<pre><code>$(<span class="string">"test"</span>).innerHTML += <span class="string">"&lt;/br&gt;-------无全局标识--------&lt;/br&gt;"</span>;
<span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;
<span class="keyword">var</span> patter3 = <span class="regexp">/.at/</span>;
<span class="keyword">var</span> matches = patter3.exec(text);
$(<span class="string">"test"</span>).innerHTML += <span class="string">"mathches.index："</span>+matches.index + <span class="string">" matches[0]："</span> + matches[<span class="number">0</span>] + <span class="string">" lastIndex："</span> +patter3.lastIndex + <span class="string">"&lt;/br&gt;"</span>;
<span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;
<span class="keyword">var</span> patter3 = <span class="regexp">/.at/</span>;
<span class="keyword">var</span> matches = patter3.exec(text);
$(<span class="string">"test"</span>).innerHTML += <span class="string">"mathches.index："</span>+matches.index + <span class="string">" matches[0]："</span> + matches[<span class="number">0</span>] + <span class="string">" lastIndex："</span> +patter3.lastIndex;
$(<span class="string">"test"</span>).innerHTML += <span class="string">"&lt;/br&gt;------带全局标识---------&lt;/br&gt;"</span>;
<span class="keyword">var</span> patter4 = <span class="regexp">/.at/g</span>;
<span class="keyword">var</span> matches = patter4.exec(text);
$(<span class="string">"test"</span>).innerHTML += <span class="string">"mathches.index："</span>+matches.index + <span class="string">" matches[0]："</span> + matches[<span class="number">0</span>] + <span class="string">" lastIndex："</span> +patter3.lastIndex + <span class="string">"&lt;/br&gt;"</span>;
<span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;
<span class="keyword">var</span> patter3 = <span class="regexp">/.at/</span>;
<span class="keyword">var</span> matches = patter4.exec(text);
$(<span class="string">"test"</span>).innerHTML += <span class="string">"mathches.index："</span>+matches.index + <span class="string">" matches[0]："</span> + matches[<span class="number">0</span>] + <span class="string">" lastIndex："</span> +patter4.lastIndex;
$(<span class="string">"test"</span>).innerHTML += <span class="string">"&lt;/br&gt;------test方法---------&lt;/br&gt;"</span>;
<span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;
<span class="keyword">var</span> patter4 = <span class="regexp">/\d{3}-\d{2}-\d{4}/</span>;
<span class="keyword">if</span>(patter4.test(text)){
    $(<span class="string">"test"</span>).innerHTML +=  <span class="string">"The pattern was matched"</span>;
}<span class="keyword">else</span>{
    $(<span class="string">"test"</span>).innerHTML +=  <span class="string">"The pattern was not matched"</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/js1.jpg" alt=""></p>
<h1 id="RegExp构造函数属性">RegExp构造函数属性</h1><p>RegExp构造函数包含一些属性，这些适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。</p>
<pre><code>$(<span class="string">"test"</span>).innerHTML += <span class="string">"&lt;/br&gt;------RegExp构造函数属性---------&lt;/br&gt;"</span>;
<span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;
<span class="keyword">var</span> patter5 = <span class="regexp">/(.)hort/g</span>;
<span class="keyword">if</span>(patter5.test(text)){
    $(<span class="string">"test"</span>).innerHTML += <span class="string">"input:"</span> + <span class="built_in">RegExp</span>.input +  <span class="string">"&lt;/br&gt;leftContext:"</span> + <span class="built_in">RegExp</span>.leftContext + 
    <span class="string">"&lt;/br&gt;rightContext:"</span> + <span class="built_in">RegExp</span>.rightContext + <span class="string">"&lt;/br&gt;lastMatch:"</span> + <span class="built_in">RegExp</span>.lastMatch +
     <span class="string">"&lt;/br&gt;lastParen:"</span> + <span class="built_in">RegExp</span>.lastParen + <span class="string">"&lt;/br&gt;multiline:"</span> + <span class="built_in">RegExp</span>.multiline;  <span class="comment">//不支持multiline</span>
}   
$(<span class="string">"test"</span>).innerHTML += <span class="string">"&lt;/br&gt;------存储捕获组的构造函数属性---------&lt;/br&gt;"</span>;
<span class="keyword">var</span> patter6 = <span class="regexp">/(..)or(.)/g</span>;
<span class="keyword">if</span>(patter6.test(text)){
    $(<span class="string">"test"</span>).innerHTML += <span class="string">"$1："</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span> + <span class="string">"&lt;/br&gt;$2："</span> + <span class="built_in">RegExp</span>.$<span class="number">2</span>;
}
</code></pre><p><img src="http://7xqkrz.com1.z0.glb.clouddn.com/js2.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>今天用到了JavaScript的RegExp，顺便把这部分内容复习了下，敲了敲demo<br>课题组要结题，断更了一段时间，以后会慢慢恢复正常</p>
</blockquote>
<h1 id="RegExp类型">RegExp类型</h1><hr>
<p>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。有两种创建方式</p>
<ul>
<li>字面量<br><code>var p = /pattern/attributes;</code><br>比如：匹配第一个“bat”或“cat”，不区分大小写<br><code>var pattern = /[bc]at/i;</code></li>
<li>RegExp构造函数<br><code>var p = new RegExp(pattern,attributes);</code><br>比如：匹配第一个“bat”或“cat”，不区分大小写<br><code>var pattern = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</code>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IFE Task 03]]></title>
    <link href="http://blog.supce.com/2016/05/17/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%803/"/>
    <id>http://blog.supce.com/2016/05/17/JavaScript之基础3/</id>
    <published>2016-05-16T16:00:00.000Z</published>
    <updated>2016-05-18T02:36:55.056Z</updated>
    <content type="html"><![CDATA[<h1 id="任务目的">任务目的</h1><hr>
<ul>
<li>在上一任务基础上继续JavaScript的体验</li>
<li>深入学习JavaScript的事件机制及DOM操作</li>
<li>学习事件代理机制</li>
<li>学习简单的表单验证功能</li>
<li>学习外部加载JavaScript文件<a id="more"></a>
</li>
</ul>
<h1 id="任务描述">任务描述</h1><ul>
<li>参考以下示例代码，用户输入城市名称和空气质量指数后，点击“确认添加”按钮后，就会将用户的输入在进行验证后，添加到下面的表格中，新增一行进行显示</li>
<li>用户输入的城市名必须为中英文字符，空气质量指数必须为整数</li>
<li>用户输入的城市名字和空气质量指数需要进行前后去空格及空字符处理（trim）</li>
<li>用户输入不合规格时，需要给出提示（允许用alert，也可以自行定义提示方式）</li>
<li>用户可以点击表格列中的“删除”按钮，删掉那一行的数据</li>
</ul>
<h1 id="最终代码">最终代码</h1><h2 id="html">html</h2><pre><code><span class="doctype">&lt;!DOCTYPE&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>IFE JavaScript Task 01<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"js/task16.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">label</span>&gt;</span>城市名称：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"aqi-city-input"</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span>
    <span class="tag">&lt;<span class="title">label</span>&gt;</span>空气质量指数：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"aqi-value-input"</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"add-btn"</span>&gt;</span>确认添加<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">table</span> <span class="attribute">id</span>=<span class="value">"aqi-table"</span>&gt;</span>
  <span class="comment">&lt;!-- 
    &lt;tr&gt;
      &lt;td&gt;城市&lt;/td&gt;&lt;td&gt;空气质量&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;北京&lt;/td&gt;&lt;td&gt;90&lt;/td&gt;&lt;td&gt;&lt;button&gt;删除&lt;/button&gt;&lt;/td&gt;
    &lt;/tr&gt;
   --&gt;</span>
  <span class="tag">&lt;/<span class="title">table</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</code></pre><h2 id="js">js</h2><pre><code><span class="comment">/**
 + aqiData，存储用户输入的空气指数数据
 + 示例格式：
 + aqiData = {
 +    "北京": 90,
 +    "上海": 40
 + };
 */</span>
 var $ = <span class="function"><span class="keyword">function</span><span class="params">(id)</span>{</span>
  return document.getElementById<span class="params">(id)</span>;
 }
var aqiData = {};
<span class="comment">/**
 + 从用户输入中获取数据，向aqiData中增加一条数据
 + 然后渲染aqi-list列表，增加新增的数据
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">addAqiData</span><span class="params">()</span> {</span>
  var city = $<span class="params">(<span class="string">"aqi-city-input"</span>)</span>.value.trim<span class="params">()</span>;
  var num = $<span class="params">(<span class="string">"aqi-value-input"</span>)</span>.value.trim<span class="params">()</span>;
  <span class="keyword">if</span><span class="params">(!city.match<span class="params">(/^[A-Za-z\u4E00-\u9FA5]+$/)</span>)</span>{
    alert<span class="params">(<span class="string">"城市名必须为中英文字符"</span>)</span>;
    return;
  }
  <span class="keyword">if</span><span class="params">(!num.match<span class="params">(/^[<span class="number">0</span>-<span class="number">9</span>]*$/)</span>)</span>{
    alert<span class="params">(<span class="string">"空气质量指数必须为整数"</span>)</span>;
    return;
  }
  aqiData[city] = num;
}
<span class="comment">/**
 + 渲染aqi-table表格
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">renderAqiList</span><span class="params">()</span> {</span>
  var items = <span class="string">"&lt;tr&gt;&lt;td&gt;城市&lt;/td&gt;&lt;td&gt;空气质量&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;"</span>;
  <span class="keyword">for</span><span class="params">(value in aqiData)</span>{
    items += <span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + value + <span class="string">"&lt;/td&gt;&lt;td&gt;"</span> + aqiData[value] 
    - <span class="string">"&lt;/td&gt;&lt;td&gt;"</span> + <span class="string">"&lt;button onclick='delBtnHandle(\""</span> +value+<span class="string">"\")'&gt;删除&lt;/button&gt;&lt;/td&gt;&lt;/tr&gt;"</span>;
  }
  $<span class="params">(<span class="string">"aqi-table"</span>)</span>.innerHTML = items;
}
<span class="comment">/**
 + 点击add-btn时的处理逻辑
 + 获取用户输入，更新数据，并进行页面呈现的更新
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">addBtnHandle</span><span class="params">()</span> {</span>
  addAqiData<span class="params">()</span>;
  renderAqiList<span class="params">()</span>;
}
<span class="comment">/**
 + 点击各个删除按钮的时候的处理逻辑
 + 获取哪个城市数据被删，删除数据，更新表格显示
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">delBtnHandle</span><span class="params">(city)</span> {</span>
  <span class="comment">// do sth.</span>
  delete aqiData[city];
  renderAqiList<span class="params">()</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span> {</span>
  <span class="comment">// 在这下面给add-btn绑定一个点击事件，点击时触发addBtnHandle函数</span>
  $<span class="params">(<span class="string">"add-btn"</span>)</span>.addEventListener<span class="params">(<span class="string">"click"</span>,addBtnHandle,<span class="literal">false</span>)</span>;
  <span class="comment">// 想办法给aqi-table中的所有删除按钮绑定事件，触发delBtnHandle函数</span>
}
init<span class="params">()</span>;
</code></pre><blockquote>
<p>搞定~</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="任务目的">任务目的</h1><hr>
<ul>
<li>在上一任务基础上继续JavaScript的体验</li>
<li>深入学习JavaScript的事件机制及DOM操作</li>
<li>学习事件代理机制</li>
<li>学习简单的表单验证功能</li>
<li>学习外部加载JavaScript文件]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IFE Task 02]]></title>
    <link href="http://blog.supce.com/2016/05/17/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%802/"/>
    <id>http://blog.supce.com/2016/05/17/JavaScript之基础2/</id>
    <published>2016-05-16T16:00:00.000Z</published>
    <updated>2016-05-17T13:44:34.091Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>最近课题要结项，自由支配的时间越发宝贵了</p>
</blockquote>
<h1 id="任务目的">任务目的</h1><hr>
<ul>
<li>在上一任务基础上继续JavaScript的体验</li>
<li>接触一下JavaScript中的高级选择器</li>
<li>学习JavaScript中的数组对象遍历、读写、排序等操作</li>
<li>学习简单的字符串处理操作<a id="more"></a>
</li>
</ul>
<h1 id="任务描述">任务描述</h1><ul>
<li>参考以下示例代码，读取页面上已有的source列表，从中提取出城市以及对应的空气质量</li>
<li>将数据按照某种顺序排序后，在resort列表中按照顺序显示出来</li>
</ul>
<h1 id="任务最终代码">任务最终代码</h1><pre><code><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>{
      <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
    }
    <span class="comment">/**
     + getData方法
     + 读取id为source的列表，获取其中城市名字及城市对应的空气质量
     + 返回一个数组，格式见函数中示例
     */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>{
      <span class="comment">/*
      coding here
      */</span>
      <span class="comment">/*
      data = [
        ["北京", 90],
        ["北京", 90]
        ……
      ]
      */</span>
      <span class="keyword">var</span> data = [];
      <span class="keyword">var</span> li = $(<span class="string">'source'</span>).getElementsByTagName(<span class="string">'li'</span>);
      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;li.length; i++){
        <span class="keyword">var</span> city = li[i].innerHTML.split(<span class="string">"空气质量："</span>)[<span class="number">0</span>];

        <span class="keyword">var</span> num = li[i].getElementsByTagName(<span class="string">'b'</span>)[<span class="number">0</span>].innerHTML;
        <span class="comment">//var num = Number(li.children[0].innerHTML);</span>

        data[data.length] = [city,num];
        <span class="comment">//data.push([city,num]);</span>
      }
      <span class="built_in">console</span>.log(data.length);
      <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     + sortAqiData
     + 按空气质量对data进行从小到大的排序
     + 返回一个排序后的数组
     */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">sortAqiData</span>(<span class="params">data</span>) </span>{
      data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>{
        <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];
      });
      <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     + render
     + 将排好序的城市及空气质量指数，输出显示到id位resort的列表中
     + 格式见ul中的注释的部分
     */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data</span>) </span>{
      <span class="keyword">var</span> chineseNum = [<span class="string">"零"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span>, <span class="string">"七"</span>, <span class="string">"八"</span>, <span class="string">"九"</span>];
      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;data.length; i++){
        $(<span class="string">"resort"</span>).innerHTML += <span class="string">"&lt;li&gt;第"</span> + chineseNum[i+<span class="number">1</span>] +　<span class="string">"名："</span> + data[i][<span class="number">0</span>] + <span class="string">"空气质量：&lt;b&gt;"</span> + data[i][<span class="number">1</span>] + <span class="string">"&lt;/b&gt;&lt;/li&gt;"</span>;
      }
    }
    <span class="function"><span class="keyword">function</span> <span class="title">btnHandle</span>(<span class="params"></span>) </span>{
      <span class="keyword">var</span> aqiData = getData();
      aqiData = sortAqiData(aqiData);
      render(aqiData);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>{
      <span class="comment">// 在这下面给sort-btn绑定一个点击事件，点击时触发btnHandle函数</span>
      $(<span class="string">"sort-btn"</span>).addEventListener(<span class="string">"click"</span>,btnHandle,<span class="literal">false</span>);
    }
    init();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>最近课题要结项，自由支配的时间越发宝贵了</p>
</blockquote>
<h1 id="任务目的">任务目的</h1><hr>
<ul>
<li>在上一任务基础上继续JavaScript的体验</li>
<li>接触一下JavaScript中的高级选择器</li>
<li>学习JavaScript中的数组对象遍历、读写、排序等操作</li>
<li>学习简单的字符串处理操作]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IFE Task 01]]></title>
    <link href="http://blog.supce.com/2016/05/10/JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.supce.com/2016/05/10/JavaScript之基础/</id>
    <published>2016-05-09T16:00:00.000Z</published>
    <updated>2016-05-13T07:48:58.335Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>前一段时间一直在写 CSS，以后这段时间会把百度前端学院有关 JavaScript 的任务写一写</p>
</blockquote>
<h1 id="任务一">任务一</h1><hr>
<h2 id="任务目的">任务目的</h2><ul>
<li>JavaScript初体验</li>
<li>初步明白JavaScript的简单基本语法，如变量、函数</li>
<li>初步了解JavaScript的事件是什么</li>
<li>初步了解JavaScript中的DOM是什么<a id="more"></a>
</li>
</ul>
<h2 id="任务描述">任务描述</h2><ul>
<li>参考以下示例代码，补充其中的JavaScript功能，完成一个JavaScript代码的编写</li>
<li>本任务完成的功能为：用户可以在输入框中输入任何内容，点击“确认填写”按钮后，用户输入的内容会显示在“您输入的值是”文字的右边</li>
</ul>
<h2 id="最终代码">最终代码</h2><pre><code><span class="tag">&lt;<span class="title">label</span>&gt;</span>请输入北京今天空气质量：<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"aqi-input"</span> <span class="attribute">type</span>=<span class="value">"text"</span>&gt;</span><span class="tag">&lt;/<span class="title">label</span>&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"button"</span>&gt;</span>确认填写<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span>&gt;</span>您输入的值是：<span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"aqi-display"</span>&gt;</span>尚无录入<span class="tag">&lt;/<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
      <span class="comment">/*    
      在注释下方写下代码
      给按钮button绑定一个点击事件
      在事件处理函数中
      获取aqi-input输入的值，并显示在aqi-display中
      */</span>
      <span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>{
        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);
      }
      <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        <span class="keyword">var</span> num = <span class="built_in">parseInt</span>($(<span class="string">"aqi-input"</span>).value)
        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(num) &amp;&amp; num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">500</span>) {
          $(<span class="string">"aqi-display"</span>).innerHTML = $(<span class="string">"aqi-input"</span>).value;
        }<span class="keyword">else</span>{
          $(<span class="string">"aqi-display"</span>).innerHTML = <span class="string">"请输入范围为0-500的效数字"</span>;
        }
      }
      $(<span class="string">"button"</span>).addEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);

  })();
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><blockquote>
<p>第一个任务还是很哪里不会点哪里的。</p>
</blockquote>
<h1 id="任务二">任务二</h1><hr>
<h2 id="任务目的-1">任务目的</h2><ul>
<li>在上一任务基础上继续JavaScript的体验</li>
<li>学习JavaScript中的if判断语法，for循环语法</li>
<li>学习JavaScript中的数组对象</li>
<li>学习如何读取、处理数据，并动态创建、修改DOM中的内容</li>
</ul>
<h2 id="任务描述-1">任务描述</h2><ul>
<li>参考以下示例代码，页面加载后，将提供的空气质量数据数组，按照某种逻辑（比如空气质量大于60）进行过滤筛选，最后将符合条件的数据按照一定的格式要求显示在网页上</li>
</ul>
<h2 id="最终代码-1">最终代码</h2><pre><code>&lt;h3&gt;污染城市列表&lt;/h3&gt;
&lt;ul id=<span class="string">"aqi-list"</span>&gt;
&lt;!--   
  &lt;li&gt;第一名：福州（样例），<span class="number">10</span>&lt;/li&gt;
  &lt;li&gt;第二名：福州（样例），<span class="number">10</span>&lt;/li&gt; --&gt;
&lt;/ul&gt;
&lt;script <span class="keyword">type</span>=<span class="string">"text/javascript"</span>&gt;
  <span class="keyword">var</span> aqiData = [
    [<span class="string">"北京"</span>, <span class="number">90</span>],
    [<span class="string">"上海"</span>, <span class="number">50</span>],
    [<span class="string">"福州"</span>, <span class="number">10</span>],
    [<span class="string">"石家庄"</span>, <span class="number">320</span>],
    [<span class="string">"邯郸"</span>, <span class="number">301</span>],
    [<span class="string">"广州"</span>, <span class="number">50</span>],
    [<span class="string">"成都"</span>, <span class="number">90</span>],
    [<span class="string">"西安"</span>, <span class="number">100</span>]

  ];

  (function () {
      /*
      在注释下方编写代码
      遍历读取aqiData中各个城市的数据
      将空气质量指数大于<span class="number">60</span>的城市显示到aqi-list的列表中
      */
      <span class="keyword">var</span> $ = function(id){
        <span class="keyword">return</span> document.getElementById(id);
      }
      <span class="keyword">var</span> <span class="literal">result</span> = aqiData.filter(function(value){
        <span class="keyword">return</span> (value[<span class="number">1</span>] &gt; <span class="number">60</span>);
      });
      <span class="literal">result</span>.sort(function(a,b){
        <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];
      });
      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="literal">result</span>.length; i++){
        $(<span class="string">"aqi-list"</span>).innerHTML += <span class="string">"&lt;li&gt;第"</span> + (i+<span class="number">1</span>) + <span class="string">"名："</span> + <span class="literal">result</span>[i][<span class="number">0</span>] + <span class="string">"(样例)，"</span> + <span class="literal">result</span>[i][<span class="number">1</span>] + <span class="string">"&lt;/li&gt;"</span>;
      }
   })();
&lt;/script&gt;
</code></pre><blockquote>
<p>这里对数组操作比较多，下面简单复习下数组。</p>
</blockquote>
<h1 id="Array">Array</h1><hr>
<h2 id="Array的创建">Array的创建</h2><p>数组的创建方式 分为以下两种</p>
<h3 id="使用Array构造函数">使用Array构造函数</h3><p><code>var persons = new Array();</code><br>可以指定数组长度，比如长度为5的数组<br><code>var persons = new Array(5);</code><br>可以直接在构造函数中传递数组中包含的项<br><code>var persons = new Array(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</code></p>
<blockquote>
<p>使用构造函数时可以省略new关键字<br><code>var persons = Array(4);</code></p>
</blockquote>
<h3 id="使用数组字面量">使用数组字面量</h3><p><code>var persons = [];  //空数组</code><br><code>var persons = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;];</code></p>
<h2 id="数组的长度">数组的长度</h2><pre><code><span class="variable"><span class="keyword">var</span> persons</span> = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>];
alert(persons.length);  <span class="comment">//3</span>
</code></pre><p>可以利用lenght来给数组添加新的项</p>
<pre><code>persons[persons.<span class="built_in">length</span>] = <span class="string">"赵六"</span>; <span class="comment"> //在数组末尾添加新的项</span>
</code></pre><h2 id="数组的判断">数组的判断</h2><p>想要判断某个对象是否是数组，可以利用<code>Array.isArray()</code>方法</p>
<pre><code><span class="keyword">if</span><span class="params">(Array.isArray<span class="params">(someObject)</span>)</span>{
  <span class="comment">//对数组进行操作</span>
}
</code></pre><h2 id="转换方法">转换方法</h2><h3 id="toString()方法">toString()方法</h3><p>数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</p>
<pre><code><span class="variable"><span class="keyword">var</span> persons</span> = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>];
alert(persons.toString());  <span class="comment">//返回一个字符串"张三,李四,王五"</span>
</code></pre><blockquote>
<p>关于toString和valueOf这两个方法的区别请点<a href="">这里</a></p>
</blockquote>
<h3 id="join()方法">join()方法</h3><p>如果想要用不同的分隔符来构建字符串 可以使用join方法，该方法只接收一个参数，用来作为字符串的分隔符。</p>
<pre><code><span class="keyword">var</span> persons = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>];
alert(persons.<span class="keyword">join</span>(<span class="string">"&amp;"</span>)); 
</code></pre><h2 id="栈方法">栈方法</h2><p>栈是一种先进后出的数据结构 在JavaScript数组中可以利用push和pop进行入栈和出栈。<br>push方法可以接收任意数量的参数，把它们添加到数组末尾，并返回修改后的数组长度。pop方法从数组末尾移除最后一项，减少数组的长度值，然后返回移除的项。</p>
<pre><code><span class="variable"><span class="keyword">var</span> persons</span> = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"王五"</span>];
<span class="variable"><span class="keyword">var</span> length</span> = persons.push(<span class="string">"赵六"</span>,<span class="string">"麻七"</span>);
alert(persons.pop());  <span class="comment">//麻七</span>
</code></pre><h2 id="队列方法">队列方法</h2><p>队列即先进先出 利用<code>shift()</code>移除数组第一项并返回该项，数组长度减1，<code>push()</code>向数组末端添加新的项，并返回数组长度<br><code>unshift()</code>方法能在数组前端添加任意个项并返回新数组的长度</p>
<h2 id="重排序">重排序</h2><h3 id="数组的反转">数组的反转</h3><p>可以利用<code>reverse()</code>对数组进行反转</p>
<pre><code><span class="keyword">var</span> <span class="keyword">test</span> = [1,2,3];
alert(<span class="keyword">test</span>.<span class="literal">reverse</span>()); <span class="comment">//3,2,1</span>
</code></pre><h3 id="数组的排序">数组的排序</h3><p>可以使用<code>sort()</code>方法按照升序对数组进行排序。sort方法会调用每个数组项的toString方法，对得到的字符串进行比较，即使数组项是数值，也是比较的字符串。<br>sort方法可以接收一个比较函数，该函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数<br>在第二个任务中的sort就进行了降序排列</p>
<pre><code><span class="literal">result</span>.sort(function(a,b){
    <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];
});
</code></pre><h2 id="操作方法">操作方法</h2><h3 id="数组的合并">数组的合并</h3><h4 id="concat方法">concat方法</h4><p>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。</p>
<pre><code><span class="variable"><span class="keyword">var</span> persons</span> = [<span class="string">"张三"</span>,<span class="string">"李四"</span>];
<span class="variable"><span class="keyword">var</span> people</span> = persons.concat(<span class="string">"Tom"</span>,[<span class="string">"王五"</span>,<span class="string">"赵六"</span>]);
</code></pre><h4 id="reduce或者reduceright方法">reduce或者reduceright方法</h4><blockquote>
<p>JS中的归并下面说，这里直接贴小例子了</p>
</blockquote>
<pre><code><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="keyword">var</span> num2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]
<span class="keyword">var</span> <span class="literal">result</span> = num2.reduce(function(pre,cur,index,<span class="type">array</span>){
    pre.push(cur);
    <span class="keyword">return</span> pre;
},num);
alert(<span class="literal">result</span>);  //<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>
</code></pre><h3 id="数组的复制">数组的复制</h3><p>利用<code>slice()</code>方法可以对数组进行复制，该方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项（不包括结束位置的项）</p>
<pre><code>var persons = [<span class="string">"张三"</span>,<span class="string">"李四"</span>,<span class="string">"Tom"</span>,<span class="string">"王五"</span>,<span class="string">"赵六"</span>];
alert(persons.slice(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment">//李四,Tom</span>
</code></pre><h3 id="数组的插入">数组的插入</h3><p>在数组中一般使用splice来进行插入。详细用法如下</p>
<ul>
<li><p>删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。</p>
<p>  var persons = [“张三”,”李四”,”Tom”,”王五”,”赵六”];<br>  persons.splice(0,2); //删除前两项</p>
</li>
<li><p>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。</p>
<p>  <code>var persons = [&quot;张三&quot;,&quot;李四&quot;,&quot;Tom&quot;,&quot;王五&quot;,&quot;赵六&quot;];</code><br>  <code>person.splice(1,0,&quot;John&quot;,&quot;Snow&quot;); //张三,John,Snow,李四...</code></p>
</li>
<li><p>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等</p>
<p>  <code>var persons = [&quot;张三&quot;,&quot;李四&quot;,&quot;Tom&quot;,&quot;王五&quot;,&quot;赵六&quot;];</code><br>  <code>person.splice(1,2,&quot;John&quot;,&quot;Snow&quot;); //张三,John,Snow,王五...</code></p>
</li>
</ul>
<blockquote>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何项，则返回一个空数组)</p>
</blockquote>
<h3 id="位置方法">位置方法</h3><p>利用indexOf和lastIndexOf，两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。最终返回查找项在数组中的索引，如果没有查到则返回-1<br>indexOf默认从索引为0出向后查找，lastIndexOf反之。</p>
<h3 id="迭代方法">迭代方法</h3><blockquote>
<p>以下方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。</p>
</blockquote>
<ul>
<li>some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true </li>
<li>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true </li>
<li>forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
</ul>
<blockquote>
<p>下面列几个小例子</p>
</blockquote>
<pre><code><span class="keyword">var</span> num = [<span class="number">90</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">200</span>,<span class="number">320</span>];
num.some(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{
  <span class="keyword">return</span> item&gt;<span class="number">20</span>;
});  <span class="comment">//true</span>
num.every(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{
  <span class="keyword">return</span> item&gt;<span class="number">20</span>;
});  <span class="comment">//false</span>
num.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{
  <span class="comment">//对每一项进行某些操作</span>
});
num.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{
  <span class="keyword">return</span> item-<span class="number">10</span>;
});  <span class="comment">//[80,40,0,190,310]</span>
num.filter(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{
  <span class="keyword">return</span> item&gt;<span class="number">60</span>;
}); [<span class="number">90</span>,<span class="number">200</span>,<span class="number">320</span>]
</code></pre><h3 id="归并方法">归并方法</h3><p>也就是刚才在数组合并那里用到的reduce和reduceRight，这两个函数会接收四个参数：<br>前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br>比如求数组中所有数值的和</p>
<pre><code>ar values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];
var sum = values.reduce(function(pre,cur,index,<span class="built_in">array</span>){
    <span class="keyword">return</span> pre + cur;
});
alert(sum)  <span class="comment">//15;</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>前一段时间一直在写 CSS，以后这段时间会把百度前端学院有关 JavaScript 的任务写一写</p>
</blockquote>
<h1 id="任务一">任务一</h1><hr>
<h2 id="任务目的">任务目的</h2><ul>
<li>JavaScript初体验</li>
<li>初步明白JavaScript的简单基本语法，如变量、函数</li>
<li>初步了解JavaScript的事件是什么</li>
<li>初步了解JavaScript中的DOM是什么]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.supce.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
